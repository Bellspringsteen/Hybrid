CCS PCM C Compiler, Version 4.084, 46530               04-Jul-12 12:59

               Filename: HondaHybrid.lst

               ROM used: 230 words (6%)
                         Largest free fragment is 1818
               RAM used: 25 (14%) at main() level
                         28 (16%) worst case
               Stack:    2 worst case (1 in main + 1 for interrupts)

*
0000:  NOP
0001:  MOVLW  00
0002:  MOVWF  0A
0003:  GOTO   075
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  26
0008:  MOVF   7F,W
0009:  MOVWF  25
000A:  MOVF   0A,W
000B:  MOVWF  2D
000C:  CLRF   0A
000D:  SWAPF  25,F
000E:  MOVF   04,W
000F:  MOVWF  27
0010:  MOVF   20,W
0011:  MOVWF  28
0012:  MOVF   21,W
0013:  MOVWF  29
0014:  MOVF   22,W
0015:  MOVWF  2A
0016:  MOVF   23,W
0017:  MOVWF  2B
0018:  MOVF   24,W
0019:  MOVWF  2C
001A:  BCF    03.7
001B:  BCF    03.5
001C:  MOVLW  8C
001D:  MOVWF  04
001E:  BTFSS  00.0
001F:  GOTO   022
0020:  BTFSC  0C.0
0021:  GOTO   035
0022:  MOVF   27,W
0023:  MOVWF  04
0024:  MOVF   28,W
0025:  MOVWF  20
0026:  MOVF   29,W
0027:  MOVWF  21
0028:  MOVF   2A,W
0029:  MOVWF  22
002A:  MOVF   2B,W
002B:  MOVWF  23
002C:  MOVF   2C,W
002D:  MOVWF  24
002E:  MOVF   2D,W
002F:  MOVWF  0A
0030:  SWAPF  26,W
0031:  MOVWF  03
0032:  SWAPF  7F,F
0033:  SWAPF  7F,W
0034:  RETFIE
0035:  BCF    0A.3
0036:  GOTO   037
.................... #include "C:\Documents and Settings\Enter\My Documents\Hybrid\Hybrid-v2\HondaHybrid.h" 
.................... #include <16F873A.h> 
.................... //////// Standard Header file for the PIC16F873A device //////////////// 
.................... #device PIC16F873A 
.................... #list 
....................  
....................  
.................... //#include <16F737.h> 
.................... #device ICD=TRUE 
.................... #device adc=10 
.................... //#device adc=8 
.................... #use delay(clock=20000000) 
*
0061:  MOVLW  38
0062:  MOVWF  04
0063:  MOVF   00,W
0064:  BTFSC  03.2
0065:  GOTO   073
0066:  MOVLW  06
0067:  MOVWF  21
0068:  CLRF   20
0069:  DECFSZ 20,F
006A:  GOTO   069
006B:  DECFSZ 21,F
006C:  GOTO   068
006D:  MOVLW  7B
006E:  MOVWF  20
006F:  DECFSZ 20,F
0070:  GOTO   06F
0071:  DECFSZ 00,F
0072:  GOTO   066
0073:  BCF    0A.3
0074:  GOTO   0E4 (RETURN)
.................... #fuses HS,NOWDT 
.................... #use rs232 (debugger,STREAM=MONITOR) 
.................... #include <mcp4921.c> 
.................... //////////////// Driver for MCP4921 D/A Converter /////////////////////// 
.................... ////                                                                 //// 
.................... ////  init_dac()    Call this before using a MCP4921 DAC             //// 
.................... ////                                                                 //// 
.................... ////  write_dac( long int )   Writes command and 12 bit resolution   //// 
.................... ////                          to the MCP4921 which converts it to a  //// 
.................... ////                          voltage                                //// 
.................... ////                          0-4095 input represents 0-vref V out.  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SELECT 
....................  
.................... #define DAC_CS     PIN_C4 
.................... #define DAC_CLK    PIN_C3 
.................... #define DAC_DI     PIN_C5 
.................... #define DAC_LDAC   PIN_B4 
....................  
.................... #endif 
....................  
.................... void init_dac() 
.................... { 
....................    output_high(DAC_CS); 
....................    output_high(DAC_LDAC); 
....................    output_high(DAC_CLK); 
....................    output_high(DAC_DI); 
.................... } 
....................  
.................... void write_dac(int16 data) { 
....................    BYTE cmd[3]; 
....................    BYTE i; 
....................  
....................    cmd[0]=data; 
....................    cmd[1]=(data>>8); 
....................    cmd[2]=0x03;                            
....................     
....................    output_high(DAC_LDAC); 
....................    output_low(DAC_CLK); 
....................    output_low(DAC_CS); 
....................  
....................    for(i=0; i<=23; ++i) 
....................    { 
....................       if(i<4 || (i>7 && i<12)) 
....................          shift_left(cmd,3,0); 
....................       else 
....................       { 
....................          output_bit(DAC_DI, shift_left(cmd,3,0)); 
....................  
....................          output_high(DAC_CLK); 
....................          output_low(DAC_CLK); 
....................       } 
....................    } 
....................    output_high(DAC_CS); 
....................  
....................    output_low(DAC_LDAC); 
....................    delay_us(10); 
....................     
....................    output_HIGH(DAC_LDAC); 
.................... } 
....................  
....................  
....................  
....................  
.................... #define servo_pin PIN_B1  //Setting servo out pin to be hardware pin b1 
.................... /* 
.................... Clock Interrupt Settings 
....................  
.................... Number of operations per second is CLOCK/4/Timer Divisions 
.................... Number of operations per second is 20,000,000/4/2 = 2,500,000  
....................  
.................... Each operation takes 1/2,500,000 = 400 nano seconds 
....................  
.................... The period for the servo is .020 seconds which is 50,000 operations 
.................... The leftmost position of the server is .001 seconds which is 2,500 
.................... The rightmost position of the server is .002 seconds which is 5,000 
....................  
.................... */ 
.................... static int16 left_position = 2500; 
*
0086:  MOVLW  C4
0087:  MOVWF  2F
0088:  MOVLW  09
0089:  MOVWF  30
.................... static int16 right_position = 5000; 
008A:  MOVLW  88
008B:  MOVWF  31
008C:  MOVLW  13
008D:  MOVWF  32
.................... static int16 servo_period   = 65356-50000; 
008E:  MOVLW  FC
008F:  MOVWF  33
0090:  MOVLW  3B
0091:  MOVWF  34
....................  
.................... unsigned int16 current_servo_position=2500; 
0092:  MOVLW  C4
0093:  MOVWF  35
0094:  MOVLW  09
0095:  MOVWF  36
.................... int1 SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0; 
0096:  BCF    37.0
....................  
.................... #int_timer1 
.................... void isr() 
.................... { 
....................    if(SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER) 
*
0037:  BTFSS  37.0
0038:  GOTO   04C
....................       {  
....................          output_high(servo_pin);                     //Set the servo control pin to high  
0039:  BSF    03.5
003A:  BCF    06.1
003B:  BCF    03.5
003C:  BSF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0;  
003D:  BCF    37.0
....................          set_timer1(65356-current_servo_position);                 //Set timer for the position high pulse 
003E:  MOVF   35,W
003F:  SUBLW  4C
0040:  MOVWF  39
0041:  MOVLW  FF
0042:  MOVWF  3A
0043:  MOVF   36,W
0044:  BTFSS  03.0
0045:  INCFSZ 36,W
0046:  SUBWF  3A,F
0047:  MOVF   3A,W
0048:  MOVWF  0F
0049:  MOVF   39,W
004A:  MOVWF  0E
....................       }  
....................    else  
004B:  GOTO   05E
....................       {  
....................          output_low(servo_pin);                      // Set the servo control pin to low   
004C:  BSF    03.5
004D:  BCF    06.1
004E:  BCF    03.5
004F:  BCF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 1;  
0050:  BSF    37.0
....................          set_timer1(servo_period+current_servo_position);          //Set timer for the low position the length is the difference between  
0051:  MOVF   35,W
0052:  ADDWF  33,W
0053:  MOVWF  39
0054:  MOVF   34,W
0055:  MOVWF  3A
0056:  MOVF   36,W
0057:  BTFSC  03.0
0058:  INCFSZ 36,W
0059:  ADDWF  3A,F
005A:  MOVF   3A,W
005B:  MOVWF  0F
005C:  MOVF   39,W
005D:  MOVWF  0E
....................                                                      //the total int16 lenght - high pulse length 
....................       }   
.................... } 
....................  
....................  
....................  
005E:  BCF    0C.0
005F:  BCF    0A.3
0060:  GOTO   022
.................... void main() 
.................... {   
*
0075:  CLRF   04
0076:  MOVLW  1F
0077:  ANDWF  03,F
0078:  BSF    03.5
0079:  BCF    06.3
007A:  BCF    03.5
007B:  BSF    06.3
007C:  BSF    03.5
007D:  BSF    1F.0
007E:  BSF    1F.1
007F:  BSF    1F.2
0080:  BCF    1F.3
0081:  MOVLW  07
0082:  MOVWF  1C
....................     
....................    setup_adc_ports(NO_ANALOGS); 
*
0097:  BSF    03.5
0098:  BSF    1F.0
0099:  BSF    1F.1
009A:  BSF    1F.2
009B:  BCF    1F.3
....................    setup_adc(ADC_OFF); 
009C:  BCF    03.5
009D:  BCF    1F.0
....................    setup_spi(FALSE); 
009E:  CLRF   14
....................    setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
009F:  BSF    03.5
00A0:  MOVF   01,W
00A1:  ANDLW  C0
00A2:  IORLW  00
00A3:  MOVWF  01
00A4:  CLRWDT
....................    setup_timer_1(T1_DISABLED); 
00A5:  BCF    03.5
00A6:  CLRF   10
....................    setup_timer_2(T2_DISABLED,0,1); 
00A7:  MOVLW  00
00A8:  MOVWF  21
00A9:  MOVWF  12
00AA:  MOVLW  00
00AB:  BSF    03.5
00AC:  MOVWF  12
....................    setup_port_a(ALL_ANALOG); 
00AD:  BCF    1F.0
00AE:  BCF    1F.1
00AF:  BCF    1F.2
00B0:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
00B1:  BCF    1F.6
00B2:  BCF    03.5
00B3:  BSF    1F.6
00B4:  BSF    1F.7
00B5:  BSF    03.5
00B6:  BSF    1F.7
00B7:  BCF    03.5
00B8:  BSF    1F.0
....................    //init_dac(); 
....................   
....................  
....................     
....................    //printf("\n\rHigh time (sampled every second):\n\r"); 
....................    //setup_ccp1(CCP_COMPARE_INT);    // Configure CCP1 to capture rise 
....................    //setup_ccp2(CCP_CAPTURE_FE);    // Configure CCP2 to capture fall 
....................    setup_timer_1(T1_DIV_BY_2| T1_INTERNAL);  
00B9:  MOVLW  95
00BA:  MOVWF  10
....................  
....................    //setup_timer_2(T2_DIV_BY_16,255,1); 
....................    enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
00BB:  BSF    03.5
00BC:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
00BD:  MOVLW  C0
00BE:  BCF    03.5
00BF:  IORWF  0B,F
....................    while(TRUE) { 
....................    if (current_servo_position<left_position){ 
00C0:  MOVF   36,W
00C1:  SUBWF  30,W
00C2:  BTFSS  03.0
00C3:  GOTO   0CF
00C4:  BTFSS  03.2
00C5:  GOTO   0CA
00C6:  MOVF   2F,W
00C7:  SUBWF  35,W
00C8:  BTFSC  03.0
00C9:  GOTO   0CF
....................       current_servo_position = left_position; 
00CA:  MOVF   30,W
00CB:  MOVWF  36
00CC:  MOVF   2F,W
00CD:  MOVWF  35
....................    } 
....................    else if (current_servo_position > right_position){ 
00CE:  GOTO   0E1
00CF:  MOVF   32,W
00D0:  SUBWF  36,W
00D1:  BTFSS  03.0
00D2:  GOTO   0DE
00D3:  BTFSS  03.2
00D4:  GOTO   0D9
00D5:  MOVF   35,W
00D6:  SUBWF  31,W
00D7:  BTFSC  03.0
00D8:  GOTO   0DE
....................       current_servo_position = left_position; 
00D9:  MOVF   30,W
00DA:  MOVWF  36
00DB:  MOVF   2F,W
00DC:  MOVWF  35
....................    } 
....................    else { 
00DD:  GOTO   0E1
....................       current_servo_position++; 
00DE:  INCF   35,F
00DF:  BTFSC  03.2
00E0:  INCF   36,F
....................    } 
....................       //fprintf(MONITOR,"Hello"); 
....................       //left_adjust++; 
....................       //output_low(servo_pin); 
....................       delay_ms(10); 
00E1:  MOVLW  0A
00E2:  MOVWF  38
00E3:  GOTO   061
....................       //left_adjust--; 
....................       //delay_ms(1000); 
....................       //output_high(servo_pin); 
....................       //delay_ms(1000); 
....................       //write_dac(output); 
....................    } 
00E4:  GOTO   0C0
....................     
....................  
.................... } 
....................  
....................  
....................  
00E5:  GOTO   0E5

Configuration Fuses:
   Word  1: 373A   HS NOWDT NOPUT DEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
