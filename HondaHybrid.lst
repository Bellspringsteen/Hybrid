CCS PCM C Compiler, Version 4.084, 46530               15-Nov-12 00:53

               Filename: HondaHybrid.lst

               ROM used: 1230 words (32%)
                         Largest free fragment is 1788
               RAM used: 48 (27%) at main() level
                         66 (37%) worst case
               Stack:    2 worst case (1 in main + 1 for interrupts)

*
0000:  NOP
0001:  MOVLW  00
0002:  MOVWF  0A
0003:  GOTO   3D5
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  26
0008:  MOVF   7F,W
0009:  MOVWF  25
000A:  MOVF   0A,W
000B:  MOVWF  2D
000C:  CLRF   0A
000D:  SWAPF  25,F
000E:  MOVF   04,W
000F:  MOVWF  27
0010:  MOVF   20,W
0011:  MOVWF  28
0012:  MOVF   21,W
0013:  MOVWF  29
0014:  MOVF   22,W
0015:  MOVWF  2A
0016:  MOVF   23,W
0017:  MOVWF  2B
0018:  MOVF   24,W
0019:  MOVWF  2C
001A:  BCF    03.7
001B:  BCF    03.5
001C:  MOVLW  8C
001D:  MOVWF  04
001E:  BTFSS  00.0
001F:  GOTO   022
0020:  BTFSC  0C.0
0021:  GOTO   03F
0022:  MOVLW  8D
0023:  MOVWF  04
0024:  BTFSS  00.0
0025:  GOTO   028
0026:  BTFSC  0D.0
0027:  GOTO   041
0028:  BTFSS  0B.5
0029:  GOTO   02C
002A:  BTFSC  0B.2
002B:  GOTO   043
002C:  MOVF   27,W
002D:  MOVWF  04
002E:  MOVF   28,W
002F:  MOVWF  20
0030:  MOVF   29,W
0031:  MOVWF  21
0032:  MOVF   2A,W
0033:  MOVWF  22
0034:  MOVF   2B,W
0035:  MOVWF  23
0036:  MOVF   2C,W
0037:  MOVWF  24
0038:  MOVF   2D,W
0039:  MOVWF  0A
003A:  SWAPF  26,W
003B:  MOVWF  03
003C:  SWAPF  7F,F
003D:  SWAPF  7F,W
003E:  RETFIE
003F:  BCF    0A.3
0040:  GOTO   051
0041:  BCF    0A.3
0042:  GOTO   098
0043:  BCF    0A.3
0044:  GOTO   045
.................... #include "C:\Documents and Settings\Enter\My Documents\Hybrid\Hybrid-v2\HondaHybrid.h" 
.................... #include <16F873A.h> 
.................... //////// Standard Header file for the PIC16F873A device //////////////// 
.................... #device PIC16F873A 
.................... #list 
....................  
....................  
.................... //#include <16F737.h> 
.................... #device ICD=TRUE 
.................... #device adc=10 
.................... //#device adc=8 
.................... #use delay(clock=20000000) 
.................... #fuses HS,PUT,NOWDT 
.................... #use rs232 (DEBUGGER) 
.................... #include <mcp4921.c> 
.................... //////////////// Driver for MCP4921 D/A Converter /////////////////////// 
.................... ////                                                                 //// 
.................... ////  init_dac()    Call this before using a MCP4921 DAC             //// 
.................... ////                                                                 //// 
.................... ////  write_dac( long int )   Writes command and 12 bit resolution   //// 
.................... ////                          to the MCP4921 which converts it to a  //// 
.................... ////                          voltage                                //// 
.................... ////                          0-4095 input represents 0-vref V out.  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SELECT 
....................  
.................... #define DAC_CS     PIN_C4 
.................... #define DAC_CLK    PIN_C3 
.................... #define DAC_DI     PIN_C5 
.................... #define DAC_LDAC   PIN_B4 
....................  
.................... #endif 
....................  
.................... void init_dac() 
.................... { 
....................    output_high(DAC_CS); 
*
00A3:  BCF    2E.4
00A4:  MOVF   2E,W
00A5:  BSF    03.5
00A6:  MOVWF  07
00A7:  BCF    03.5
00A8:  BSF    07.4
....................    output_high(DAC_LDAC); 
00A9:  BSF    03.5
00AA:  BCF    06.4
00AB:  BCF    03.5
00AC:  BSF    06.4
....................    output_high(DAC_CLK); 
00AD:  BCF    2E.3
00AE:  MOVF   2E,W
00AF:  BSF    03.5
00B0:  MOVWF  07
00B1:  BCF    03.5
00B2:  BSF    07.3
....................    output_high(DAC_DI); 
00B3:  BCF    2E.5
00B4:  MOVF   2E,W
00B5:  BSF    03.5
00B6:  MOVWF  07
00B7:  BCF    03.5
00B8:  BSF    07.5
.................... } 
00B9:  BCF    0A.3
00BA:  GOTO   426 (RETURN)
....................  
.................... void write_dac(int16 data) { 
....................    BYTE cmd[3]; 
....................    BYTE i; 
....................  
....................    cmd[0]=data; 
*
0378:  MOVF   49,W
0379:  MOVWF  4B
....................    cmd[1]=(data>>8); 
037A:  MOVF   4A,W
037B:  MOVWF  4C
....................    cmd[2]=0x03;                            
037C:  MOVLW  03
037D:  MOVWF  4D
....................     
....................    output_high(DAC_LDAC); 
037E:  BSF    03.5
037F:  BCF    06.4
0380:  BCF    03.5
0381:  BSF    06.4
....................    output_low(DAC_CLK); 
0382:  BCF    2E.3
0383:  MOVF   2E,W
0384:  BSF    03.5
0385:  MOVWF  07
0386:  BCF    03.5
0387:  BCF    07.3
....................    output_low(DAC_CS); 
0388:  BCF    2E.4
0389:  MOVF   2E,W
038A:  BSF    03.5
038B:  MOVWF  07
038C:  BCF    03.5
038D:  BCF    07.4
....................  
....................    for(i=0; i<=23; ++i) 
038E:  CLRF   4E
038F:  MOVF   4E,W
0390:  SUBLW  17
0391:  BTFSS  03.0
0392:  GOTO   3C0
....................    { 
....................       if(i<4 || (i>7 && i<12)) 
0393:  MOVF   4E,W
0394:  SUBLW  03
0395:  BTFSC  03.0
0396:  GOTO   39F
0397:  MOVF   4E,W
0398:  SUBLW  07
0399:  BTFSC  03.0
039A:  GOTO   3A4
039B:  MOVF   4E,W
039C:  SUBLW  0B
039D:  BTFSS  03.0
039E:  GOTO   3A4
....................          shift_left(cmd,3,0); 
039F:  BCF    03.0
03A0:  RLF    4B,F
03A1:  RLF    4C,F
03A2:  RLF    4D,F
....................       else 
03A3:  GOTO   3BE
....................       { 
....................          output_bit(DAC_DI, shift_left(cmd,3,0)); 
03A4:  BCF    03.0
03A5:  RLF    4B,F
03A6:  RLF    4C,F
03A7:  RLF    4D,F
03A8:  BTFSC  03.0
03A9:  GOTO   3AC
03AA:  BCF    07.5
03AB:  GOTO   3AD
03AC:  BSF    07.5
03AD:  BCF    2E.5
03AE:  MOVF   2E,W
03AF:  BSF    03.5
03B0:  MOVWF  07
....................  
....................          output_high(DAC_CLK); 
03B1:  BCF    03.5
03B2:  BCF    2E.3
03B3:  MOVF   2E,W
03B4:  BSF    03.5
03B5:  MOVWF  07
03B6:  BCF    03.5
03B7:  BSF    07.3
....................          output_low(DAC_CLK); 
03B8:  BCF    2E.3
03B9:  MOVF   2E,W
03BA:  BSF    03.5
03BB:  MOVWF  07
03BC:  BCF    03.5
03BD:  BCF    07.3
....................       } 
....................    } 
03BE:  INCF   4E,F
03BF:  GOTO   38F
....................    output_high(DAC_CS); 
03C0:  BCF    2E.4
03C1:  MOVF   2E,W
03C2:  BSF    03.5
03C3:  MOVWF  07
03C4:  BCF    03.5
03C5:  BSF    07.4
....................  
....................    output_low(DAC_LDAC); 
03C6:  BSF    03.5
03C7:  BCF    06.4
03C8:  BCF    03.5
03C9:  BCF    06.4
....................    delay_us(10); 
03CA:  MOVLW  10
03CB:  MOVWF  20
03CC:  DECFSZ 20,F
03CD:  GOTO   3CC
03CE:  NOP
....................     
....................    output_HIGH(DAC_LDAC); 
03CF:  BSF    03.5
03D0:  BCF    06.4
03D1:  BCF    03.5
03D2:  BSF    06.4
.................... } 
03D3:  BCF    0A.3
03D4:  GOTO   4CC (RETURN)
....................  
....................  
....................  
....................  
.................... /* 
.................... This is the main controller for the super capacitor hybrid scooter a.k.a RED 
.................... B2 close contactor 
.................... CONTROL BOX INPUTS 
.................... Athrottle- A0 - analog input representing the users input for speed, 10 bit 
.................... Vspeed - CCp2-a 16 bit representation of the speed of the vehicle 
.................... Acaps- A1 - analog input representing the current voltage of the supercapacitors, 10 bit 
....................  
.................... CONTROL BOX OUTPUT 
.................... ICEthrottle- B1 - a 16 bit number sent to the internal combustion engine(ICE) throttle  
.................... ELECthrottle-  - a 16 bit number sent as analog value representing the demanded electric power 
....................  
.................... SPECIFICS OF I/O 
....................  
.................... Athrottle - the electric throttle is a 3 wire unit with a 5 volt,ground, and analog out 
....................    representing how far throttle is turned. Pin AN0 is the input. 
....................     
.................... Vspeed - There is a encoder in the rear wheel/electric motor that is used by the electric 
....................    power controller. Tapping in to this this Main Controller receives a 5 Volt square wave 
....................    with 42 pulses. There are two options for measuring speed. The first is to measure the  
....................    length of the pulses. The second is to measure the rate of pulses. This controller currently 
....................    uses the rate method. The int_ccp2 interupt is called on each falling edge and stores the  
....................    Vspeed value as the max number of 16bit (65535-timer0_since_last_reset).  
....................     
....................    The RED scooter has a circumpherence of 16.3*2*pi = 102.4 
....................    X m/h * 63360 inch/mile * 1/3600 h/sec * 1/(102.4 inch/rev) = .171875* X 
....................    Examples 50 mph is 8.9 ms 1 overflow of timer0 
....................    Example 5 mph is 89 ms or 13 time overflow 
....................     
....................    #int_timer0 increments the counter number_of_overflows each time it overflows 
....................    On int ccp2 we multiply number_of_overflows * 256 + timer0 to get timer0_since_last_reset 
....................     
.................... Acaps - the analog voltage which is the 5volt representation of the voltage in the caps which 
....................    have a value of between 0-48v. The voltages are factored so that the voltage on AN1 goes 
....................    from 0 - 4.8 volts (TODO check this factor, think its 1/11 not 1/10) 
....................     
.................... ICEthrottle -  #int_timer1 is set to make sure the period follows the required below 
....................    The period for the servo is .020 seconds which is 50,000 operations 
....................    The leftmost position of the server is .001 seconds which is 2,500 
....................    The rightmost position of the server is .002 seconds which is 5,000 
....................     
....................    The output pin is pin_B1.-> 
....................  
.................... ELECthrottle 
....................    The electric power controller takes an analog voltage as input. The output voltage 
....................    is set by the DAC. The pins used are C3,C4,C5. if CHARGING_STATE is true then  
....................     
.................... ALGORITHM 
....................    The algorithm is basically a PID controller. In broad terms we are trying to set the 
....................    ICEthrottle and ICEelectric to maximize the use of electric and accelerate to meet the 
....................    requirements set by the rider with the Athrottle signal. When the demanded power is  
....................    less than the power output possible by the ICE and the caps are in the CHARGING_STATE  
....................    then the ICE is turned up to the max and the ELECthrottle is set to regen to 
....................    charge the capacitors.If CHARGING_STATE is false then the caps are supplying the drivig power 
....................    and the ICE is set to "off", the caps supply the power. Unless the user requested supply 
....................    is enough to require both power sources. 
....................     
....................    If CHARGING_STATE is true. Then pin_b2 is set as high which will close the brake number 
....................    for the electric power controller.  
....................     
....................    If CHARGING_STATE is false then the pin_b2 is set low which opens brake. 
....................     
....................     
....................  
....................  
.................... The encoder has 42 on and offs per rotation, i.e. 21 steps 
....................  
.................... Number of operations per second is CLOCK/4/Timer Divisions 
.................... Number of operations per second is 20,000,000/4/128 = 39062.5  
.................... Each operation takes 1/39062.5 = .256 micro (x10^-6) seconds 
.................... Seconds to Overflow timer0 8bit timer = .256x10^-6 * 256 = 6.55ms 
....................  
....................  
....................  
.................... */ 
.................... #define servo_pin PIN_B1  //Setting servo out pin to be hardware pin b1 
.................... #define ADC_DELAY delay_us(20) 
.................... #define Acaps_pin PIN_A1 
.................... #define Acaps_channel 1 
.................... #define Athrottle_pin PIN_A0 
.................... #define Athrottle_channel 0 
.................... #define Electric_Controller_Switch PIN_B0 
....................  
.................... static int16 left_position = 2500; 
*
03E6:  MOVLW  C4
03E7:  MOVWF  2F
03E8:  MOVLW  09
03E9:  MOVWF  30
.................... static int16 right_position = 5000; 
03EA:  MOVLW  88
03EB:  MOVWF  31
03EC:  MOVLW  13
03ED:  MOVWF  32
.................... static int16 servo_period   = 65356-50000; 
03EE:  MOVLW  FC
03EF:  MOVWF  33
03F0:  MOVLW  3B
03F1:  MOVWF  34
.................... unsigned int16 current_servo_position=2500; 
03F2:  MOVLW  C4
03F3:  MOVWF  35
03F4:  MOVLW  09
03F5:  MOVWF  36
.................... int1 SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0; 
03F6:  BCF    37.0
.................... int1 test_boolean = 0; 
03F7:  BCF    37.1
....................  
.................... int1 test_switch = 0; 
03F8:  BCF    37.2
.................... unsigned int16 test_counter = 0; 
03F9:  CLRF   38
03FA:  CLRF   39
....................  
.................... unsigned int8 number_of_timer0_interupts_since_reset =0; 
03FB:  CLRF   3A
.................... unsigned int16 timer0_since_last_reset= 0; 
03FC:  CLRF   3B
03FD:  CLRF   3C
.................... unsigned int16 vSpeed= 255; 
03FE:  MOVLW  FF
03FF:  MOVWF  3D
0400:  CLRF   3E
.................... unsigned int16 ELECthrottle = 0; 
0401:  CLRF   3F
0402:  CLRF   40
.................... unsigned int16 ICEthrottle = 0; 
0403:  CLRF   41
0404:  CLRF   42
.................... unsigned int16 Athrottle = 0; 
0405:  CLRF   43
0406:  CLRF   44
.................... unsigned int16 Acaps = 0; 
0407:  CLRF   45
0408:  CLRF   46
.................... int1 CURRENTLY_CHARGING = 0; 
0409:  BCF    37.3
....................  
.................... /* 
.................... The #int_timer0 interupt is triggered on each timer0 8bit interupt 
.................... the function simply increments a overflow counter to be used by the ccp2 
.................... interupt to calculate speed 
.................... NUMBER OF OPERATIONS =  
.................... */ 
.................... #int_timer0 
.................... void timer0_isr(){ 
....................    if (number_of_timer0_interupts_since_reset!=255){ 
*
0045:  INCFSZ 3A,W
0046:  GOTO   048
0047:  GOTO   04A
....................       number_of_timer0_interupts_since_reset++; 
0048:  INCF   3A,F
....................    } 
....................    else { 
0049:  GOTO   04E
....................       vSpeed = 255; 
004A:  CLRF   3E
004B:  MOVLW  FF
004C:  MOVWF  3D
....................       number_of_timer0_interupts_since_reset=0; 
004D:  CLRF   3A
....................    } 
.................... } 
....................  
.................... /* 
.................... #int_timer1 is used by the ICEservo throttle to regulate the timing pulses. The  
.................... timer is setup for a pulsetrain of 20ms period. This is done as follows, 
....................  
.................... Period is 1/(CLOCK/4opsperclock)*(startingPostionOfClock) = 20 ms 
.................... for this setup 1/(20000000/4)*(50000) = 20 ms 
....................  
.................... The timer1 starts at 0 and counts up. So we set the beggining of the clock at 
.................... servo_period which is 65356-50000 so that the total time is 20ms. 
.................... */ 
004E:  BCF    0B.2
004F:  BCF    0A.3
0050:  GOTO   02C
.................... #int_timer1 
.................... void isr() 
.................... { 
....................  
.................... //Make sure that the position is within the left and right positions of the servo 
....................    if (current_servo_position<left_position){ 
0051:  MOVF   36,W
0052:  SUBWF  30,W
0053:  BTFSS  03.0
0054:  GOTO   060
0055:  BTFSS  03.2
0056:  GOTO   05B
0057:  MOVF   2F,W
0058:  SUBWF  35,W
0059:  BTFSC  03.0
005A:  GOTO   060
....................       current_servo_position = left_position; 
005B:  MOVF   30,W
005C:  MOVWF  36
005D:  MOVF   2F,W
005E:  MOVWF  35
....................    } 
....................    else if (current_servo_position > right_position){ 
005F:  GOTO   06E
0060:  MOVF   32,W
0061:  SUBWF  36,W
0062:  BTFSS  03.0
0063:  GOTO   06E
0064:  BTFSS  03.2
0065:  GOTO   06A
0066:  MOVF   35,W
0067:  SUBWF  31,W
0068:  BTFSC  03.0
0069:  GOTO   06E
....................       current_servo_position = left_position; 
006A:  MOVF   30,W
006B:  MOVWF  36
006C:  MOVF   2F,W
006D:  MOVWF  35
....................    } 
....................  
....................    if(SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER) 
006E:  BTFSS  37.0
006F:  GOTO   083
....................       {  
....................          output_high(servo_pin);        //Set the servo control pin to high  
0070:  BSF    03.5
0071:  BCF    06.1
0072:  BCF    03.5
0073:  BSF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0;  
0074:  BCF    37.0
....................          set_timer1(65356-current_servo_position); //Set timer for the position high pulse 
0075:  MOVF   35,W
0076:  SUBLW  4C
0077:  MOVWF  5F
0078:  MOVLW  FF
0079:  MOVWF  60
007A:  MOVF   36,W
007B:  BTFSS  03.0
007C:  INCFSZ 36,W
007D:  SUBWF  60,F
007E:  MOVF   60,W
007F:  MOVWF  0F
0080:  MOVF   5F,W
0081:  MOVWF  0E
....................       }  
....................    else  
0082:  GOTO   095
....................       {  
....................          output_low(servo_pin);                      // Set the servo control pin to low   
0083:  BSF    03.5
0084:  BCF    06.1
0085:  BCF    03.5
0086:  BCF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 1;  
0087:  BSF    37.0
....................          set_timer1(servo_period+current_servo_position);          //Set timer for the low position the length is the difference between  
0088:  MOVF   35,W
0089:  ADDWF  33,W
008A:  MOVWF  5F
008B:  MOVF   34,W
008C:  MOVWF  60
008D:  MOVF   36,W
008E:  BTFSC  03.0
008F:  INCFSZ 36,W
0090:  ADDWF  60,F
0091:  MOVF   60,W
0092:  MOVWF  0F
0093:  MOVF   5F,W
0094:  MOVWF  0E
....................                                                      //the total int16 lenght - high pulse length 
....................       }   
.................... } 
....................  
....................  
.................... /* 
.................... #int_ccp2 is called on the falling edge of the encoder pulse. We calculate the time 
.................... between pulses.  
.................... TODO will have to put some kind of smoothing mechanism 
.................... */ 
0095:  BCF    0C.0
0096:  BCF    0A.3
0097:  GOTO   02C
.................... #int_ccp2 
.................... void isr2() 
.................... { 
.................... if (number_of_timer0_interupts_since_reset>20){ 
0098:  MOVF   3A,W
0099:  SUBLW  14
009A:  BTFSC  03.0
009B:  GOTO   0A0
.................... vSpeed  = number_of_timer0_interupts_since_reset; 
009C:  CLRF   3E
009D:  MOVF   3A,W
009E:  MOVWF  3D
.................... number_of_timer0_interupts_since_reset = 0; 
009F:  CLRF   3A
.................... } 
.................... } 
....................  
....................  
00A0:  BCF    0D.0
00A1:  BCF    0A.3
00A2:  GOTO   02C
.................... void main() 
.................... {   
*
03D5:  CLRF   04
03D6:  MOVLW  1F
03D7:  ANDWF  03,F
03D8:  BSF    03.5
03D9:  BCF    06.3
03DA:  BCF    03.5
03DB:  BSF    06.3
03DC:  BSF    03.5
03DD:  BSF    1F.0
03DE:  BSF    1F.1
03DF:  BSF    1F.2
03E0:  BCF    1F.3
03E1:  MOVLW  07
03E2:  MOVWF  1C
....................     
....................    setup_adc_ports(NO_ANALOGS); 
*
040A:  BSF    03.5
040B:  BSF    1F.0
040C:  BSF    1F.1
040D:  BSF    1F.2
040E:  BCF    1F.3
....................    setup_adc(ADC_OFF); 
040F:  BCF    03.5
0410:  BCF    1F.0
....................    setup_spi(FALSE); 
0411:  CLRF   14
....................     
....................    //setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
....................    setup_timer_1(T1_DISABLED); 
0412:  CLRF   10
....................    setup_timer_2(T2_DISABLED,0,1); 
0413:  MOVLW  00
0414:  MOVWF  21
0415:  MOVWF  12
0416:  MOVLW  00
0417:  BSF    03.5
0418:  MOVWF  12
....................    setup_port_a(ALL_ANALOG); 
0419:  BCF    1F.0
041A:  BCF    1F.1
041B:  BCF    1F.2
041C:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
041D:  BCF    1F.6
041E:  BCF    03.5
041F:  BSF    1F.6
0420:  BSF    1F.7
0421:  BSF    03.5
0422:  BSF    1F.7
0423:  BCF    03.5
0424:  BSF    1F.0
....................     
....................    init_dac(); 
0425:  GOTO   0A3
....................   
....................    setup_timer_1(T1_DIV_BY_2| T1_INTERNAL);  
0426:  MOVLW  95
0427:  MOVWF  10
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_128); 
0428:  BSF    03.5
0429:  MOVF   01,W
042A:  ANDLW  C0
042B:  IORLW  06
042C:  MOVWF  01
....................    setup_ccp2(CCP_CAPTURE_RE);    // Configure CCP2 to capture fall 
042D:  BCF    03.5
042E:  BSF    2E.1
042F:  MOVF   2E,W
0430:  BSF    03.5
0431:  MOVWF  07
0432:  BCF    03.5
0433:  CLRF   1D
0434:  MOVLW  05
0435:  MOVWF  1D
....................    enable_interrupts(INT_CCP2);   // Setup interrupt on falling edge 
0436:  BSF    03.5
0437:  BSF    0D.0
....................    enable_interrupts(INT_TIMER0); 
0438:  BCF    03.5
0439:  BSF    0B.5
....................    enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
043A:  BSF    03.5
043B:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
043C:  MOVLW  C0
043D:  BCF    03.5
043E:  IORWF  0B,F
....................    output_low(Electric_Controller_Switch); 
043F:  BSF    03.5
0440:  BCF    06.0
0441:  BCF    03.5
0442:  BCF    06.0
....................    while(TRUE) { 
....................        
....................       //GET INPUTS 
....................       //Vspeed happens in interrupts 
....................        
....................       set_adc_channel(Acaps_channel); 
0443:  MOVLW  08
0444:  MOVWF  21
0445:  MOVF   1F,W
0446:  ANDLW  C7
0447:  IORWF  21,W
0448:  MOVWF  1F
....................       ADC_DELAY; 
0449:  MOVLW  21
044A:  MOVWF  20
044B:  DECFSZ 20,F
044C:  GOTO   44B
....................       Acaps = read_adc(); 
044D:  BSF    1F.2
044E:  BTFSC  1F.2
044F:  GOTO   44E
0450:  BSF    03.5
0451:  MOVF   1E,W
0452:  BCF    03.5
0453:  MOVWF  45
0454:  MOVF   1E,W
0455:  MOVWF  46
....................        
....................       set_adc_channel(Athrottle_channel); 
0456:  MOVLW  00
0457:  MOVWF  21
0458:  MOVF   1F,W
0459:  ANDLW  C7
045A:  IORWF  21,W
045B:  MOVWF  1F
....................       ADC_DELAY; 
045C:  MOVLW  21
045D:  MOVWF  20
045E:  DECFSZ 20,F
045F:  GOTO   45E
....................       Athrottle = read_adc(); 
0460:  BSF    1F.2
0461:  BTFSC  1F.2
0462:  GOTO   461
0463:  BSF    03.5
0464:  MOVF   1E,W
0465:  BCF    03.5
0466:  MOVWF  43
0467:  MOVF   1E,W
0468:  MOVWF  44
....................  
....................       //CONTROL BOX 
....................  
....................        
....................       current_servo_position=left_position+(Athrottle/1024.0)*2500;//(vSpeed/65536.0)*(2500); 
0469:  MOVF   44,W
046A:  MOVWF  50
046B:  MOVF   43,W
046C:  MOVWF  4F
046D:  CALL   0BB
046E:  MOVF   23,W
046F:  MOVWF  4A
0470:  MOVF   22,W
0471:  MOVWF  49
0472:  MOVF   21,W
0473:  MOVWF  48
0474:  MOVF   20,W
0475:  MOVWF  47
0476:  CLRF   4E
0477:  CLRF   4D
0478:  CLRF   4C
0479:  MOVLW  89
047A:  MOVWF  4B
047B:  GOTO   0D8
047C:  MOVF   20,W
047D:  MOVWF  47
047E:  MOVF   21,W
047F:  MOVWF  48
0480:  MOVF   22,W
0481:  MOVWF  49
0482:  MOVF   23,W
0483:  MOVWF  4A
0484:  MOVWF  4E
0485:  MOVF   22,W
0486:  MOVWF  4D
0487:  MOVF   21,W
0488:  MOVWF  4C
0489:  MOVF   20,W
048A:  MOVWF  4B
048B:  CLRF   52
048C:  MOVLW  40
048D:  MOVWF  51
048E:  MOVLW  1C
048F:  MOVWF  50
0490:  MOVLW  8A
0491:  MOVWF  4F
0492:  GOTO   1A3
0493:  MOVF   20,W
0494:  MOVWF  4B
0495:  MOVF   21,W
0496:  MOVWF  4C
0497:  MOVF   22,W
0498:  MOVWF  4D
0499:  MOVF   23,W
049A:  MOVWF  4E
049B:  MOVF   30,W
049C:  MOVWF  50
049D:  MOVF   2F,W
049E:  MOVWF  4F
049F:  CALL   0BB
04A0:  BCF    03.1
04A1:  MOVF   23,W
04A2:  MOVWF  52
04A3:  MOVF   22,W
04A4:  MOVWF  51
04A5:  MOVF   21,W
04A6:  MOVWF  50
04A7:  MOVF   20,W
04A8:  MOVWF  4F
04A9:  MOVF   4E,W
04AA:  MOVWF  56
04AB:  MOVF   4D,W
04AC:  MOVWF  55
04AD:  MOVF   4C,W
04AE:  MOVWF  54
04AF:  MOVF   4B,W
04B0:  MOVWF  53
04B1:  GOTO   219
04B2:  MOVF   23,W
04B3:  MOVWF  52
04B4:  MOVF   22,W
04B5:  MOVWF  51
04B6:  MOVF   21,W
04B7:  MOVWF  50
04B8:  MOVF   20,W
04B9:  MOVWF  4F
04BA:  GOTO   358
04BB:  MOVF   22,W
04BC:  MOVWF  36
04BD:  MOVF   21,W
04BE:  MOVWF  35
....................       //printf("Analog Cap %d Analog Throttle %d\n",(int) Acaps, (int) Athrottle); 
....................        
....................     
....................       //SET OUTPUTS  
....................       //The writing of the ICEThrottle happens in interupts and all that is 
....................       //required is updating ICEthrottle 
....................       write_dac(Athrottle*4); 
04BF:  RLF    43,W
04C0:  MOVWF  47
04C1:  RLF    44,W
04C2:  MOVWF  48
04C3:  RLF    47,F
04C4:  RLF    48,F
04C5:  MOVLW  FC
04C6:  ANDWF  47,F
04C7:  MOVF   48,W
04C8:  MOVWF  4A
04C9:  MOVF   47,W
04CA:  MOVWF  49
04CB:  GOTO   378
....................    } 
04CC:  GOTO   443
....................     
....................  
.................... } 
....................  
....................  
....................  
....................  
04CD:  GOTO   4CD

Configuration Fuses:
   Word  1: 373A   HS NOWDT NOPUT DEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
