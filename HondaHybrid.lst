CCS PCM C Compiler, Version 4.084, 46530               26-Jan-13 15:38

               Filename: HondaHybrid.lst

               ROM used: 1088 words (28%)
                         Largest free fragment is 1788
               RAM used: 60 (34%) at main() level
                         73 (41%) worst case
               Stack:    2 worst case (1 in main + 1 for interrupts)

*
0000:  NOP
0001:  MOVLW  00
0002:  MOVWF  0A
0003:  GOTO   31E
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  26
0008:  MOVF   7F,W
0009:  MOVWF  25
000A:  MOVF   0A,W
000B:  MOVWF  2D
000C:  CLRF   0A
000D:  SWAPF  25,F
000E:  MOVF   04,W
000F:  MOVWF  27
0010:  MOVF   20,W
0011:  MOVWF  28
0012:  MOVF   21,W
0013:  MOVWF  29
0014:  MOVF   22,W
0015:  MOVWF  2A
0016:  MOVF   23,W
0017:  MOVWF  2B
0018:  MOVF   24,W
0019:  MOVWF  2C
001A:  BCF    03.7
001B:  BCF    03.5
001C:  MOVLW  8C
001D:  MOVWF  04
001E:  BTFSS  00.0
001F:  GOTO   022
0020:  BTFSC  0C.0
0021:  GOTO   03F
0022:  MOVLW  8D
0023:  MOVWF  04
0024:  BTFSS  00.0
0025:  GOTO   028
0026:  BTFSC  0D.0
0027:  GOTO   041
0028:  BTFSS  0B.5
0029:  GOTO   02C
002A:  BTFSC  0B.2
002B:  GOTO   043
002C:  MOVF   27,W
002D:  MOVWF  04
002E:  MOVF   28,W
002F:  MOVWF  20
0030:  MOVF   29,W
0031:  MOVWF  21
0032:  MOVF   2A,W
0033:  MOVWF  22
0034:  MOVF   2B,W
0035:  MOVWF  23
0036:  MOVF   2C,W
0037:  MOVWF  24
0038:  MOVF   2D,W
0039:  MOVWF  0A
003A:  SWAPF  26,W
003B:  MOVWF  03
003C:  SWAPF  7F,F
003D:  SWAPF  7F,W
003E:  RETFIE
003F:  BCF    0A.3
0040:  GOTO   051
0041:  BCF    0A.3
0042:  GOTO   099
0043:  BCF    0A.3
0044:  GOTO   045
.................... #include "HondaHybrid.h" 
.................... #include <16F873A.h> 
.................... //////// Standard Header file for the PIC16F873A device //////////////// 
.................... #device PIC16F873A 
.................... #list 
....................  
....................  
.................... //#include <16F737.h> 
.................... #device ICD=TRUE 
.................... #device adc=10 
.................... //#device adc=8 
.................... #use delay(clock=20000000) 
.................... #fuses HS,PUT,NOWDT 
.................... #use rs232 (DEBUGGER) 
.................... #include <mcp4921.c> 
.................... //////////////// Driver for MCP4921 D/A Converter /////////////////////// 
.................... ////                                                                 //// 
.................... ////  init_dac()    Call this before using a MCP4921 DAC             //// 
.................... ////                                                                 //// 
.................... ////  write_dac( long int )   Writes command and 12 bit resolution   //// 
.................... ////                          to the MCP4921 which converts it to a  //// 
.................... ////                          voltage                                //// 
.................... ////                          0-4095 input represents 0-vref V out.  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SELECT 
....................  
.................... #define DAC_CS     PIN_C4 
.................... #define DAC_CLK    PIN_C3 
.................... #define DAC_DI     PIN_C5 
.................... #define DAC_LDAC   PIN_B5 
....................  
.................... #endif 
....................  
.................... void init_dac() 
.................... { 
....................    output_high(DAC_CS); 
*
00A3:  BCF    2E.4
00A4:  MOVF   2E,W
00A5:  BSF    03.5
00A6:  MOVWF  07
00A7:  BCF    03.5
00A8:  BSF    07.4
....................    output_high(DAC_LDAC); 
00A9:  BSF    03.5
00AA:  BCF    06.5
00AB:  BCF    03.5
00AC:  BSF    06.5
....................    output_high(DAC_CLK); 
00AD:  BCF    2E.3
00AE:  MOVF   2E,W
00AF:  BSF    03.5
00B0:  MOVWF  07
00B1:  BCF    03.5
00B2:  BSF    07.3
....................    output_high(DAC_DI); 
00B3:  BCF    2E.5
00B4:  MOVF   2E,W
00B5:  BSF    03.5
00B6:  MOVWF  07
00B7:  BCF    03.5
00B8:  BSF    07.5
.................... } 
00B9:  BCF    0A.3
00BA:  GOTO   36B (RETURN)
....................  
.................... void write_dac(int16 data) { 
....................    BYTE cmd[3]; 
....................    BYTE i; 
....................  
....................    cmd[0]=data; 
00BB:  MOVF   5B,W
00BC:  MOVWF  5D
....................    cmd[1]=(data>>8); 
00BD:  MOVF   5C,W
00BE:  MOVWF  5E
....................    cmd[2]=0x03;                            
00BF:  MOVLW  03
00C0:  MOVWF  5F
....................     
....................    output_high(DAC_LDAC); 
00C1:  BSF    03.5
00C2:  BCF    06.5
00C3:  BCF    03.5
00C4:  BSF    06.5
....................    output_low(DAC_CLK); 
00C5:  BCF    2E.3
00C6:  MOVF   2E,W
00C7:  BSF    03.5
00C8:  MOVWF  07
00C9:  BCF    03.5
00CA:  BCF    07.3
....................    output_low(DAC_CS); 
00CB:  BCF    2E.4
00CC:  MOVF   2E,W
00CD:  BSF    03.5
00CE:  MOVWF  07
00CF:  BCF    03.5
00D0:  BCF    07.4
....................  
....................    for(i=0; i<=23; ++i) 
00D1:  CLRF   60
00D2:  MOVF   60,W
00D3:  SUBLW  17
00D4:  BTFSS  03.0
00D5:  GOTO   103
....................    { 
....................       if(i<4 || (i>7 && i<12)) 
00D6:  MOVF   60,W
00D7:  SUBLW  03
00D8:  BTFSC  03.0
00D9:  GOTO   0E2
00DA:  MOVF   60,W
00DB:  SUBLW  07
00DC:  BTFSC  03.0
00DD:  GOTO   0E7
00DE:  MOVF   60,W
00DF:  SUBLW  0B
00E0:  BTFSS  03.0
00E1:  GOTO   0E7
....................          shift_left(cmd,3,0); 
00E2:  BCF    03.0
00E3:  RLF    5D,F
00E4:  RLF    5E,F
00E5:  RLF    5F,F
....................       else 
00E6:  GOTO   101
....................       { 
....................          output_bit(DAC_DI, shift_left(cmd,3,0)); 
00E7:  BCF    03.0
00E8:  RLF    5D,F
00E9:  RLF    5E,F
00EA:  RLF    5F,F
00EB:  BTFSC  03.0
00EC:  GOTO   0EF
00ED:  BCF    07.5
00EE:  GOTO   0F0
00EF:  BSF    07.5
00F0:  BCF    2E.5
00F1:  MOVF   2E,W
00F2:  BSF    03.5
00F3:  MOVWF  07
....................  
....................          output_high(DAC_CLK); 
00F4:  BCF    03.5
00F5:  BCF    2E.3
00F6:  MOVF   2E,W
00F7:  BSF    03.5
00F8:  MOVWF  07
00F9:  BCF    03.5
00FA:  BSF    07.3
....................          output_low(DAC_CLK); 
00FB:  BCF    2E.3
00FC:  MOVF   2E,W
00FD:  BSF    03.5
00FE:  MOVWF  07
00FF:  BCF    03.5
0100:  BCF    07.3
....................       } 
....................    } 
0101:  INCF   60,F
0102:  GOTO   0D2
....................    output_high(DAC_CS); 
0103:  BCF    2E.4
0104:  MOVF   2E,W
0105:  BSF    03.5
0106:  MOVWF  07
0107:  BCF    03.5
0108:  BSF    07.4
....................  
....................    output_low(DAC_LDAC); 
0109:  BSF    03.5
010A:  BCF    06.5
010B:  BCF    03.5
010C:  BCF    06.5
....................    delay_us(10); 
010D:  MOVLW  10
010E:  MOVWF  20
010F:  DECFSZ 20,F
0110:  GOTO   10F
0111:  NOP
....................     
....................    output_HIGH(DAC_LDAC); 
0112:  BSF    03.5
0113:  BCF    06.5
0114:  BCF    03.5
0115:  BSF    06.5
.................... } 
0116:  RETLW  00
....................  
....................  
....................  
.................... #include "pid.h" 
.................... /*This file has been prepared for Doxygen automatic documentation generation.*/ 
.................... /*! \file ********************************************************************* 
....................  * 
....................  * \brief Header file for pid.c. 
....................  * 
....................  * - File:               pid.h 
....................  * - Compiler:           IAR EWAAVR 4.11A 
....................  * - Supported devices:  All AVR devices can be used. 
....................  * - AppNote:            AVR221 - Discrete PID controller 
....................  * 
....................  * \author               Atmel Corporation: http://www.atmel.com \n 
....................  *                       Support email: avr@atmel.com 
....................  * 
....................  * $Name$ 
....................  * $Revision: 456 $ 
....................  * $RCSfile$ 
....................  * $Date: 2006-02-16 12:46:13 +0100 (to, 16 feb 2006) $ 
....................  *****************************************************************************/ 
....................  
.................... #ifndef PID_H 
.................... #define PID_H 
....................  
.................... //#include "stdint.h" 
.................... #define INT16_MAX 32767 
.................... #define INT32_MAX 2147483647 
.................... #define SCALING_FACTOR  128 
....................  
.................... /*! \brief PID Status 
....................  * 
....................  * Setpoints and data used by the PID control algorithm 
....................  */ 
.................... typedef struct PID_DATA{ 
....................   //! Last process value, used to find derivative of process value. 
....................   int16 lastProcessValue; 
....................   //! Summation of errors, used for integrate calculations 
....................   int32 sumError; 
....................   //! The Proportional tuning constant, multiplied with SCALING_FACTOR 
....................   int16 P_Factor; 
....................   //! The Integral tuning constant, multiplied with SCALING_FACTOR 
....................   int16 I_Factor; 
....................   //! The Derivative tuning constant, multiplied with SCALING_FACTOR 
....................   int16 D_Factor; 
....................   //! Maximum allowed error, avoid overflow 
....................   int16 maxError; 
....................   //! Maximum allowed sumerror, avoid overflow 
....................   int32 maxSumError; 
.................... } pidData_t; 
....................  
.................... /*! \brief Maximum values 
....................  * 
....................  * Needed to avoid sign/overflow problems 
....................  */ 
.................... // Maximum value of variables 
.................... #define MAX_INT         INT16_MAX 
.................... #define MAX_LONG        INT32_MAX 
.................... #define MAX_I_TERM      (MAX_LONG / 2) 
....................  
.................... // Boolean values 
.................... #define FALSE           0 
.................... #define TRUE            1 
....................  
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid); 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st); 
.................... void pid_Reset_Integrator(pidData_t *pid_st); 
....................  
.................... #endif 
....................  
.................... /* 
.................... This is the main controller for the super capacitor hybrid scooter a.k.a RED 
.................... B2 close contactor 
.................... CONTROL BOX INPUTS 
.................... Athrottle- A0 - analog input representing the users input for speed, 10 bit 
.................... Vspeed - CCp2-a 16 bit representation of the speed of the vehicle 
.................... Acaps- A1 - analog input representing the current voltage of the supercapacitors, 10 bit 
....................  
.................... CONTROL BOX OUTPUT 
.................... ICEthrottle- B1 - a 16 bit number sent to the internal combustion engine(ICE) throttle  
.................... ELECthrottle-  - a 16 bit number sent as analog value representing the demanded electric power 
....................  
.................... SPECIFICS OF I/O 
....................  
.................... Athrottle - the electric throttle is a 3 wire unit with a 5 volt,ground, and analog out 
....................    representing how far throttle is turned. Pin AN0 is the input. 
....................     
.................... Vspeed - There is a encoder in the rear wheel/electric motor that is used by the electric 
....................    power controller. Tapping in to this this Main Controller receives a 5 Volt square wave 
....................    with 42 pulses. There are two options for measuring speed. The first is to measure the  
....................    length of the pulses. The second is to measure the rate of pulses. This controller currently 
....................    uses the rate method. The int_ccp2 interupt is called on each falling edge and stores the  
....................    Vspeed value as the max number of 16bit (65535-timer0_since_last_reset).  
....................     
....................    The RED scooter has a circumpherence of 16.3*2*pi = 102.4 
....................    X m/h * 63360 inch/mile * 1/3600 h/sec * 1/(102.4 inch/rev) = .171875* X 
....................    Examples 50 mph is 8.9 ms 1 overflow of timer0 
....................    Example 5 mph is 89 ms or 13 time overflow 
....................     
....................    #int_timer0 increments the counter number_of_overflows each time it overflows 
....................    On int ccp2 we multiply number_of_overflows * 256 + timer0 to get timer0_since_last_reset 
....................     
.................... Acaps - the analog voltage which is the 5volt representation of the voltage in the caps which 
....................    have a value of between 0-48v. The voltages are factored so that the voltage on AN1 goes 
....................    from 0 - 4.8 volts (TODO check this factor, think its 1/11 not 1/10) 
....................     
.................... ICEthrottle -  #int_timer1 is set to make sure the period follows the required below 
....................    The period for the servo is .020 seconds which is 50,000 operations 
....................    The leftmost position of the server is .001 seconds which is 2,500 
....................    The rightmost position of the server is .002 seconds which is 5,000 
....................     
....................    The output pin is pin_B1.-> 
....................  
.................... ELECthrottle 
....................    The electric power controller takes an analog voltage as input. The output voltage 
....................    is set by the DAC. The pins used are C3,C4,C5. if CHARGING_STATE is true then  
....................     
.................... ALGORITHM 
....................    The algorithm is basically a PID controller. In broad terms we are trying to set the 
....................    ICEthrottle and ICEelectric to maximize the use of electric and accelerate to meet the 
....................    requirements set by the rider with the Athrottle signal. When the demanded power is  
....................    less than the power output possible by the ICE and the caps are in the CHARGING_STATE  
....................    then the ICE is turned up to the max and the ELECthrottle is set to regen to 
....................    charge the capacitors.If CHARGING_STATE is false then the caps are supplying the drivig power 
....................    and the ICE is set to "off", the caps supply the power. Unless the user requested supply 
....................    is enough to require both power sources. 
....................     
....................    If CHARGING_STATE is true. Then pin_b2 is set as high which will close the brake number 
....................    for the electric power controller.  
....................     
....................    If CHARGING_STATE is false then the pin_b2 is set low which opens brake. 
....................     
....................     
....................  
....................  
.................... The encoder has 42 on and offs per rotation, i.e. 21 steps 
....................  
.................... Number of operations per second is CLOCK/4/Timer Divisions 
.................... Number of operations per second is 20,000,000/4/128 = 39062.5  
.................... Each operation takes 1/39062.5 = .256 micro (x10^-6) seconds 
.................... Seconds to Overflow timer0 8bit timer = .256x10^-6 * 256 = 6.55ms 
....................  
....................  
....................  
.................... */ 
.................... #define servo_pin PIN_B1  //Setting servo out pin to be hardware pin b1 
.................... #define brake_pin PIN_B4 
.................... #define ADC_DELAY delay_us(20) 
.................... #define Acaps_pin PIN_A1 
.................... #define Acaps_channel 1 
.................... #define Athrottle_pin PIN_A0  //Voltage goes from 1.5 (306)to 4.1(836) 
.................... #define Athrottle_Min 306 
.................... #define Athrottle_Max 836 
.................... #define Athrottle_Full Athrottle_Max-Athrottle_Min 
.................... #define Athrottle_channel 0 
.................... #define Electric_Controller_Switch PIN_B0 
.................... #define Contactor_Switch PIN_B2 
....................  
.................... //PID Values 
.................... #define K_P 1.00 
.................... #define K_I 1.00 
.................... #define K_D 0.00 
....................  
.................... int1 pid_Timer = 0; 
*
032F:  BCF    2F.0
.................... struct PID_DATA pidData; 
.................... #define TIME_INTERVAL 157 //TODO replace 
....................  
.................... #define left_position 3950 
.................... #define right_position 4800 
.................... #define servo_difference  right_position-left_position 
.................... const float Athrottle_servo_factor = ((float) servo_difference)/((float) Athrottle_FULL); 
.................... #define servo_period   65356-50000 
.................... unsigned int16 current_servo_position=right_position; 
0330:  MOVLW  C0
0331:  MOVWF  42
0332:  MOVLW  12
0333:  MOVWF  43
.................... int1 SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0; 
0334:  BCF    2F.1
.................... int1 test_boolean = 0; 
0335:  BCF    2F.2
....................  
.................... int1 test_switch = 0; 
0336:  BCF    2F.3
.................... unsigned int16 test_counter = 0; 
0337:  CLRF   44
0338:  CLRF   45
....................  
.................... unsigned int8 number_of_timer0_interupts_since_reset =0; 
0339:  CLRF   46
.................... unsigned int16 timer0_since_last_reset= 0; 
033A:  CLRF   47
033B:  CLRF   48
.................... unsigned int16 vSpeed= 255; 
033C:  MOVLW  FF
033D:  MOVWF  49
033E:  CLRF   4A
.................... unsigned int16 ELECthrottle = 0; 
033F:  CLRF   4B
0340:  CLRF   4C
.................... unsigned int16 ICEthrottle = 0; 
0341:  CLRF   4D
0342:  CLRF   4E
.................... unsigned int16 Athrottle = 0; 
0343:  CLRF   4F
0344:  CLRF   50
.................... unsigned int16 Acaps = 0; 
0345:  CLRF   51
0346:  CLRF   52
.................... int1 CURRENTLY_CHARGING = 0; 
0347:  BCF    2F.4
....................  
.................... /* 
.................... The #int_timer0 interupt is triggered on each timer0 8bit interupt 
.................... the function simply increments a overflow counter to be used by the ccp2 
.................... interupt to calculate speed 
.................... NUMBER OF OPERATIONS =  
.................... */ 
.................... #int_timer0 
.................... void timer0_isr(){ 
....................    if (number_of_timer0_interupts_since_reset!=255){ 
*
0045:  INCFSZ 46,W
0046:  GOTO   048
0047:  GOTO   04A
....................       number_of_timer0_interupts_since_reset++; 
0048:  INCF   46,F
....................       //current_servo_position=current_servo_position+1; 
....................        
....................    } 
....................    else { 
0049:  GOTO   04E
....................       vSpeed = 255; 
004A:  CLRF   4A
004B:  MOVLW  FF
004C:  MOVWF  49
....................       number_of_timer0_interupts_since_reset=0; 
004D:  CLRF   46
....................        
....................        
....................    } 
.................... } 
....................  
.................... /* 
.................... #int_timer1 is used by the ICEservo throttle to regulate the timing pulses. The  
.................... timer is setup for a pulsetrain of 20ms period. This is done as follows, 
....................  
.................... Period is 1/(CLOCK/4opsperclock)*(startingPostionOfClock) = 20 ms 
.................... for this setup 1/(20000000/4)*(50000) = 20 ms 
....................  
.................... The timer1 starts at 0 and counts up. So we set the beggining of the clock at 
.................... servo_period which is 65356-50000 so that the total time is 20ms. 
.................... */ 
004E:  BCF    0B.2
004F:  BCF    0A.3
0050:  GOTO   02C
.................... #int_timer1 
.................... void isr() 
.................... { 
....................  
.................... //Make sure that the position is within the left and right positions of the servo 
....................    if (current_servo_position<left_position){ 
0051:  MOVF   43,W
0052:  SUBLW  0F
0053:  BTFSS  03.0
0054:  GOTO   060
0055:  BTFSS  03.2
0056:  GOTO   05B
0057:  MOVF   42,W
0058:  SUBLW  6D
0059:  BTFSS  03.0
005A:  GOTO   060
....................       current_servo_position = left_position; 
005B:  MOVLW  0F
005C:  MOVWF  43
005D:  MOVLW  6E
005E:  MOVWF  42
....................    } 
....................    else if (current_servo_position > right_position){ 
005F:  GOTO   06F
0060:  MOVF   43,W
0061:  SUBLW  11
0062:  BTFSC  03.0
0063:  GOTO   06F
0064:  XORLW  FF
0065:  BTFSS  03.2
0066:  GOTO   06B
0067:  MOVF   42,W
0068:  SUBLW  C0
0069:  BTFSC  03.0
006A:  GOTO   06F
....................       current_servo_position = right_position; 
006B:  MOVLW  12
006C:  MOVWF  43
006D:  MOVLW  C0
006E:  MOVWF  42
....................    } 
....................  
....................    if(SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER) 
006F:  BTFSS  2F.1
0070:  GOTO   084
....................       {  
....................          output_high(servo_pin);        //Set the servo control pin to high  
0071:  BSF    03.5
0072:  BCF    06.1
0073:  BCF    03.5
0074:  BSF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0;  
0075:  BCF    2F.1
....................          set_timer1(65356-current_servo_position); //Set timer for the position high pulse 
0076:  MOVF   42,W
0077:  SUBLW  4C
0078:  MOVWF  66
0079:  MOVLW  FF
007A:  MOVWF  67
007B:  MOVF   43,W
007C:  BTFSS  03.0
007D:  INCFSZ 43,W
007E:  SUBWF  67,F
007F:  MOVF   67,W
0080:  MOVWF  0F
0081:  MOVF   66,W
0082:  MOVWF  0E
....................       }  
....................    else  
0083:  GOTO   096
....................       {  
....................          output_low(servo_pin);                      // Set the servo control pin to low   
0084:  BSF    03.5
0085:  BCF    06.1
0086:  BCF    03.5
0087:  BCF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 1;  
0088:  BSF    2F.1
....................          set_timer1(servo_period+current_servo_position);          //Set timer for the low position the length is the difference between  
0089:  MOVLW  FC
008A:  ADDWF  42,W
008B:  MOVWF  66
008C:  MOVF   43,W
008D:  MOVWF  67
008E:  MOVLW  3B
008F:  BTFSC  03.0
0090:  MOVLW  3C
0091:  ADDWF  67,F
0092:  MOVF   67,W
0093:  MOVWF  0F
0094:  MOVF   66,W
0095:  MOVWF  0E
....................                                                      //the total int16 lenght - high pulse length 
....................       }   
.................... } 
....................  
....................  
.................... /* 
.................... #int_ccp2 is called on the falling edge of the encoder pulse. We calculate the time 
.................... between pulses.  
.................... TODO will have to put some kind of smoothing mechanism 
.................... */ 
0096:  BCF    0C.0
0097:  BCF    0A.3
0098:  GOTO   02C
.................... #int_ccp2 
.................... void isr2() 
.................... { 
.................... if (number_of_timer0_interupts_since_reset>0){ 
0099:  MOVF   46,F
009A:  BTFSC  03.2
009B:  GOTO   0A0
.................... vSpeed  = number_of_timer0_interupts_since_reset; 
009C:  CLRF   4A
009D:  MOVF   46,W
009E:  MOVWF  49
.................... number_of_timer0_interupts_since_reset = 0; 
009F:  CLRF   46
.................... } 
.................... } 
....................  
....................  
....................  
....................  
00A0:  BCF    0D.0
00A1:  BCF    0A.3
00A2:  GOTO   02C
.................... void main() 
.................... {   
*
031E:  CLRF   04
031F:  MOVLW  1F
0320:  ANDWF  03,F
0321:  BSF    03.5
0322:  BCF    06.3
0323:  BCF    03.5
0324:  BSF    06.3
0325:  BSF    03.5
0326:  BSF    1F.0
0327:  BSF    1F.1
0328:  BSF    1F.2
0329:  BCF    1F.3
032A:  MOVLW  07
032B:  MOVWF  1C
....................     
....................    setup_adc_ports(NO_ANALOGS); 
*
0348:  BSF    03.5
0349:  BSF    1F.0
034A:  BSF    1F.1
034B:  BSF    1F.2
034C:  BCF    1F.3
....................    setup_adc(ADC_OFF); 
034D:  BCF    03.5
034E:  BCF    1F.0
....................    setup_spi(FALSE); 
034F:  CLRF   14
....................     
....................    setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
0350:  BSF    03.5
0351:  MOVF   01,W
0352:  ANDLW  C0
0353:  IORLW  00
0354:  MOVWF  01
0355:  CLRWDT
....................    setup_timer_1(T1_DISABLED); 
0356:  BCF    03.5
0357:  CLRF   10
....................    setup_timer_2(T2_DISABLED,0,1); 
0358:  MOVLW  00
0359:  MOVWF  21
035A:  MOVWF  12
035B:  MOVLW  00
035C:  BSF    03.5
035D:  MOVWF  12
....................    setup_port_a(ALL_ANALOG); 
035E:  BCF    1F.0
035F:  BCF    1F.1
0360:  BCF    1F.2
0361:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
0362:  BCF    1F.6
0363:  BCF    03.5
0364:  BSF    1F.6
0365:  BSF    1F.7
0366:  BSF    03.5
0367:  BSF    1F.7
0368:  BCF    03.5
0369:  BSF    1F.0
....................     
....................    init_dac(); 
036A:  GOTO   0A3
....................   
....................    setup_timer_1(T1_DIV_BY_2| T1_INTERNAL);  
036B:  MOVLW  95
036C:  MOVWF  10
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_128); 
036D:  BSF    03.5
036E:  MOVF   01,W
036F:  ANDLW  C0
0370:  IORLW  06
0371:  MOVWF  01
....................    setup_ccp2(CCP_CAPTURE_RE);    // Configure CCP2 to capture fall 
0372:  BCF    03.5
0373:  BSF    2E.1
0374:  MOVF   2E,W
0375:  BSF    03.5
0376:  MOVWF  07
0377:  BCF    03.5
0378:  CLRF   1D
0379:  MOVLW  05
037A:  MOVWF  1D
....................    enable_interrupts(INT_CCP2);   // Setup interrupt on falling edge 
037B:  BSF    03.5
037C:  BSF    0D.0
....................    enable_interrupts(INT_TIMER0); 
037D:  BCF    03.5
037E:  BSF    0B.5
....................    enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
037F:  BSF    03.5
0380:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
0381:  MOVLW  C0
0382:  BCF    03.5
0383:  IORWF  0B,F
....................    output_low(Electric_Controller_Switch); 
0384:  BSF    03.5
0385:  BCF    06.0
0386:  BCF    03.5
0387:  BCF    06.0
....................    write_dac(0); 
0388:  CLRF   5C
0389:  CLRF   5B
038A:  CALL   0BB
....................    output_high(Contactor_Switch); 
038B:  BSF    03.5
038C:  BCF    06.2
038D:  BCF    03.5
038E:  BSF    06.2
....................    output_low(brake_pin); 
038F:  BSF    03.5
0390:  BCF    06.4
0391:  BCF    03.5
0392:  BCF    06.4
....................    //pid_Init(K_P * SCALING_FACTOR,K_I*SCALING_FACTOR,K_D*SCALING_FACTOR, & pidData); 
....................     
....................    //delay_ms(1000); 
....................    //write_dac(1000); 
....................    //delay_ms(10000); 
....................    //output_high(Contactor_Switch); 
....................    //output_high(brake_pin); 
....................    //output_high(Electric_Controller_Switch); 
....................    while(TRUE) { 
....................  
....................       //GET INPUTS 
....................       //Vspeedhappens in interrupts 
....................        
....................       set_adc_channel(Acaps_channel); 
0393:  MOVLW  08
0394:  MOVWF  21
0395:  MOVF   1F,W
0396:  ANDLW  C7
0397:  IORWF  21,W
0398:  MOVWF  1F
....................       ADC_DELAY; 
0399:  MOVLW  21
039A:  MOVWF  20
039B:  DECFSZ 20,F
039C:  GOTO   39B
....................       Acaps = read_adc(); 
039D:  BSF    1F.2
039E:  BTFSC  1F.2
039F:  GOTO   39E
03A0:  BSF    03.5
03A1:  MOVF   1E,W
03A2:  BCF    03.5
03A3:  MOVWF  51
03A4:  MOVF   1E,W
03A5:  MOVWF  52
....................        
....................       set_adc_channel(Athrottle_channel); 
03A6:  MOVLW  00
03A7:  MOVWF  21
03A8:  MOVF   1F,W
03A9:  ANDLW  C7
03AA:  IORWF  21,W
03AB:  MOVWF  1F
....................       ADC_DELAY; 
03AC:  MOVLW  21
03AD:  MOVWF  20
03AE:  DECFSZ 20,F
03AF:  GOTO   3AE
....................       Athrottle = read_adc(); 
03B0:  BSF    1F.2
03B1:  BTFSC  1F.2
03B2:  GOTO   3B1
03B3:  BSF    03.5
03B4:  MOVF   1E,W
03B5:  BCF    03.5
03B6:  MOVWF  4F
03B7:  MOVF   1E,W
03B8:  MOVWF  50
....................  
....................       //CONTROL BOX 
....................  
....................        
....................       //current_servo_position=left_position+((Athrottle-Athrottle_Min)/Athrottle_Full)*servo_difference;//(vSpeed/65536.0)*(2500); 
....................       if (Athrottle<Athrottle_Min){ 
03B9:  MOVF   50,W
03BA:  SUBLW  01
03BB:  BTFSS  03.0
03BC:  GOTO   3C7
03BD:  BTFSS  03.2
03BE:  GOTO   3C3
03BF:  MOVF   4F,W
03C0:  SUBLW  31
03C1:  BTFSS  03.0
03C2:  GOTO   3C7
....................          Athrottle=Athrottle_Min; 
03C3:  MOVLW  01
03C4:  MOVWF  50
03C5:  MOVLW  32
03C6:  MOVWF  4F
....................       } 
....................       //current_servo_position=right_position-(Athrottle-Athrottle_Min)*Athrottle_servo_factor;//(Athrottle/Athrottle_Full)*servo_difference;//(vSpeed/65536.0)*(2500); 
....................       //printf("Analog Cap %d Analog Throttle %d\n",(int) Acaps, (int) Athrottle); 
....................       current_servo_position =right_position-(vSpeed*30); 
03C7:  MOVF   4A,W
03C8:  MOVWF  54
03C9:  MOVF   49,W
03CA:  MOVWF  53
03CB:  CLRF   56
03CC:  MOVLW  1E
03CD:  MOVWF  55
03CE:  GOTO   117
03CF:  MOVF   21,W
03D0:  SUBLW  C0
03D1:  MOVWF  42
03D2:  MOVLW  12
03D3:  MOVWF  43
03D4:  MOVF   22,W
03D5:  BTFSS  03.0
03D6:  INCFSZ 22,W
03D7:  SUBWF  43,F
....................     
....................       //SET OUTPUTS  
....................       //The writing of the ICEThrottle happens in interupts and all that is 
....................       //required is updating ICEthrottle 
....................        
....................       write_dac((right_position-(right_position-(Athrottle-Athrottle_Min)*Athrottle_servo_factor))*4); 
03D8:  MOVLW  32
03D9:  SUBWF  4F,W
03DA:  MOVWF  53
03DB:  MOVF   50,W
03DC:  MOVWF  54
03DD:  MOVLW  01
03DE:  BTFSS  03.0
03DF:  MOVLW  02
03E0:  SUBWF  54,F
03E1:  MOVF   54,W
03E2:  MOVWF  56
03E3:  MOVF   53,W
03E4:  MOVWF  55
03E5:  GOTO   12D
03E6:  MOVF   23,W
03E7:  MOVWF  5C
03E8:  MOVF   22,W
03E9:  MOVWF  5B
03EA:  MOVF   21,W
03EB:  MOVWF  5A
03EC:  MOVF   20,W
03ED:  MOVWF  59
03EE:  MOVLW  74
03EF:  MOVWF  60
03F0:  MOVLW  48
03F1:  MOVWF  5F
03F2:  MOVLW  4D
03F3:  MOVWF  5E
03F4:  MOVLW  7F
03F5:  MOVWF  5D
03F6:  CALL   14B
03F7:  BSF    03.1
03F8:  CLRF   58
03F9:  CLRF   57
03FA:  MOVLW  16
03FB:  MOVWF  56
03FC:  MOVLW  8B
03FD:  MOVWF  55
03FE:  MOVF   23,W
03FF:  MOVWF  5C
0400:  MOVF   22,W
0401:  MOVWF  5B
0402:  MOVF   21,W
0403:  MOVWF  5A
0404:  MOVF   20,W
0405:  MOVWF  59
0406:  CALL   1C0
0407:  BSF    03.1
0408:  CLRF   58
0409:  CLRF   57
040A:  MOVLW  16
040B:  MOVWF  56
040C:  MOVLW  8B
040D:  MOVWF  55
040E:  MOVF   23,W
040F:  MOVWF  5C
0410:  MOVF   22,W
0411:  MOVWF  5B
0412:  MOVF   21,W
0413:  MOVWF  5A
0414:  MOVF   20,W
0415:  MOVWF  59
0416:  CALL   1C0
0417:  MOVF   20,W
0418:  MOVWF  55
0419:  MOVF   21,W
041A:  MOVWF  56
041B:  MOVF   22,W
041C:  MOVWF  57
041D:  MOVF   23,W
041E:  MOVWF  58
041F:  MOVWF  5C
0420:  MOVF   22,W
0421:  MOVWF  5B
0422:  MOVF   21,W
0423:  MOVWF  5A
0424:  MOVF   20,W
0425:  MOVWF  59
0426:  CLRF   60
0427:  CLRF   5F
0428:  CLRF   5E
0429:  MOVLW  81
042A:  MOVWF  5D
042B:  CALL   14B
042C:  MOVF   23,W
042D:  MOVWF  5C
042E:  MOVF   22,W
042F:  MOVWF  5B
0430:  MOVF   21,W
0431:  MOVWF  5A
0432:  MOVF   20,W
0433:  MOVWF  59
0434:  GOTO   2FE
0435:  MOVF   22,W
0436:  MOVWF  5A
0437:  MOVF   21,W
0438:  MOVWF  59
0439:  MOVF   22,W
043A:  MOVWF  5C
043B:  MOVF   21,W
043C:  MOVWF  5B
043D:  CALL   0BB
....................       //write_dac((right_position-current_servo_position)*4); 
....................    } 
043E:  GOTO   393
....................     
....................  
.................... } 
....................  
.................... /*! \brief Initialisation of PID controller parameters. 
....................  * 
....................  *  Initialise the variables used by the PID algorithm. 
....................  * 
....................  *  \param p_factor  Proportional term. 
....................  *  \param i_factor  Integral term. 
....................  *  \param d_factor  Derivate term. 
....................  *  \param pid  Struct with PID status. 
....................  */ 
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid) 
.................... // Set up PID controller parameters 
043F:  GOTO   43F
.................... { 
....................   // Start values for PID controller 
....................   pid->sumError = 0; 
....................   pid->lastProcessValue = 0; 
....................   // Tuning constants for PID loop 
....................   pid->P_Factor = p_factor; 
....................   pid->I_Factor = i_factor; 
....................   pid->D_Factor = d_factor; 
....................   // Limits to avoid overflow 
....................   pid->maxError = MAX_INT / (pid->P_Factor + 1); 
....................   pid->maxSumError = MAX_I_TERM / (pid->I_Factor + 1); 
.................... } 
....................  
....................  
.................... /*! \brief PID control algorithm. 
....................  * 
....................  *  Calculates output from setpoint, process value and PID status. 
....................  * 
....................  *  \param setPoint  Desired value. 
....................  *  \param processValue  Measured value. 
....................  *  \param pid_st  PID status struct. 
....................  */ 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st) 
.................... { 
....................   int16 error, p_term, d_term; 
....................   int32 i_term, ret, temp; 
....................  
....................   error = setPoint - processValue; 
....................  
....................   // Calculate Pterm and limit error overflow 
....................   if (error > pid_st->maxError){ 
....................     p_term = MAX_INT; 
....................   } 
....................   else if (error < -pid_st->maxError){ 
....................     p_term = -MAX_INT; 
....................   } 
....................   else{ 
....................     p_term = pid_st->P_Factor * error; 
....................   } 
....................  
....................   // Calculate Iterm and limit integral runaway 
....................   temp = pid_st->sumError + error; 
....................   if(temp > pid_st->maxSumError){ 
....................     i_term = MAX_I_TERM; 
....................     pid_st->sumError = pid_st->maxSumError; 
....................   } 
....................   else if(temp < -pid_st->maxSumError){ 
....................     i_term = -MAX_I_TERM; 
....................     pid_st->sumError = -pid_st->maxSumError; 
....................   } 
....................   else{ 
....................     pid_st->sumError = temp; 
....................     i_term = pid_st->I_Factor * pid_st->sumError; 
....................   } 
....................  
....................   // Calculate Dterm 
....................   d_term = pid_st->D_Factor * (pid_st->lastProcessValue - processValue); 
....................  
....................   pid_st->lastProcessValue = processValue; 
....................  
....................   ret = (p_term + i_term + d_term) / SCALING_FACTOR; 
....................   if(ret > MAX_INT){ 
....................     ret = MAX_INT; 
....................   } 
....................   else if(ret < -MAX_INT){ 
....................     ret = -MAX_INT; 
....................   } 
....................  
....................   return((int16)ret); 
.................... } 
....................  
.................... /*! \brief Resets the integrator. 
....................  * 
....................  *  Calling this function will reset the integrator in the PID regulator. 
....................  */ 
.................... void pid_Reset_Integrator(pidData_t *pid_st) 
.................... { 
....................   pid_st->sumError = 0; 
.................... } 
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 373A   HS NOWDT NOPUT DEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
