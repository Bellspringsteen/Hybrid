CCS PCM C Compiler, Version 4.084, 46530               01-Jun-13 17:17

               Filename: HondaHybrid.lst

               ROM used: 2580 words (67%)
                         Largest free fragment is 1105
               RAM used: 60 (34%) at main() level
                         106 (59%) worst case
               Stack:    3 worst case (2 in main + 1 for interrupts)

*
0000:  NOP
0001:  MOVLW  08
0002:  MOVWF  0A
0003:  GOTO   000
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  26
0008:  MOVF   7F,W
0009:  MOVWF  25
000A:  MOVF   0A,W
000B:  MOVWF  2D
000C:  CLRF   0A
000D:  SWAPF  25,F
000E:  MOVF   04,W
000F:  MOVWF  27
0010:  MOVF   20,W
0011:  MOVWF  28
0012:  MOVF   21,W
0013:  MOVWF  29
0014:  MOVF   22,W
0015:  MOVWF  2A
0016:  MOVF   23,W
0017:  MOVWF  2B
0018:  MOVF   24,W
0019:  MOVWF  2C
001A:  BCF    03.7
001B:  BCF    03.5
001C:  MOVLW  8C
001D:  MOVWF  04
001E:  BTFSS  00.0
001F:  GOTO   022
0020:  BTFSC  0C.0
0021:  GOTO   03F
0022:  MOVLW  8D
0023:  MOVWF  04
0024:  BTFSS  00.0
0025:  GOTO   028
0026:  BTFSC  0D.0
0027:  GOTO   041
0028:  BTFSS  0B.5
0029:  GOTO   02C
002A:  BTFSC  0B.2
002B:  GOTO   043
002C:  MOVF   27,W
002D:  MOVWF  04
002E:  MOVF   28,W
002F:  MOVWF  20
0030:  MOVF   29,W
0031:  MOVWF  21
0032:  MOVF   2A,W
0033:  MOVWF  22
0034:  MOVF   2B,W
0035:  MOVWF  23
0036:  MOVF   2C,W
0037:  MOVWF  24
0038:  MOVF   2D,W
0039:  MOVWF  0A
003A:  SWAPF  26,W
003B:  MOVWF  03
003C:  SWAPF  7F,F
003D:  SWAPF  7F,W
003E:  RETFIE
003F:  BCF    0A.3
0040:  GOTO   11A
0041:  BCF    0A.3
0042:  GOTO   172
0043:  BCF    0A.3
0044:  GOTO   10C
.................... #include "HondaHybrid.h" 
.................... #include <16F873A.h> 
.................... //////// Standard Header file for the PIC16F873A device //////////////// 
.................... #device PIC16F873A 
.................... #list 
....................  
....................  
.................... //#include <16F737.h> 
.................... #device ICD=TRUE 
.................... #device adc=10 
.................... //#device adc=8 
.................... #use delay(clock=20000000) 
*
02F2:  MOVLW  58
02F3:  MOVWF  04
02F4:  MOVF   00,W
02F5:  BTFSC  03.2
02F6:  GOTO   304
02F7:  MOVLW  06
02F8:  MOVWF  21
02F9:  CLRF   20
02FA:  DECFSZ 20,F
02FB:  GOTO   2FA
02FC:  DECFSZ 21,F
02FD:  GOTO   2F9
02FE:  MOVLW  7B
02FF:  MOVWF  20
0300:  DECFSZ 20,F
0301:  GOTO   300
0302:  DECFSZ 00,F
0303:  GOTO   2F7
0304:  RETLW  00
.................... #fuses HS,PUT,NOWDT 
.................... #use rs232 (DEBUGGER) 
0305:  BSF    03.5
0306:  BCF    06.3
0307:  BCF    03.5
0308:  BCF    06.3
0309:  MOVLW  08
030A:  MOVWF  21
030B:  GOTO   30C
030C:  NOP
030D:  BSF    21.7
030E:  GOTO   31D
030F:  BCF    21.7
0310:  RRF    58,F
0311:  BTFSC  03.0
0312:  BSF    06.3
0313:  BTFSS  03.0
0314:  BCF    06.3
0315:  BSF    21.6
0316:  GOTO   31D
0317:  BCF    21.6
0318:  DECFSZ 21,F
0319:  GOTO   310
031A:  GOTO   31B
031B:  NOP
031C:  BSF    06.3
031D:  MOVLW  02
031E:  MOVWF  20
031F:  CLRF   04
0320:  DECFSZ 04,F
0321:  GOTO   320
0322:  DECFSZ 20,F
0323:  GOTO   31F
0324:  MOVLW  AD
0325:  MOVWF  04
0326:  DECFSZ 04,F
0327:  GOTO   326
0328:  GOTO   329
0329:  NOP
032A:  BTFSC  21.7
032B:  GOTO   30F
032C:  BTFSC  21.6
032D:  GOTO   317
032E:  RETLW  00
.................... #include <mcp4921.c> 
.................... //////////////// Driver for MCP4921 D/A Converter /////////////////////// 
.................... ////                                                                 //// 
.................... ////  init_dac()    Call this before using a MCP4921 DAC             //// 
.................... ////                                                                 //// 
.................... ////  write_dac( long int )   Writes command and 12 bit resolution   //// 
.................... ////                          to the MCP4921 which converts it to a  //// 
.................... ////                          voltage                                //// 
.................... ////                          0-4095 input represents 0-vref V out.  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SELECT 
....................  
.................... #define DAC_CS     PIN_C4 
.................... #define DAC_CLK    PIN_C3 
.................... #define DAC_DI     PIN_C5 
.................... #define DAC_LDAC   PIN_B5 
....................  
.................... #endif 
....................  
.................... void init_dac() 
.................... { 
....................    output_high(DAC_CS); 
*
018F:  BCF    2E.4
0190:  MOVF   2E,W
0191:  BSF    03.5
0192:  MOVWF  07
0193:  BCF    03.5
0194:  BSF    07.4
....................    output_high(DAC_LDAC); 
0195:  BSF    03.5
0196:  BCF    06.5
0197:  BCF    03.5
0198:  BSF    06.5
....................    output_high(DAC_CLK); 
0199:  BCF    2E.3
019A:  MOVF   2E,W
019B:  BSF    03.5
019C:  MOVWF  07
019D:  BCF    03.5
019E:  BSF    07.3
....................    output_high(DAC_DI); 
019F:  BCF    2E.5
01A0:  MOVF   2E,W
01A1:  BSF    03.5
01A2:  MOVWF  07
01A3:  BCF    03.5
01A4:  BSF    07.5
.................... } 
01A5:  BSF    0A.3
01A6:  GOTO   052 (RETURN)
....................  
.................... void write_dac(int16 data) { 
....................    BYTE cmd[3]; 
....................    BYTE i; 
....................  
....................    cmd[0]=data; 
01A7:  MOVF   5B,W
01A8:  MOVWF  5D
....................    cmd[1]=(data>>8); 
01A9:  MOVF   5C,W
01AA:  MOVWF  5E
....................    cmd[2]=0x03;                            
01AB:  MOVLW  03
01AC:  MOVWF  5F
....................     
....................    output_high(DAC_LDAC); 
01AD:  BSF    03.5
01AE:  BCF    06.5
01AF:  BCF    03.5
01B0:  BSF    06.5
....................    output_low(DAC_CLK); 
01B1:  BCF    2E.3
01B2:  MOVF   2E,W
01B3:  BSF    03.5
01B4:  MOVWF  07
01B5:  BCF    03.5
01B6:  BCF    07.3
....................    output_low(DAC_CS); 
01B7:  BCF    2E.4
01B8:  MOVF   2E,W
01B9:  BSF    03.5
01BA:  MOVWF  07
01BB:  BCF    03.5
01BC:  BCF    07.4
....................  
....................    for(i=0; i<=23; ++i) 
01BD:  CLRF   60
01BE:  MOVF   60,W
01BF:  SUBLW  17
01C0:  BTFSS  03.0
01C1:  GOTO   1EF
....................    { 
....................       if(i<4 || (i>7 && i<12)) 
01C2:  MOVF   60,W
01C3:  SUBLW  03
01C4:  BTFSC  03.0
01C5:  GOTO   1CE
01C6:  MOVF   60,W
01C7:  SUBLW  07
01C8:  BTFSC  03.0
01C9:  GOTO   1D3
01CA:  MOVF   60,W
01CB:  SUBLW  0B
01CC:  BTFSS  03.0
01CD:  GOTO   1D3
....................          shift_left(cmd,3,0); 
01CE:  BCF    03.0
01CF:  RLF    5D,F
01D0:  RLF    5E,F
01D1:  RLF    5F,F
....................       else 
01D2:  GOTO   1ED
....................       { 
....................          output_bit(DAC_DI, shift_left(cmd,3,0)); 
01D3:  BCF    03.0
01D4:  RLF    5D,F
01D5:  RLF    5E,F
01D6:  RLF    5F,F
01D7:  BTFSC  03.0
01D8:  GOTO   1DB
01D9:  BCF    07.5
01DA:  GOTO   1DC
01DB:  BSF    07.5
01DC:  BCF    2E.5
01DD:  MOVF   2E,W
01DE:  BSF    03.5
01DF:  MOVWF  07
....................  
....................          output_high(DAC_CLK); 
01E0:  BCF    03.5
01E1:  BCF    2E.3
01E2:  MOVF   2E,W
01E3:  BSF    03.5
01E4:  MOVWF  07
01E5:  BCF    03.5
01E6:  BSF    07.3
....................          output_low(DAC_CLK); 
01E7:  BCF    2E.3
01E8:  MOVF   2E,W
01E9:  BSF    03.5
01EA:  MOVWF  07
01EB:  BCF    03.5
01EC:  BCF    07.3
....................       } 
....................    } 
01ED:  INCF   60,F
01EE:  GOTO   1BE
....................    output_high(DAC_CS); 
01EF:  BCF    2E.4
01F0:  MOVF   2E,W
01F1:  BSF    03.5
01F2:  MOVWF  07
01F3:  BCF    03.5
01F4:  BSF    07.4
....................  
....................    output_low(DAC_LDAC); 
01F5:  BSF    03.5
01F6:  BCF    06.5
01F7:  BCF    03.5
01F8:  BCF    06.5
....................    delay_us(10); 
01F9:  MOVLW  10
01FA:  MOVWF  20
01FB:  DECFSZ 20,F
01FC:  GOTO   1FB
01FD:  NOP
....................     
....................    output_HIGH(DAC_LDAC); 
01FE:  BSF    03.5
01FF:  BCF    06.5
0200:  BCF    03.5
0201:  BSF    06.5
.................... } 
0202:  RETLW  00
....................  
....................  
....................  
.................... #include "pid.h" 
.................... /*This file has been prepared for Doxygen automatic documentation generation.*/ 
.................... /*! \file ********************************************************************* 
....................  * 
....................  * \brief Header file for pid.c. 
....................  * 
....................  * - File:               pid.h 
....................  * - Compiler:           IAR EWAAVR 4.11A 
....................  * - Supported devices:  All AVR devices can be used. 
....................  * - AppNote:            AVR221 - Discrete PID controller 
....................  * 
....................  * \author               Atmel Corporation: http://www.atmel.com \n 
....................  *                       Support email: avr@atmel.com 
....................  * 
....................  * $Name$ 
....................  * $Revision: 456 $ 
....................  * $RCSfile$ 
....................  * $Date: 2006-02-16 12:46:13 +0100 (to, 16 feb 2006) $ 
....................  *****************************************************************************/ 
....................  
.................... #ifndef PID_H 
.................... #define PID_H 
....................  
.................... //#include "stdint.h" 
.................... #define INT16_MAX 32767 
.................... #define INT32_MAX 2147483647 
.................... #define SCALING_FACTOR  128 
....................  
.................... /*! \brief PID Status 
....................  * 
....................  * Setpoints and data used by the PID control algorithm 
....................  */ 
.................... typedef struct PID_DATA{ 
....................   //! Last process value, used to find derivative of process value. 
....................   int16 lastProcessValue; 
....................   //! Summation of errors, used for integrate calculations 
....................   int32 sumError; 
....................   //! The Proportional tuning constant, multiplied with SCALING_FACTOR 
....................   int16 P_Factor; 
....................   //! The Integral tuning constant, multiplied with SCALING_FACTOR 
....................   int16 I_Factor; 
....................   //! The Derivative tuning constant, multiplied with SCALING_FACTOR 
....................   int16 D_Factor; 
....................   //! Maximum allowed error, avoid overflow 
....................   int16 maxError; 
....................   //! Maximum allowed sumerror, avoid overflow 
....................   int32 maxSumError; 
.................... } pidData_t; 
....................  
.................... /*! \brief Maximum values 
....................  * 
....................  * Needed to avoid sign/overflow problems 
....................  */ 
.................... // Maximum value of variables 
.................... #define MAX_INT         INT16_MAX 
.................... #define MAX_LONG        INT32_MAX 
.................... #define MAX_I_TERM      (MAX_LONG / 2) 
....................  
.................... // Boolean values 
.................... //#define FALSE           0 
.................... //#define TRUE            1 
....................  
.................... boolean checkRunnaway(struct PID_DATA *pid); 
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid); 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st); 
.................... void pid_Reset_Integrator(pidData_t *pid_st); 
....................  
.................... #endif 
....................  
.................... /* 
.................... This is the main controller for the super capacitor hybrid scooter a.k.a RED 
.................... B2 close contactor 
.................... CONTROL BOX INPUTS 
.................... Athrottle- A0 - analog input representing the users input for speed, 10 bit 
.................... Vspeed - CCp2-a 16 bit representation of the speed of the vehicle 
.................... Acaps- A1 - analog input representing the current voltage of the supercapacitors, 10 bit 
.................... There are 18 Supercaps with a maximum voltage of 2.7 (2.85 is breakdown) volts for a total of 48.6 V 
.................... The circuit has a 10/110 voltage divider into the ADC. So minimum voltage of 18 Volts is 335 and 48 Volts is 893. Measured 38.2V equal to 726 
....................  
.................... CONTROL BOX OUTPUT 
.................... ICEthrottle- B1 - a 16 bit number sent to the internal combustion engine(ICE) throttle  
.................... ELECthrottle-  - a 16 bit number sent as analog value representing the demanded electric power 
....................  
.................... SPECIFICS OF I/O 
....................  
.................... Athrottle - the electric throttle is a 3 wire unit with a 5 volt,ground, and analog out 
....................    representing how far throttle is turned. Pin AN0 is the input. 
....................     
.................... Vspeed - There is a encoder in the rear wheel/electric motor that is used by the electric 
....................    power controller. Tapping in to this this Main Controller receives a 5 Volt square wave 
....................    with 42 pulses. There are two options for measuring speed. The first is to measure the  
....................    length of the pulses. The second is to measure the rate of pulses. This controller currently 
....................    uses the rate method. The int_ccp2 interupt is called on each falling edge and stores the  
....................    Vspeed value as the max number of 16bit (65535-timer0_since_last_reset).  
....................     
....................    The RED scooter has a circumpherence of 16.3*2*pi = 102.4 
....................    X m/h * 63360 inch/mile * 1/3600 h/sec * 1/(102.4 inch/rev) = .171875* X 
....................    Examples 50 mph is 8.9 ms 1 overflow of timer0 
....................    Example 5 mph is 89 ms or 13 time overflow 
....................     
....................    #int_timer0 increments the counter number_of_overflows each time it overflows 
....................    On int ccp2 we multiply number_of_overflows * 256 + timer0 to get timer0_since_last_reset 
....................     
.................... Acaps - the analog voltage which is the 5volt representation of the voltage in the caps which 
....................    have a value of between 0-48v. The voltages are factored so that the voltage on AN1 goes 
....................    from 0 - 4.8 volts (TODO check this factor, think its 1/11 not 1/10) 
....................     
.................... ICEthrottle -  #int_timer1 is set to make sure the period follows the required below 
....................    The period for the servo is .020 seconds which is 50,000 operations 
....................    The leftmost position of the server is .001 seconds which is 2,500 
....................    The rightmost position of the server is .002 seconds which is 5,000 
....................     
....................    The output pin is pin_B1.-> 
....................  
.................... ELECthrottle 
....................    The electric power controller takes an analog voltage as input. The output voltage 
....................    is set by the DAC. The pins used are C3,C4,C5. if CHARGING_STATE is true then  
....................     
.................... ALGORITHM 
....................    The algorithm is basically a PID controller. In broad terms we are trying to set the 
....................    ICEthrottle and ICEelectric to maximize the use of electric and accelerate to meet the 
....................    requirements set by the rider with the Athrottle signal. When the demanded power is  
....................    less than the power output possible by the ICE and the caps are in the CHARGING_STATE  
....................    then the ICE is turned up to the max and the ELECthrottle is set to regen to 
....................    charge the capacitors.If CHARGING_STATE is false then the caps are supplying the drivig power 
....................    and the ICE is set to "off", the caps supply the power. Unless the user requested supply 
....................    is enough to require both power sources. 
....................     
....................    If CHARGING_STATE is true. Then pin_b2 is set as high which will close the brake number 
....................    for the electric power controller.  
....................     
....................    If CHARGING_STATE is false then the pin_b2 is set low which opens brake. 
....................     
....................     
....................  
....................  
.................... The encoder has 42 on and offs per rotation, i.e. 21 steps 
....................  
.................... Number of operations per second is CLOCK/4/Timer Divisions 
.................... Number of operations per second is 20,000,000/4/128 = 39062.5  
.................... Each operation takes 1/39062.5 = .256 micro (x10^-6) seconds 
.................... Seconds to Overflow timer0 8bit timer = .256x10^-6 * 256 = 6.55ms 
....................  
....................  
....................  
.................... */ 
.................... #define servo_pin PIN_B1  //Setting servo out pin to be hardware pin b1 
.................... #define brake_pin PIN_B4 
.................... #define ADC_DELAY delay_us(20) 
.................... #define Acaps_pin PIN_A1 
.................... #define Acaps_channel 1 
.................... #define Athrottle_pin PIN_A0  //Voltage goes from 1.5 (306)to 4.1(836) 
.................... #define Athrottle_Min 316 
.................... #define Athrottle_Max 860 
.................... #define Athrottle_Full Athrottle_Max-Athrottle_Min 
.................... #define Athrottle_channel 0 
.................... #define Electric_Controller_Switch PIN_B0 
.................... #define Contactor_Switch PIN_B2 
.................... #define A_CAPS_MAX 793//893 
.................... #define A_CAPS_MIN 335 
.................... #define A_CAPS_MID_LOW (A_CAPS_MIN + 100) //This is the low end of the middle ACaps range. The range in which discharge and charge are allowed.  
.................... #define A_CAPS_MID_HIGH (A_CAPS_MAX - 100) //This is the low end of the middle ACaps range. The range in which discharge and charge are allowed.  
.................... #define V_SPEED_REGEN_MIN 50 //Why is there a minimum speed? Because below this no regenerative action is possible with electric motor 
.................... #define INSUFFICIENT_BRAKING_RUNNAWAY_ERROR 10000 
....................  
.................... //PID Values 
.................... #define K_P 1.00 
.................... #define K_I 0.00 
.................... #define K_D 0.00 
....................  
.................... int1 pid_Timer = 0; 
*
0811:  BCF    2F.0
.................... struct PID_DATA pidData; 
.................... #define TIME_INTERVAL 157 //TODO replace 
....................  
.................... #define left_position 4450 
.................... #define right_position 5300 
.................... #define servo_difference  right_position-left_position 
.................... #define servo_difference_div 5100 
.................... #define ELEC_CONTROLLER_OFFSET 900 
.................... const float Athrottle_servo_factor = ((float) servo_difference)/((float) Athrottle_FULL); 
.................... #define servo_period   65356-50000 
.................... unsigned int16 current_servo_position=right_position; 
0812:  MOVLW  B4
0813:  MOVWF  42
0814:  MOVLW  14
0815:  MOVWF  43
.................... int1 SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0; 
0816:  BCF    2F.1
.................... int1 test_boolean = 0; 
0817:  BCF    2F.2
....................  
.................... int1 test_switch = 0; 
0818:  BCF    2F.3
.................... unsigned int16 test_counter = 0; 
0819:  CLRF   44
081A:  CLRF   45
.................... //int16 returnedValue = 0; 
....................  
.................... unsigned int16 number_of_timer0_interupts_since_reset =0; 
081B:  CLRF   46
081C:  CLRF   47
.................... unsigned int16 timer0_since_last_reset= 0; 
081D:  CLRF   48
081E:  CLRF   49
.................... unsigned int16 vSpeed= 0; 
081F:  CLRF   4A
0820:  CLRF   4B
.................... signed int16 ELECthrottle = 0; 
0821:  CLRF   4C
0822:  CLRF   4D
.................... unsigned int16 ICEthrottle = 0; 
0823:  CLRF   4E
0824:  CLRF   4F
.................... unsigned int16 Athrottle = 0; 
0825:  CLRF   50
0826:  CLRF   51
.................... unsigned int16 Acaps = 0; 
0827:  CLRF   52
0828:  CLRF   53
.................... int1 ICE_ON = 0; 
0829:  BCF    2F.4
.................... int1 CURRENTLY_CHARGING = 0; 
082A:  BCF    2F.5
.................... int1 RUNNAWAY_CHECK = 0; 
082B:  BCF    2F.6
.................... signed int16 returnedValue =0;  
082C:  CLRF   54
082D:  CLRF   55
....................  
.................... enum{  
....................    EVERYTHING_OFF, 
....................    SPEED_TO_LOW_ICE_DIRECT, 
....................    CHARGING_ALLOWED,  
....................    DISCHARGING_ALLOWED,  
....................    CHARGING_AND_DISCHARING_ALLOWED, 
....................    INSUFFICIENT_BRAKING_RUNAWAY 
.................... } CHARGING_STATE;  
....................  
.................... /* 
.................... The #int_timer0 interupt is triggered on each timer0 8bit interupt 
.................... the function simply increments a overflow counter to be used by the ccp2 
.................... interupt to calculate speed 
.................... NUMBER OF OPERATIONS =  
.................... */ 
.................... #int_timer0 
.................... void timer0_isr(){ 
....................     
....................       number_of_timer0_interupts_since_reset=number_of_timer0_interupts_since_reset+256; 
*
010C:  MOVLW  01
010D:  ADDWF  47,F
....................       //current_servo_position=current_servo_position+1; 
....................        
....................     
....................    if (number_of_timer0_interupts_since_reset>=1024){ 
010E:  MOVF   47,W
010F:  SUBLW  03
0110:  BTFSC  03.0
0111:  GOTO   117
....................       vSpeed = 0; 
0112:  CLRF   4B
0113:  CLRF   4A
....................       number_of_timer0_interupts_since_reset=1024; 
0114:  MOVLW  04
0115:  MOVWF  47
0116:  CLRF   46
....................        
....................        
....................    } 
.................... } 
....................  
.................... /* 
.................... #int_timer1 is used by the ICEservo throttle to regulate the timing pulses. The  
.................... timer is setup for a pulsetrain of 20ms period. This is done as follows, 
....................  
.................... Period is 1/(CLOCK/4opsperclock)*(startingPostionOfClock) = 20 ms 
.................... for this setup 1/(20000000/4)*(50000) = 20 ms 
....................  
.................... The timer1 starts at 0 and counts up. So we set the beggining of the clock at 
.................... servo_period which is 65356-50000 so that the total time is 20ms. 
.................... */ 
0117:  BCF    0B.2
0118:  BCF    0A.3
0119:  GOTO   02C
.................... #int_timer1 
.................... void isr() 
.................... { 
....................  
.................... //Make sure that the position is within the left and right positions of the servo 
....................    if (current_servo_position<left_position){ 
011A:  MOVF   43,W
011B:  SUBLW  11
011C:  BTFSS  03.0
011D:  GOTO   129
011E:  BTFSS  03.2
011F:  GOTO   124
0120:  MOVF   42,W
0121:  SUBLW  61
0122:  BTFSS  03.0
0123:  GOTO   129
....................       current_servo_position = left_position; 
0124:  MOVLW  11
0125:  MOVWF  43
0126:  MOVLW  62
0127:  MOVWF  42
....................    } 
....................    else if (current_servo_position > right_position){ 
0128:  GOTO   138
0129:  MOVF   43,W
012A:  SUBLW  13
012B:  BTFSC  03.0
012C:  GOTO   138
012D:  XORLW  FF
012E:  BTFSS  03.2
012F:  GOTO   134
0130:  MOVF   42,W
0131:  SUBLW  B4
0132:  BTFSC  03.0
0133:  GOTO   138
....................       current_servo_position = right_position; 
0134:  MOVLW  14
0135:  MOVWF  43
0136:  MOVLW  B4
0137:  MOVWF  42
....................    } 
....................  
....................    if(SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER) 
0138:  BTFSS  2F.1
0139:  GOTO   157
....................       {  
....................          output_high(servo_pin);        //Set the servo control pin to high  
013A:  BSF    03.5
013B:  BCF    06.1
013C:  BCF    03.5
013D:  BSF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0;  
013E:  BCF    2F.1
....................          set_timer1(65356-current_servo_position); //Set timer for the position high pulse 
013F:  MOVF   42,W
0140:  SUBLW  4C
0141:  BSF    03.5
0142:  MOVWF  29
0143:  MOVLW  FF
0144:  MOVWF  2A
0145:  BCF    03.5
0146:  MOVF   43,W
0147:  BTFSS  03.0
0148:  INCFSZ 43,W
0149:  GOTO   14B
014A:  GOTO   14E
014B:  BSF    03.5
014C:  SUBWF  2A,F
014D:  BCF    03.5
014E:  BSF    03.5
014F:  MOVF   2A,W
0150:  BCF    03.5
0151:  MOVWF  0F
0152:  BSF    03.5
0153:  MOVF   29,W
0154:  BCF    03.5
0155:  MOVWF  0E
....................       }  
....................    else  
0156:  GOTO   16F
....................       {  
....................          output_low(servo_pin);                      // Set the servo control pin to low   
0157:  BSF    03.5
0158:  BCF    06.1
0159:  BCF    03.5
015A:  BCF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 1;  
015B:  BSF    2F.1
....................          set_timer1(servo_period+current_servo_position);          //Set timer for the low position the length is the difference between  
015C:  MOVLW  FC
015D:  ADDWF  42,W
015E:  BSF    03.5
015F:  MOVWF  29
0160:  BCF    03.5
0161:  MOVF   43,W
0162:  BSF    03.5
0163:  MOVWF  2A
0164:  MOVLW  3B
0165:  BTFSC  03.0
0166:  MOVLW  3C
0167:  ADDWF  2A,F
0168:  MOVF   2A,W
0169:  BCF    03.5
016A:  MOVWF  0F
016B:  BSF    03.5
016C:  MOVF   29,W
016D:  BCF    03.5
016E:  MOVWF  0E
....................                                                      //the total int16 lenght - high pulse length 
....................       }   
....................  
.................... } 
....................  
....................  
.................... /* 
.................... #int_ccp2 is called on the falling edge of the encoder pulse. We calculate the time 
.................... between pulses.  
.................... TODO will have to put some kind of smoothing mechanism 
.................... */ 
016F:  BCF    0C.0
0170:  BCF    0A.3
0171:  GOTO   02C
.................... #int_ccp2 
.................... void isr2() 
.................... { 
.................... if (number_of_timer0_interupts_since_reset>10){ 
0172:  MOVF   47,F
0173:  BTFSS  03.2
0174:  GOTO   179
0175:  MOVF   46,W
0176:  SUBLW  0A
0177:  BTFSC  03.0
0178:  GOTO   18C
.................... vSpeed  = 1280 - (number_of_timer0_interupts_since_reset+get_timer0()); 
0179:  MOVF   01,W
017A:  ADDWF  46,W
017B:  MOVWF  21
017C:  MOVF   47,W
017D:  MOVWF  23
017E:  BTFSC  03.0
017F:  INCF   23,F
0180:  MOVF   21,W
0181:  SUBLW  00
0182:  MOVWF  4A
0183:  MOVLW  05
0184:  MOVWF  4B
0185:  MOVF   23,W
0186:  BTFSS  03.0
0187:  INCFSZ 23,W
0188:  SUBWF  4B,F
.................... //vSpeed  = -(get_timer0()); 
.................... set_timer0(0); 
0189:  CLRF   01
.................... number_of_timer0_interupts_since_reset = 0; 
018A:  CLRF   47
018B:  CLRF   46
.................... } 
.................... } 
....................  
018C:  BCF    0D.0
018D:  BCF    0A.3
018E:  GOTO   02C
.................... void trickBreaking(){ 
.................... write_dac((unsigned int16) 400+ELEC_CONTROLLER_OFFSET); 
*
075B:  MOVLW  05
075C:  MOVWF  5C
075D:  MOVLW  14
075E:  MOVWF  5B
075F:  CALL   1A7
.................... delay_ms(500);       
0760:  MOVLW  02
0761:  MOVWF  57
0762:  MOVLW  FA
0763:  MOVWF  58
0764:  CALL   2F2
0765:  DECFSZ 57,F
0766:  GOTO   762
.................... } 
0767:  BSF    0A.3
0768:  GOTO   1F9 (RETURN)
....................  
.................... void main() 
.................... {   
*
0800:  CLRF   04
0801:  MOVLW  1F
0802:  ANDWF  03,F
0803:  BSF    03.5
0804:  BCF    06.3
0805:  BCF    03.5
0806:  BSF    06.3
0807:  BSF    03.5
0808:  BSF    1F.0
0809:  BSF    1F.1
080A:  BSF    1F.2
080B:  BCF    1F.3
080C:  MOVLW  07
080D:  MOVWF  1C
....................     
....................    setup_adc_ports(NO_ANALOGS); 
*
082E:  BSF    03.5
082F:  BSF    1F.0
0830:  BSF    1F.1
0831:  BSF    1F.2
0832:  BCF    1F.3
....................    setup_adc(ADC_OFF); 
0833:  BCF    03.5
0834:  BCF    1F.0
....................    setup_spi(FALSE); 
0835:  CLRF   14
....................     
....................    setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
0836:  BSF    03.5
0837:  MOVF   01,W
0838:  ANDLW  C0
0839:  IORLW  00
083A:  MOVWF  01
083B:  CLRWDT
....................    setup_timer_1(T1_DISABLED); 
083C:  BCF    03.5
083D:  CLRF   10
....................    setup_timer_2(T2_DISABLED,0,1); 
083E:  MOVLW  00
083F:  MOVWF  21
0840:  MOVWF  12
0841:  MOVLW  00
0842:  BSF    03.5
0843:  MOVWF  12
....................    setup_port_a(ALL_ANALOG); 
0844:  BCF    1F.0
0845:  BCF    1F.1
0846:  BCF    1F.2
0847:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
0848:  BCF    1F.6
0849:  BCF    03.5
084A:  BSF    1F.6
084B:  BSF    1F.7
084C:  BSF    03.5
084D:  BSF    1F.7
084E:  BCF    03.5
084F:  BSF    1F.0
....................     
....................    init_dac(); 
0850:  BCF    0A.3
0851:  GOTO   18F
0852:  BSF    0A.3
....................   
....................    setup_timer_1(T1_DIV_BY_2| T1_INTERNAL);  
0853:  MOVLW  95
0854:  MOVWF  10
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_128); 
0855:  BSF    03.5
0856:  MOVF   01,W
0857:  ANDLW  C0
0858:  IORLW  06
0859:  MOVWF  01
....................    setup_ccp2(CCP_CAPTURE_RE);    // Configure CCP2 to capture fall 
085A:  BCF    03.5
085B:  BSF    2E.1
085C:  MOVF   2E,W
085D:  BSF    03.5
085E:  MOVWF  07
085F:  BCF    03.5
0860:  CLRF   1D
0861:  MOVLW  05
0862:  MOVWF  1D
....................    enable_interrupts(INT_CCP2);   // Setup interrupt on falling edge 
0863:  BSF    03.5
0864:  BSF    0D.0
....................    enable_interrupts(INT_TIMER0); 
0865:  BCF    03.5
0866:  BSF    0B.5
....................    enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
0867:  BSF    03.5
0868:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
0869:  MOVLW  C0
086A:  BCF    03.5
086B:  IORWF  0B,F
....................     
....................    CHARGING_STATE = EVERYTHING_OFF; 
086C:  CLRF   56
....................    output_low(Electric_Controller_Switch); 
086D:  BSF    03.5
086E:  BCF    06.0
086F:  BCF    03.5
0870:  BCF    06.0
....................    write_dac(0); 
0871:  CLRF   5C
0872:  CLRF   5B
0873:  BCF    0A.3
0874:  CALL   1A7
0875:  BSF    0A.3
....................    ICE_ON=TRUE; 
0876:  BSF    2F.4
....................    output_high(Contactor_Switch); 
0877:  BSF    03.5
0878:  BCF    06.2
0879:  BCF    03.5
087A:  BSF    06.2
....................    output_low(brake_pin); 
087B:  BSF    03.5
087C:  BCF    06.4
087D:  BCF    03.5
087E:  BCF    06.4
....................    pid_Init(K_P*SCALING_FACTOR,K_I*SCALING_FACTOR,K_D*SCALING_FACTOR, & pidData); 
087F:  CLRF   58
0880:  MOVLW  80
0881:  MOVWF  57
0882:  CLRF   5A
0883:  CLRF   59
0884:  CLRF   5C
0885:  CLRF   5B
0886:  MOVLW  30
0887:  MOVWF  5D
0888:  BCF    0A.3
0889:  GOTO   203
088A:  BSF    0A.3
....................    delay_ms(3000); 
088B:  MOVLW  0C
088C:  MOVWF  57
088D:  MOVLW  FA
088E:  MOVWF  58
088F:  BCF    0A.3
0890:  CALL   2F2
0891:  BSF    0A.3
0892:  DECFSZ 57,F
0893:  GOTO   08D
....................    //write_dac(1000); 
....................    //delay_ms(10000); 
....................    //output_high(Contactor_Switch); 
....................    //output_high(brake_pin); 
....................    //output_high(Electric_Controller_Switch); 
....................    while(TRUE) { 
....................  
....................       //GET INPUTS 
....................       //Vspeedhappens in interrupts 
....................        
....................       set_adc_channel(Acaps_channel); 
0894:  MOVLW  08
0895:  MOVWF  21
0896:  MOVF   1F,W
0897:  ANDLW  C7
0898:  IORWF  21,W
0899:  MOVWF  1F
....................       ADC_DELAY; 
089A:  MOVLW  21
089B:  MOVWF  20
089C:  DECFSZ 20,F
089D:  GOTO   09C
....................       Acaps = read_adc(); 
089E:  BSF    1F.2
089F:  BTFSC  1F.2
08A0:  GOTO   09F
08A1:  BSF    03.5
08A2:  MOVF   1E,W
08A3:  BCF    03.5
08A4:  MOVWF  52
08A5:  MOVF   1E,W
08A6:  MOVWF  53
....................        
....................       set_adc_channel(Athrottle_channel); 
08A7:  MOVLW  00
08A8:  MOVWF  21
08A9:  MOVF   1F,W
08AA:  ANDLW  C7
08AB:  IORWF  21,W
08AC:  MOVWF  1F
....................       ADC_DELAY; 
08AD:  MOVLW  21
08AE:  MOVWF  20
08AF:  DECFSZ 20,F
08B0:  GOTO   0AF
....................       Athrottle = read_adc(); 
08B1:  BSF    1F.2
08B2:  BTFSC  1F.2
08B3:  GOTO   0B2
08B4:  BSF    03.5
08B5:  MOVF   1E,W
08B6:  BCF    03.5
08B7:  MOVWF  50
08B8:  MOVF   1E,W
08B9:  MOVWF  51
....................       if (Athrottle<Athrottle_Min){ 
08BA:  MOVF   51,W
08BB:  SUBLW  01
08BC:  BTFSS  03.0
08BD:  GOTO   0C8
08BE:  BTFSS  03.2
08BF:  GOTO   0C4
08C0:  MOVF   50,W
08C1:  SUBLW  3B
08C2:  BTFSS  03.0
08C3:  GOTO   0C8
....................          Athrottle=Athrottle_Min; 
08C4:  MOVLW  01
08C5:  MOVWF  51
08C6:  MOVLW  3C
08C7:  MOVWF  50
....................       } 
....................  
....................       //SET THE STATE 
....................       if (Acaps> (A_CAPS_MAX +5)){ 
08C8:  MOVF   53,W
08C9:  SUBLW  02
08CA:  BTFSC  03.0
08CB:  GOTO   0F3
08CC:  XORLW  FF
08CD:  BTFSS  03.2
08CE:  GOTO   0D3
08CF:  MOVF   52,W
08D0:  SUBLW  1E
08D1:  BTFSC  03.0
08D2:  GOTO   0F3
....................          //FREAK OUT 
....................          printf("State: Freak Out \n"); 
08D3:  CLRF   57
08D4:  MOVF   57,W
08D5:  BCF    0A.3
08D6:  CALL   045
08D7:  BSF    0A.3
08D8:  INCF   57,F
08D9:  MOVWF  20
08DA:  MOVWF  58
08DB:  BCF    0A.3
08DC:  CALL   305
08DD:  BSF    0A.3
08DE:  MOVLW  12
08DF:  SUBWF  57,W
08E0:  BTFSS  03.2
08E1:  GOTO   0D4
....................          output_low(Electric_Controller_Switch); 
08E2:  BSF    03.5
08E3:  BCF    06.0
08E4:  BCF    03.5
08E5:  BCF    06.0
....................          write_dac(0); 
08E6:  CLRF   5C
08E7:  CLRF   5B
08E8:  BCF    0A.3
08E9:  CALL   1A7
08EA:  BSF    0A.3
....................          output_high(Contactor_Switch); 
08EB:  BSF    03.5
08EC:  BCF    06.2
08ED:  BCF    03.5
08EE:  BSF    06.2
....................          CHARGING_STATE =EVERYTHING_OFF; 
08EF:  CLRF   56
....................         return; 
08F0:  GOTO   2AA
....................         break; 
08F1:  GOTO   2AA
....................       } 
....................       else if (ICE_ON&&(vSpeed<V_SPEED_REGEN_MIN)){ 
08F2:  GOTO   18C
08F3:  BTFSS  2F.4
08F4:  GOTO   10E
08F5:  MOVF   4B,F
08F6:  BTFSS  03.2
08F7:  GOTO   10E
08F8:  MOVF   4A,W
08F9:  SUBLW  31
08FA:  BTFSS  03.0
08FB:  GOTO   10E
....................          printf("State: Speed To Low \n"); 
08FC:  CLRF   57
08FD:  MOVF   57,W
08FE:  BCF    0A.3
08FF:  CALL   05C
0900:  BSF    0A.3
0901:  INCF   57,F
0902:  MOVWF  20
0903:  MOVWF  58
0904:  BCF    0A.3
0905:  CALL   305
0906:  BSF    0A.3
0907:  MOVLW  15
0908:  SUBWF  57,W
0909:  BTFSS  03.2
090A:  GOTO   0FD
....................          CHARGING_STATE=SPEED_TO_LOW_ICE_DIRECT; 
090B:  MOVLW  01
090C:  MOVWF  56
....................       } 
....................       else if (checkRunnaway(& pidData)){// INSUFFICIENT_BRAKING_RUNNAWAY_ERROR){ 
090D:  GOTO   18C
090E:  MOVLW  30
090F:  MOVWF  57
0910:  BCF    0A.3
0911:  GOTO   32F
0912:  BSF    0A.3
0913:  MOVF   21,F
0914:  BTFSC  03.2
0915:  GOTO   129
....................          printf("State: RUNNAWAY \n"); 
0916:  CLRF   57
0917:  MOVF   57,W
0918:  BCF    0A.3
0919:  CALL   076
091A:  BSF    0A.3
091B:  INCF   57,F
091C:  MOVWF  20
091D:  MOVWF  58
091E:  BCF    0A.3
091F:  CALL   305
0920:  BSF    0A.3
0921:  MOVLW  11
0922:  SUBWF  57,W
0923:  BTFSS  03.2
0924:  GOTO   117
....................          ICE_ON=TRUE; 
0925:  BSF    2F.4
....................          CHARGING_STATE=INSUFFICIENT_BRAKING_RUNAWAY; 
0926:  MOVLW  05
0927:  MOVWF  56
....................       } 
....................       else if ((Acaps > A_CAPS_MAX)&&(CHARGING_STATE==CHARGING_ALLOWED||CHARGING_STATE==CHARGING_AND_DISCHARING_ALLOWED)){ 
0928:  GOTO   18C
0929:  MOVF   53,W
092A:  SUBLW  02
092B:  BTFSC  03.0
092C:  GOTO   14F
092D:  XORLW  FF
092E:  BTFSS  03.2
092F:  GOTO   134
0930:  MOVF   52,W
0931:  SUBLW  19
0932:  BTFSC  03.0
0933:  GOTO   14F
0934:  MOVF   56,W
0935:  SUBLW  02
0936:  BTFSC  03.2
0937:  GOTO   13C
0938:  MOVF   56,W
0939:  SUBLW  04
093A:  BTFSS  03.2
093B:  GOTO   14F
....................          //Stop Charging they are full 
....................          printf("State: Caps Full \n"); 
093C:  CLRF   57
093D:  MOVF   57,W
093E:  BCF    0A.3
093F:  CALL   08C
0940:  BSF    0A.3
0941:  INCF   57,F
0942:  MOVWF  20
0943:  MOVWF  58
0944:  BCF    0A.3
0945:  CALL   305
0946:  BSF    0A.3
0947:  MOVLW  12
0948:  SUBWF  57,W
0949:  BTFSS  03.2
094A:  GOTO   13D
....................         ICE_ON=FALSE; 
094B:  BCF    2F.4
....................         CHARGING_STATE=DISCHARGING_ALLOWED; 
094C:  MOVLW  03
094D:  MOVWF  56
....................       } 
....................       else if ((Acaps < A_CAPS_MIN)&& CHARGING_STATE!=CHARGING_ALLOWED){ 
094E:  GOTO   18C
094F:  MOVF   53,W
0950:  SUBLW  01
0951:  BTFSS  03.0
0952:  GOTO   170
0953:  BTFSS  03.2
0954:  GOTO   159
0955:  MOVF   52,W
0956:  SUBLW  4E
0957:  BTFSS  03.0
0958:  GOTO   170
0959:  MOVF   56,W
095A:  SUBLW  02
095B:  BTFSC  03.2
095C:  GOTO   170
....................          //Stop running electric, the caps are almost empty 
....................         printf("State: Caps Empty \n"); 
095D:  CLRF   57
095E:  MOVF   57,W
095F:  BCF    0A.3
0960:  CALL   0A3
0961:  BSF    0A.3
0962:  INCF   57,F
0963:  MOVWF  20
0964:  MOVWF  58
0965:  BCF    0A.3
0966:  CALL   305
0967:  BSF    0A.3
0968:  MOVLW  13
0969:  SUBWF  57,W
096A:  BTFSS  03.2
096B:  GOTO   15E
....................         ICE_ON=TRUE; 
096C:  BSF    2F.4
....................         CHARGING_STATE=CHARGING_ALLOWED; 
096D:  MOVLW  02
096E:  MOVWF  56
....................       } 
....................      else if (A_CAPS_MID_LOW < Acaps < A_CAPS_MID_HIGH){ 
096F:  GOTO   18C
0970:  MOVF   53,W
0971:  SUBLW  00
0972:  BTFSC  03.0
0973:  GOTO   17A
0974:  XORLW  FF
0975:  BTFSS  03.2
0976:  GOTO   17B
0977:  MOVF   52,W
0978:  SUBLW  B3
0979:  BTFSC  03.0
097A:  MOVLW  00
....................         printf("State: Normal \n"); 
097B:  CLRF   57
097C:  MOVF   57,W
097D:  BCF    0A.3
097E:  CALL   0BB
097F:  BSF    0A.3
0980:  INCF   57,F
0981:  MOVWF  20
0982:  MOVWF  58
0983:  BCF    0A.3
0984:  CALL   305
0985:  BSF    0A.3
0986:  MOVLW  0F
0987:  SUBWF  57,W
0988:  BTFSS  03.2
0989:  GOTO   17C
....................         CHARGING_STATE=CHARGING_AND_DISCHARING_ALLOWED; 
098A:  MOVLW  04
098B:  MOVWF  56
....................      } 
....................       
....................       
.................... //PID CONTROLLER 
....................       //Servo to mirror Athrottle ->  
.................... //      current_servo_position=right_position-(Athrottle-Athrottle_Min)*Athrottle_servo_factor;//(Athrottle/Athrottle_Full)*servo_difference;//(vSpeed/65536.0)*(2500); 
....................       //printf("Analog Cap %d Analog Throttle %Lu\n",(int) Acaps,Athrottle); 
....................       //current_servo_position =right_position-vSpeed+200; 
....................       //printf("Speed %lu \n",speeder); 
....................       //SET OUTPUTS  
....................       //The writing of the ICEThrottle happens in interupts and all that is 
....................       //required is updating ICEthrottle 
....................       //printf("speed before %ld \n",vSpeed); 
....................        
....................       returnedValue = pid_Controller((Athrottle-AThrottle_Min),vSpeed,& pidData); 
098C:  MOVLW  3C
098D:  SUBWF  50,W
098E:  MOVWF  57
098F:  MOVF   51,W
0990:  MOVWF  58
0991:  MOVLW  01
0992:  BTFSS  03.0
0993:  MOVLW  02
0994:  SUBWF  58,F
0995:  MOVF   58,W
0996:  MOVWF  5A
0997:  MOVF   57,W
0998:  MOVWF  59
0999:  MOVF   4B,W
099A:  MOVWF  5C
099B:  MOVF   4A,W
099C:  MOVWF  5B
099D:  MOVLW  30
099E:  MOVWF  5D
099F:  BCF    0A.3
09A0:  GOTO   356
09A1:  BSF    0A.3
09A2:  MOVF   22,W
09A3:  MOVWF  55
09A4:  MOVF   21,W
09A5:  MOVWF  54
....................       ELECthrottle = ELECthrottle+returnedValue; 
09A6:  MOVF   54,W
09A7:  ADDWF  4C,F
09A8:  MOVF   55,W
09A9:  BTFSC  03.0
09AA:  INCFSZ 55,W
09AB:  ADDWF  4D,F
....................       
....................       
....................       if (ELECthrottle>2500){ 
09AC:  BTFSC  4D.7
09AD:  GOTO   1BE
09AE:  MOVF   4D,W
09AF:  SUBLW  08
09B0:  BTFSC  03.0
09B1:  GOTO   1BE
09B2:  XORLW  FF
09B3:  BTFSS  03.2
09B4:  GOTO   1B9
09B5:  MOVF   4C,W
09B6:  SUBLW  C4
09B7:  BTFSC  03.0
09B8:  GOTO   1BE
....................          ELECthrottle=2500; 
09B9:  MOVLW  09
09BA:  MOVWF  4D
09BB:  MOVLW  C4
09BC:  MOVWF  4C
....................       } 
....................       else if (ELECthrottle<-200){ 
09BD:  GOTO   1CE
09BE:  BTFSS  4D.7
09BF:  GOTO   1CE
09C0:  MOVF   4D,W
09C1:  SUBLW  FF
09C2:  BTFSS  03.0
09C3:  GOTO   1CE
09C4:  BTFSS  03.2
09C5:  GOTO   1CA
09C6:  MOVF   4C,W
09C7:  SUBLW  37
09C8:  BTFSS  03.0
09C9:  GOTO   1CE
....................          ELECthrottle = -200; 
09CA:  MOVLW  FF
09CB:  MOVWF  4D
09CC:  MOVLW  38
09CD:  MOVWF  4C
....................       } 
....................        
....................        
....................       //SET OUTPUTS 
....................       if (CHARGING_STATE==EVERYTHING_OFF){ 
09CE:  MOVF   56,F
09CF:  BTFSC  03.2
....................           
....................       } 
....................       else if (CHARGING_STATE==SPEED_TO_LOW_ICE_DIRECT || CHARGING_STATE==INSUFFICIENT_BRAKING_RUNAWAY){ 
09D0:  GOTO   2A9
09D1:  DECFSZ 56,W
09D2:  GOTO   1D4
09D3:  GOTO   1D8
09D4:  MOVF   56,W
09D5:  SUBLW  05
09D6:  BTFSS  03.2
09D7:  GOTO   1EB
....................          current_servo_position =right_position-ELECthrottle; 
09D8:  MOVF   4C,W
09D9:  SUBLW  B4
09DA:  MOVWF  20
09DB:  MOVLW  14
09DC:  MOVWF  23
09DD:  MOVF   4D,W
09DE:  BTFSS  03.0
09DF:  INCFSZ 4D,W
09E0:  SUBWF  23,F
09E1:  MOVF   20,W
09E2:  MOVWF  42
09E3:  MOVF   23,W
09E4:  MOVWF  43
....................          write_dac(0); 
09E5:  CLRF   5C
09E6:  CLRF   5B
09E7:  BCF    0A.3
09E8:  CALL   1A7
09E9:  BSF    0A.3
....................       } 
....................       else{ 
09EA:  GOTO   2A9
....................       if (ELECthrottle<0){ 
09EB:  BTFSS  4D.7
09EC:  GOTO   23A
....................         if (CHARGING_STATE==CHARGING_ALLOWED || CHARGING_STATE ==CHARGING_AND_DISCHARING_ALLOWED){ 
09ED:  MOVF   56,W
09EE:  SUBLW  02
09EF:  BTFSC  03.2
09F0:  GOTO   1F5
09F1:  MOVF   56,W
09F2:  SUBLW  04
09F3:  BTFSS  03.2
09F4:  GOTO   234
....................              if (CURRENTLY_CHARGING==1){ 
09F5:  BTFSS  2F.5
09F6:  GOTO   1FA
....................                 trickBreaking(); 
09F7:  BCF    0A.3
09F8:  GOTO   75B
09F9:  BSF    0A.3
....................              } 
....................              //ELECthrottle = 300; 
....................              CURRENTLY_CHARGING=0; 
09FA:  BCF    2F.5
....................              output_high(brake_pin); 
09FB:  BSF    03.5
09FC:  BCF    06.4
09FD:  BCF    03.5
09FE:  BSF    06.4
....................              output_high(Electric_Controller_Switch); 
09FF:  BSF    03.5
0A00:  BCF    06.0
0A01:  BCF    03.5
0A02:  BSF    06.0
....................              printf("BREAKING \n"); 
0A03:  CLRF   57
0A04:  MOVF   57,W
0A05:  BCF    0A.3
0A06:  CALL   0CF
0A07:  BSF    0A.3
0A08:  INCF   57,F
0A09:  MOVWF  20
0A0A:  MOVWF  58
0A0B:  BCF    0A.3
0A0C:  CALL   305
0A0D:  BSF    0A.3
0A0E:  MOVLW  0A
0A0F:  SUBWF  57,W
0A10:  BTFSS  03.2
0A11:  GOTO   204
....................              write_dac((abs(ELECthrottle)+ELEC_CONTROLLER_OFFSET)); 
0A12:  MOVF   4D,W
0A13:  MOVWF  23
0A14:  MOVF   4C,W
0A15:  BTFSS  4D.7
0A16:  GOTO   220
0A17:  MOVF   4C,W
0A18:  SUBLW  00
0A19:  MOVWF  20
0A1A:  CLRF   23
0A1B:  MOVF   4D,W
0A1C:  BTFSS  03.0
0A1D:  INCFSZ 4D,W
0A1E:  SUBWF  23,F
0A1F:  MOVF   20,W
0A20:  MOVWF  57
0A21:  MOVF   23,W
0A22:  MOVWF  58
0A23:  MOVLW  84
0A24:  ADDWF  57,W
0A25:  MOVWF  59
0A26:  MOVF   58,W
0A27:  MOVWF  5A
0A28:  MOVLW  03
0A29:  BTFSC  03.0
0A2A:  MOVLW  04
0A2B:  ADDWF  5A,F
0A2C:  MOVF   5A,W
0A2D:  MOVWF  5C
0A2E:  MOVF   59,W
0A2F:  MOVWF  5B
0A30:  BCF    0A.3
0A31:  CALL   1A7
0A32:  BSF    0A.3
....................         } 
....................         else{ 
0A33:  GOTO   239
....................            //Decrease ICE throttle 
....................            write_dac(0); 
0A34:  CLRF   5C
0A35:  CLRF   5B
0A36:  BCF    0A.3
0A37:  CALL   1A7
0A38:  BSF    0A.3
....................        
....................         } 
....................       } 
....................       else { 
0A39:  GOTO   281
....................         if (CHARGING_STATE==DISCHARGING_ALLOWED || CHARGING_STATE ==CHARGING_AND_DISCHARING_ALLOWED){ 
0A3A:  MOVF   56,W
0A3B:  SUBLW  03
0A3C:  BTFSC  03.2
0A3D:  GOTO   242
0A3E:  MOVF   56,W
0A3F:  SUBLW  04
0A40:  BTFSS  03.2
0A41:  GOTO   27C
....................              CURRENTLY_CHARGING=1; 
0A42:  BSF    2F.5
....................              output_low(brake_pin); 
0A43:  BSF    03.5
0A44:  BCF    06.4
0A45:  BCF    03.5
0A46:  BCF    06.4
....................              output_low(Electric_Controller_Switch); 
0A47:  BSF    03.5
0A48:  BCF    06.0
0A49:  BCF    03.5
0A4A:  BCF    06.0
....................              printf("ACCELERATING \n"); 
0A4B:  CLRF   57
0A4C:  MOVF   57,W
0A4D:  BCF    0A.3
0A4E:  CALL   0DE
0A4F:  BSF    0A.3
0A50:  INCF   57,F
0A51:  MOVWF  20
0A52:  MOVWF  58
0A53:  BCF    0A.3
0A54:  CALL   305
0A55:  BSF    0A.3
0A56:  MOVLW  0E
0A57:  SUBWF  57,W
0A58:  BTFSS  03.2
0A59:  GOTO   24C
....................              write_dac((abs(ELECthrottle)+ELEC_CONTROLLER_OFFSET)); 
0A5A:  MOVF   4D,W
0A5B:  MOVWF  23
0A5C:  MOVF   4C,W
0A5D:  BTFSS  4D.7
0A5E:  GOTO   268
0A5F:  MOVF   4C,W
0A60:  SUBLW  00
0A61:  MOVWF  20
0A62:  CLRF   23
0A63:  MOVF   4D,W
0A64:  BTFSS  03.0
0A65:  INCFSZ 4D,W
0A66:  SUBWF  23,F
0A67:  MOVF   20,W
0A68:  MOVWF  57
0A69:  MOVF   23,W
0A6A:  MOVWF  58
0A6B:  MOVLW  84
0A6C:  ADDWF  57,W
0A6D:  MOVWF  59
0A6E:  MOVF   58,W
0A6F:  MOVWF  5A
0A70:  MOVLW  03
0A71:  BTFSC  03.0
0A72:  MOVLW  04
0A73:  ADDWF  5A,F
0A74:  MOVF   5A,W
0A75:  MOVWF  5C
0A76:  MOVF   59,W
0A77:  MOVWF  5B
0A78:  BCF    0A.3
0A79:  CALL   1A7
0A7A:  BSF    0A.3
....................         } 
....................         else{ 
0A7B:  GOTO   281
....................            //Increase ICE throttle 
....................            write_dac(0); 
0A7C:  CLRF   5C
0A7D:  CLRF   5B
0A7E:  BCF    0A.3
0A7F:  CALL   1A7
0A80:  BSF    0A.3
....................        
....................         } 
....................           
....................       } 
....................       if (ICE_ON){ 
0A81:  BTFSS  2F.4
0A82:  GOTO   296
....................          printf("ICE NORMAL"); 
0A83:  CLRF   57
0A84:  MOVF   57,W
0A85:  BCF    0A.3
0A86:  CALL   0F1
0A87:  BSF    0A.3
0A88:  INCF   57,F
0A89:  MOVWF  20
0A8A:  MOVWF  58
0A8B:  BCF    0A.3
0A8C:  CALL   305
0A8D:  BSF    0A.3
0A8E:  MOVLW  0A
0A8F:  SUBWF  57,W
0A90:  BTFSS  03.2
0A91:  GOTO   284
....................          current_servo_position =right_position-servo_difference_div; 
0A92:  CLRF   43
0A93:  MOVLW  C8
0A94:  MOVWF  42
....................       } 
....................       else{ 
0A95:  GOTO   2A9
....................          current_servo_position =right_position; 
0A96:  MOVLW  14
0A97:  MOVWF  43
0A98:  MOVLW  B4
0A99:  MOVWF  42
....................          printf("ICE OFF"); 
0A9A:  CLRF   57
0A9B:  MOVF   57,W
0A9C:  BCF    0A.3
0A9D:  CALL   100
0A9E:  BSF    0A.3
0A9F:  INCF   57,F
0AA0:  MOVWF  20
0AA1:  MOVWF  58
0AA2:  BCF    0A.3
0AA3:  CALL   305
0AA4:  BSF    0A.3
0AA5:  MOVLW  07
0AA6:  SUBWF  57,W
0AA7:  BTFSS  03.2
0AA8:  GOTO   29B
....................       } 
....................       } 
....................       
....................    } 
0AA9:  GOTO   094
....................     
....................  
.................... } 
....................  
.................... boolean checkRunnaway(struct PID_DATA *pid) 
.................... { 
0AAA:  GOTO   2AA
.................... return (pid->sumError > INSUFFICIENT_BRAKING_RUNNAWAY_ERROR); 
*
032F:  MOVLW  02
0330:  ADDWF  57,W
0331:  MOVWF  04
0332:  MOVF   00,W
0333:  MOVWF  58
0334:  INCF   04,F
0335:  MOVF   00,W
0336:  MOVWF  59
0337:  INCF   04,F
0338:  MOVF   00,W
0339:  MOVWF  5A
033A:  INCF   04,F
033B:  MOVF   00,W
033C:  MOVWF  5B
033D:  MOVLW  FD
033E:  ADDWF  04,F
033F:  MOVF   5B,F
0340:  BTFSS  03.2
0341:  GOTO   352
0342:  MOVF   5A,F
0343:  BTFSS  03.2
0344:  GOTO   352
0345:  MOVF   59,W
0346:  SUBLW  26
0347:  BTFSC  03.0
0348:  GOTO   350
0349:  XORLW  FF
034A:  BTFSS  03.2
034B:  GOTO   352
034C:  MOVF   58,W
034D:  SUBLW  10
034E:  BTFSS  03.0
034F:  GOTO   352
0350:  MOVLW  00
0351:  GOTO   353
0352:  MOVLW  01
0353:  MOVWF  21
.................... } 
0354:  BSF    0A.3
0355:  GOTO   112 (RETURN)
....................  
.................... /*! \brief Initialisation of PID controller parameters. 
....................  * 
....................  *  Initialise the variables used by the PID algorithm. 
....................  * 
....................  *  \param p_factor  Proportional term. 
....................  *  \param i_factor  Integral term. 
....................  *  \param d_factor  Derivate term. 
....................  *  \param pid  Struct with PID status. 
....................  */ 
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid) 
.................... // Set up PID controller parameters 
.................... { 
....................   // Start values for PID controller 
....................   pid->sumError = 0; 
*
0203:  MOVLW  02
0204:  ADDWF  5D,W
0205:  MOVWF  04
0206:  INCF   04,F
0207:  INCF   04,F
0208:  INCF   04,F
0209:  CLRF   00
020A:  DECF   04,F
020B:  CLRF   00
020C:  DECF   04,F
020D:  CLRF   00
020E:  DECF   04,F
020F:  CLRF   00
....................   pid->lastProcessValue = 0; 
0210:  MOVF   5D,W
0211:  MOVWF  04
0212:  INCF   04,F
0213:  CLRF   00
0214:  DECF   04,F
0215:  CLRF   00
....................   // Tuning constants for PID loop 
....................   pid->P_Factor = p_factor; 
0216:  MOVLW  06
0217:  ADDWF  5D,W
0218:  MOVWF  04
0219:  INCF   04,F
021A:  MOVF   58,W
021B:  MOVWF  00
021C:  DECF   04,F
021D:  MOVF   57,W
021E:  MOVWF  00
....................   pid->I_Factor = i_factor; 
021F:  MOVLW  08
0220:  ADDWF  5D,W
0221:  MOVWF  04
0222:  INCF   04,F
0223:  MOVF   5A,W
0224:  MOVWF  00
0225:  DECF   04,F
0226:  MOVF   59,W
0227:  MOVWF  00
....................   pid->D_Factor = d_factor; 
0228:  MOVLW  0A
0229:  ADDWF  5D,W
022A:  MOVWF  04
022B:  INCF   04,F
022C:  MOVF   5C,W
022D:  MOVWF  00
022E:  DECF   04,F
022F:  MOVF   5B,W
0230:  MOVWF  00
....................   // Limits to avoid overflow 
....................   pid->maxError = MAX_INT / (pid->P_Factor + 1); 
0231:  MOVLW  0C
0232:  ADDWF  5D,W
0233:  MOVWF  5E
0234:  MOVLW  06
0235:  ADDWF  5D,W
0236:  MOVWF  04
0237:  INCF   04,F
0238:  MOVF   00,W
0239:  MOVWF  60
023A:  DECF   04,F
023B:  MOVF   00,W
023C:  MOVWF  5F
023D:  MOVLW  01
023E:  ADDWF  5F,W
023F:  MOVWF  21
0240:  MOVF   60,W
0241:  MOVWF  23
0242:  BTFSC  03.0
0243:  INCF   23,F
0244:  MOVF   21,W
0245:  MOVWF  61
0246:  MOVF   23,W
0247:  MOVWF  62
0248:  MOVLW  7F
0249:  MOVWF  64
024A:  MOVLW  FF
024B:  MOVWF  63
024C:  MOVF   62,W
024D:  MOVWF  66
024E:  MOVF   61,W
024F:  MOVWF  65
*
0274:  MOVF   5E,W
0275:  MOVWF  04
0276:  INCF   04,F
0277:  MOVF   22,W
0278:  MOVWF  00
0279:  DECF   04,F
027A:  MOVF   21,W
027B:  MOVWF  00
....................   //printf("Max %ld factor %ld and pid %ld",MAX_INT,pid->I_Factor,pid->maxError); 
....................   pid->maxSumError = MAX_I_TERM / (pid->I_Factor + 1); 
027C:  MOVLW  0E
027D:  ADDWF  5D,W
027E:  MOVWF  5E
027F:  MOVLW  08
0280:  ADDWF  5D,W
0281:  MOVWF  04
0282:  INCF   04,F
0283:  MOVF   00,W
0284:  MOVWF  60
0285:  DECF   04,F
0286:  MOVF   00,W
0287:  MOVWF  5F
0288:  MOVLW  01
0289:  ADDWF  5F,W
028A:  MOVWF  21
028B:  MOVF   60,W
028C:  MOVWF  23
028D:  BTFSC  03.0
028E:  INCF   23,F
028F:  MOVF   21,W
0290:  MOVWF  61
0291:  MOVF   23,W
0292:  MOVWF  62
0293:  MOVF   04,W
0294:  MOVWF  63
0295:  MOVLW  3F
0296:  MOVWF  67
0297:  MOVLW  FF
0298:  MOVWF  66
0299:  MOVWF  65
029A:  MOVWF  64
029B:  CLRF   6B
029C:  CLRF   6A
029D:  MOVF   62,W
029E:  MOVWF  69
029F:  MOVF   61,W
02A0:  MOVWF  68
*
02E1:  MOVF   63,W
02E2:  MOVWF  04
02E3:  MOVF   5E,W
02E4:  MOVWF  04
02E5:  MOVF   20,W
02E6:  MOVWF  00
02E7:  INCF   04,F
02E8:  MOVF   21,W
02E9:  MOVWF  00
02EA:  INCF   04,F
02EB:  MOVF   22,W
02EC:  MOVWF  00
02ED:  INCF   04,F
02EE:  MOVF   23,W
02EF:  MOVWF  00
.................... } 
02F0:  BSF    0A.3
02F1:  GOTO   08A (RETURN)
....................  
....................  
.................... /*! \brief PID control algorithm. 
....................  * 
....................  *  Calculates output from setpoint, process value and PID status. 
....................  * 
....................  *  \param setPoint  Desired value. 
....................  *  \param processValue  Measured value. 
....................  *  \param pid_st  PID status struct. 
....................  */ 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st) 
.................... { 
....................   signed int16 error, p_term, d_term; 
....................   signed int32 i_term, ret, temp; 
....................     processValue=processValue/4; 
*
0356:  RRF    5C,F
0357:  RRF    5B,F
0358:  RRF    5C,F
0359:  RRF    5B,F
035A:  MOVLW  3F
035B:  ANDWF  5C,F
....................   //printf("input %ld speed %ld ",setPoint,processValue); 
....................   error = setPoint - processValue; 
035C:  MOVF   5B,W
035D:  SUBWF  59,W
035E:  MOVWF  20
035F:  MOVF   5A,W
0360:  MOVWF  23
0361:  MOVF   5C,W
0362:  BTFSS  03.0
0363:  INCFSZ 5C,W
0364:  SUBWF  23,F
0365:  MOVF   20,W
0366:  MOVWF  5E
0367:  MOVF   23,W
0368:  MOVWF  5F
....................    
....................   // Calculate Pterm and limit error overflow 
....................    
....................   if (error > (signed int16) pid_st->maxError){ 
0369:  MOVLW  0C
036A:  ADDWF  5D,W
036B:  MOVWF  04
036C:  INCF   04,F
036D:  MOVF   00,W
036E:  MOVWF  23
036F:  DECF   04,F
0370:  MOVF   00,W
0371:  MOVWF  21
0372:  BTFSS  23.7
0373:  GOTO   377
0374:  BTFSS  5F.7
0375:  GOTO   383
0376:  GOTO   379
0377:  BTFSC  5F.7
0378:  GOTO   388
0379:  MOVF   23,W
037A:  SUBWF  5F,W
037B:  BTFSS  03.0
037C:  GOTO   388
037D:  BTFSS  03.2
037E:  GOTO   383
037F:  MOVF   5E,W
0380:  SUBWF  21,W
0381:  BTFSC  03.0
0382:  GOTO   388
....................     p_term = MAX_INT; 
0383:  MOVLW  7F
0384:  MOVWF  61
0385:  MOVLW  FF
0386:  MOVWF  60
....................     //printf("p greater error %ld a %ld p %ld",error,pid_st->maxError,p_term); 
....................  
....................   } 
....................   else if (error < (signed int16) -pid_st->maxError){ 
0387:  GOTO   4E8
0388:  MOVLW  0C
0389:  ADDWF  5D,W
038A:  MOVWF  04
038B:  INCF   04,F
038C:  MOVF   00,W
038D:  MOVWF  23
038E:  DECF   04,F
038F:  MOVF   00,W
0390:  SUBLW  00
0391:  MOVWF  20
0392:  MOVF   23,W
0393:  BTFSS  03.0
0394:  INCFSZ 23,W
0395:  GOTO   398
0396:  MOVLW  00
0397:  GOTO   399
0398:  SUBLW  00
0399:  MOVWF  23
039A:  MOVF   20,W
039B:  MOVWF  21
039C:  BTFSS  5F.7
039D:  GOTO   3A1
039E:  BTFSS  23.7
039F:  GOTO   3AD
03A0:  GOTO   3A3
03A1:  BTFSC  23.7
03A2:  GOTO   3B2
03A3:  MOVF   5F,W
03A4:  SUBWF  23,W
03A5:  BTFSS  03.0
03A6:  GOTO   3B2
03A7:  BTFSS  03.2
03A8:  GOTO   3AD
03A9:  MOVF   21,W
03AA:  SUBWF  5E,W
03AB:  BTFSC  03.0
03AC:  GOTO   3B2
....................     p_term = -MAX_INT; 
03AD:  MOVLW  80
03AE:  MOVWF  61
03AF:  MOVLW  01
03B0:  MOVWF  60
....................     //printf("p less error %ld a %ld p %ld",error,-pid_st->maxError,p_term); 
....................  
....................   } 
....................   else{ 
03B1:  GOTO   4E8
....................     p_term = (signed int16) (pid_st->P_Factor * (float) error); 
03B2:  MOVLW  06
03B3:  ADDWF  5D,W
03B4:  MOVWF  04
03B5:  INCF   04,F
03B6:  MOVF   00,W
03B7:  MOVWF  71
03B8:  DECF   04,F
03B9:  MOVF   00,W
03BA:  MOVWF  70
03BB:  MOVF   5F,W
03BC:  MOVWF  73
03BD:  MOVF   5E,W
03BE:  MOVWF  72
*
03E3:  MOVF   20,W
03E4:  MOVWF  72
03E5:  MOVF   21,W
03E6:  MOVWF  73
03E7:  MOVF   22,W
03E8:  MOVWF  74
03E9:  MOVF   23,W
03EA:  MOVWF  75
03EB:  MOVF   71,W
03EC:  MOVWF  77
03ED:  MOVF   70,W
03EE:  MOVWF  76
*
040B:  MOVF   23,W
040C:  MOVWF  79
040D:  MOVF   22,W
040E:  MOVWF  78
040F:  MOVF   21,W
0410:  MOVWF  77
0411:  MOVF   20,W
0412:  MOVWF  76
0413:  MOVF   75,W
0414:  MOVWF  7D
0415:  MOVF   74,W
0416:  MOVWF  7C
0417:  MOVF   73,W
0418:  MOVWF  7B
0419:  MOVF   72,W
041A:  MOVWF  7A
*
04BE:  MOVF   23,W
04BF:  MOVWF  79
04C0:  MOVF   22,W
04C1:  MOVWF  78
04C2:  MOVF   21,W
04C3:  MOVWF  77
04C4:  MOVF   20,W
04C5:  MOVWF  76
*
04E4:  MOVF   22,W
04E5:  MOVWF  61
04E6:  MOVF   21,W
04E7:  MOVWF  60
....................     //printf("error %ld a %ld p %ld",error,pid_st->maxError,p_term); 
....................   } 
....................    
....................   // Calculate Iterm and limit integral runaway 
....................   temp = pid_st->sumError + error; 
04E8:  MOVLW  02
04E9:  ADDWF  5D,W
04EA:  MOVWF  04
04EB:  MOVF   00,W
04EC:  MOVWF  70
04ED:  INCF   04,F
04EE:  MOVF   00,W
04EF:  MOVWF  71
04F0:  INCF   04,F
04F1:  MOVF   00,W
04F2:  MOVWF  72
04F3:  INCF   04,F
04F4:  MOVF   00,W
04F5:  MOVWF  73
04F6:  MOVF   5E,W
04F7:  MOVWF  20
04F8:  MOVF   5F,W
04F9:  MOVWF  21
04FA:  CLRF   22
04FB:  CLRF   23
04FC:  BTFSS  5F.7
04FD:  GOTO   500
04FE:  DECF   22,F
04FF:  DECF   23,F
0500:  MOVF   20,W
0501:  ADDWF  70,W
0502:  MOVWF  6C
0503:  MOVF   71,W
0504:  MOVWF  6D
0505:  MOVF   21,W
0506:  BTFSC  03.0
0507:  INCFSZ 21,W
0508:  ADDWF  6D,F
0509:  MOVF   72,W
050A:  MOVWF  6E
050B:  MOVF   22,W
050C:  BTFSC  03.0
050D:  INCFSZ 22,W
050E:  ADDWF  6E,F
050F:  MOVF   73,W
0510:  MOVWF  6F
0511:  MOVF   23,W
0512:  BTFSC  03.0
0513:  INCFSZ 23,W
0514:  ADDWF  6F,F
....................   if(temp > (signed int32)pid_st->maxSumError){ 
0515:  MOVLW  0E
0516:  ADDWF  5D,W
0517:  MOVWF  04
0518:  MOVF   00,W
0519:  MOVWF  20
051A:  INCF   04,F
051B:  MOVF   00,W
051C:  MOVWF  21
051D:  INCF   04,F
051E:  MOVF   00,W
051F:  MOVWF  22
0520:  INCF   04,F
0521:  MOVF   00,W
0522:  MOVWF  23
0523:  BTFSS  23.7
0524:  GOTO   528
0525:  BTFSS  6F.7
0526:  GOTO   540
0527:  GOTO   52A
0528:  BTFSC  6F.7
0529:  GOTO   565
052A:  MOVF   23,W
052B:  SUBWF  6F,W
052C:  BTFSS  03.0
052D:  GOTO   565
052E:  BTFSS  03.2
052F:  GOTO   540
0530:  MOVF   22,W
0531:  SUBWF  6E,W
0532:  BTFSS  03.0
0533:  GOTO   565
0534:  BTFSS  03.2
0535:  GOTO   540
0536:  MOVF   21,W
0537:  SUBWF  6D,W
0538:  BTFSS  03.0
0539:  GOTO   565
053A:  BTFSS  03.2
053B:  GOTO   540
053C:  MOVF   6C,W
053D:  SUBWF  20,W
053E:  BTFSC  03.0
053F:  GOTO   565
....................     i_term = MAX_I_TERM; 
0540:  MOVLW  3F
0541:  MOVWF  67
0542:  MOVLW  FF
0543:  MOVWF  66
0544:  MOVWF  65
0545:  MOVWF  64
....................     pid_st->sumError = pid_st->maxSumError; 
0546:  MOVLW  02
0547:  ADDWF  5D,W
0548:  MOVWF  70
0549:  MOVLW  0E
054A:  ADDWF  5D,W
054B:  MOVWF  04
054C:  MOVF   00,W
054D:  MOVWF  20
054E:  INCF   04,F
054F:  MOVF   00,W
0550:  MOVWF  21
0551:  INCF   04,F
0552:  MOVF   00,W
0553:  MOVWF  22
0554:  INCF   04,F
0555:  MOVF   00,W
0556:  MOVWF  23
0557:  MOVF   70,W
0558:  MOVWF  04
0559:  MOVF   20,W
055A:  MOVWF  00
055B:  INCF   04,F
055C:  MOVF   21,W
055D:  MOVWF  00
055E:  INCF   04,F
055F:  MOVF   22,W
0560:  MOVWF  00
0561:  INCF   04,F
0562:  MOVF   23,W
0563:  MOVWF  00
....................     //printf("\n greater temp %ld a %ld sum %ld",temp,pid_st->maxSumError,pid_st->sumError); 
....................  
....................  } 
....................   else if(temp < (signed int32)-pid_st->maxSumError){ 
0564:  GOTO   673
0565:  MOVLW  0E
0566:  ADDWF  5D,W
0567:  MOVWF  04
0568:  MOVF   00,W
0569:  MOVWF  20
056A:  INCF   04,F
056B:  MOVF   00,W
056C:  MOVWF  21
056D:  INCF   04,F
056E:  MOVF   00,W
056F:  MOVWF  22
0570:  INCF   04,F
0571:  MOVF   00,W
0572:  MOVWF  23
0573:  MOVLW  FD
0574:  ADDWF  04,F
0575:  MOVF   20,W
0576:  SUBLW  00
0577:  MOVWF  20
0578:  MOVF   21,W
0579:  BTFSS  03.0
057A:  INCFSZ 21,W
057B:  GOTO   57E
057C:  MOVLW  00
057D:  GOTO   57F
057E:  SUBLW  00
057F:  MOVWF  21
0580:  MOVF   22,W
0581:  BTFSS  03.0
0582:  INCFSZ 22,W
0583:  GOTO   586
0584:  MOVLW  00
0585:  GOTO   587
0586:  SUBLW  00
0587:  MOVWF  22
0588:  MOVF   23,W
0589:  BTFSS  03.0
058A:  INCFSZ 23,W
058B:  GOTO   58E
058C:  MOVLW  00
058D:  GOTO   58F
058E:  SUBLW  00
058F:  MOVWF  23
0590:  BTFSS  6F.7
0591:  GOTO   595
0592:  BTFSS  23.7
0593:  GOTO   5AD
0594:  GOTO   597
0595:  BTFSC  23.7
0596:  GOTO   5F0
0597:  MOVF   6F,W
0598:  SUBWF  23,W
0599:  BTFSS  03.0
059A:  GOTO   5F0
059B:  BTFSS  03.2
059C:  GOTO   5AD
059D:  MOVF   6E,W
059E:  SUBWF  22,W
059F:  BTFSS  03.0
05A0:  GOTO   5F0
05A1:  BTFSS  03.2
05A2:  GOTO   5AD
05A3:  MOVF   6D,W
05A4:  SUBWF  21,W
05A5:  BTFSS  03.0
05A6:  GOTO   5F0
05A7:  BTFSS  03.2
05A8:  GOTO   5AD
05A9:  MOVF   20,W
05AA:  SUBWF  6C,W
05AB:  BTFSC  03.0
05AC:  GOTO   5F0
....................     i_term = -MAX_I_TERM; 
05AD:  MOVLW  C0
05AE:  MOVWF  67
05AF:  CLRF   66
05B0:  CLRF   65
05B1:  MOVLW  01
05B2:  MOVWF  64
....................     pid_st->sumError = -pid_st->maxSumError; 
05B3:  MOVLW  02
05B4:  ADDWF  5D,W
05B5:  MOVWF  70
05B6:  MOVLW  0E
05B7:  ADDWF  5D,W
05B8:  MOVWF  04
05B9:  MOVF   00,W
05BA:  MOVWF  20
05BB:  INCF   04,F
05BC:  MOVF   00,W
05BD:  MOVWF  21
05BE:  INCF   04,F
05BF:  MOVF   00,W
05C0:  MOVWF  22
05C1:  INCF   04,F
05C2:  MOVF   00,W
05C3:  MOVWF  23
05C4:  MOVLW  FD
05C5:  ADDWF  04,F
05C6:  MOVF   20,W
05C7:  SUBLW  00
05C8:  MOVWF  20
05C9:  MOVF   21,W
05CA:  BTFSS  03.0
05CB:  INCFSZ 21,W
05CC:  GOTO   5CF
05CD:  MOVLW  00
05CE:  GOTO   5D0
05CF:  SUBLW  00
05D0:  MOVWF  21
05D1:  MOVF   22,W
05D2:  BTFSS  03.0
05D3:  INCFSZ 22,W
05D4:  GOTO   5D7
05D5:  MOVLW  00
05D6:  GOTO   5D8
05D7:  SUBLW  00
05D8:  MOVWF  22
05D9:  MOVF   23,W
05DA:  BTFSS  03.0
05DB:  INCFSZ 23,W
05DC:  GOTO   5DF
05DD:  MOVLW  00
05DE:  GOTO   5E0
05DF:  SUBLW  00
05E0:  MOVWF  23
05E1:  MOVWF  74
05E2:  MOVF   70,W
05E3:  MOVWF  04
05E4:  MOVF   20,W
05E5:  MOVWF  00
05E6:  INCF   04,F
05E7:  MOVF   21,W
05E8:  MOVWF  00
05E9:  INCF   04,F
05EA:  MOVF   22,W
05EB:  MOVWF  00
05EC:  INCF   04,F
05ED:  MOVF   74,W
05EE:  MOVWF  00
....................     //printf("\n less temp %ld a %ld sum %ld",temp,pid_st->maxSumError,pid_st->sumError); 
....................  
....................   } 
....................   else{ 
05EF:  GOTO   673
....................     pid_st->sumError = temp; 
05F0:  MOVLW  02
05F1:  ADDWF  5D,W
05F2:  MOVWF  04
05F3:  MOVF   6C,W
05F4:  MOVWF  00
05F5:  INCF   04,F
05F6:  MOVF   6D,W
05F7:  MOVWF  00
05F8:  INCF   04,F
05F9:  MOVF   6E,W
05FA:  MOVWF  00
05FB:  INCF   04,F
05FC:  MOVF   6F,W
05FD:  MOVWF  00
....................     i_term = pid_st->I_Factor * pid_st->sumError; 
05FE:  MOVLW  08
05FF:  ADDWF  5D,W
0600:  MOVWF  04
0601:  INCF   04,F
0602:  MOVF   00,W
0603:  MOVWF  71
0604:  DECF   04,F
0605:  MOVF   00,W
0606:  MOVWF  70
0607:  MOVLW  02
0608:  ADDWF  5D,W
0609:  MOVWF  04
060A:  MOVF   00,W
060B:  MOVWF  20
060C:  INCF   04,F
060D:  MOVF   00,W
060E:  MOVWF  21
060F:  INCF   04,F
0610:  MOVF   00,W
0611:  MOVWF  22
0612:  INCF   04,F
0613:  MOVF   00,W
0614:  MOVWF  23
0615:  MOVLW  FD
0616:  ADDWF  04,F
0617:  MOVF   23,W
0618:  MOVWF  75
0619:  MOVF   22,W
061A:  MOVWF  74
061B:  MOVF   21,W
061C:  MOVWF  73
061D:  MOVF   20,W
061E:  MOVWF  72
061F:  MOVF   04,W
0620:  MOVWF  76
0621:  CLRF   7A
0622:  CLRF   79
0623:  MOVF   71,W
0624:  MOVWF  78
0625:  MOVF   70,W
0626:  MOVWF  77
0627:  MOVF   75,W
0628:  BSF    03.5
0629:  MOVWF  23
062A:  BCF    03.5
062B:  MOVF   74,W
062C:  BSF    03.5
062D:  MOVWF  22
062E:  BCF    03.5
062F:  MOVF   73,W
0630:  BSF    03.5
0631:  MOVWF  21
0632:  BCF    03.5
0633:  MOVF   72,W
0634:  BSF    03.5
0635:  MOVWF  20
*
0668:  BCF    03.5
0669:  MOVF   76,W
066A:  MOVWF  04
066B:  MOVF   23,W
066C:  MOVWF  67
066D:  MOVF   22,W
066E:  MOVWF  66
066F:  MOVF   21,W
0670:  MOVWF  65
0671:  MOVF   20,W
0672:  MOVWF  64
....................     //printf("\n eror temp %ld i_term %ld sum %ld error %ld ",temp,i_term,pid_st->sumError,error); 
....................  
....................   } 
....................  
....................   // Calculate Dterm 
....................   d_term = pid_st->D_Factor * (pid_st->lastProcessValue - processValue); 
0673:  MOVLW  0A
0674:  ADDWF  5D,W
0675:  MOVWF  04
0676:  INCF   04,F
0677:  MOVF   00,W
0678:  MOVWF  71
0679:  DECF   04,F
067A:  MOVF   00,W
067B:  MOVWF  70
067C:  MOVF   5D,W
067D:  MOVWF  04
067E:  INCF   04,F
067F:  MOVF   00,W
0680:  MOVWF  73
0681:  DECF   04,F
0682:  MOVF   00,W
0683:  MOVWF  72
0684:  MOVF   5B,W
0685:  SUBWF  72,W
0686:  MOVWF  20
0687:  MOVF   73,W
0688:  MOVWF  23
0689:  MOVF   5C,W
068A:  BTFSS  03.0
068B:  INCFSZ 5C,W
068C:  SUBWF  23,F
068D:  MOVF   20,W
068E:  MOVWF  74
068F:  MOVF   23,W
0690:  MOVWF  75
0691:  MOVF   71,W
0692:  MOVWF  77
0693:  MOVF   70,W
0694:  MOVWF  76
0695:  MOVF   75,W
0696:  MOVWF  79
0697:  MOVF   74,W
0698:  MOVWF  78
*
06AD:  MOVF   21,W
06AE:  MOVWF  62
06AF:  MOVF   22,W
06B0:  MOVWF  63
.................... //printf("\n p_term %ld d_term %ld i_term %ld",p_term,d_term,i_term); 
....................   pid_st->lastProcessValue = processValue; 
06B1:  MOVF   5D,W
06B2:  MOVWF  04
06B3:  INCF   04,F
06B4:  MOVF   5C,W
06B5:  MOVWF  00
06B6:  DECF   04,F
06B7:  MOVF   5B,W
06B8:  MOVWF  00
....................  
....................   //ret = (p_term + i_term + d_term) / SCALING_FACTOR; 
....................    ret = (p_term+d_term+(signed int16)i_term) / SCALING_FACTOR; 
06B9:  MOVF   62,W
06BA:  ADDWF  60,W
06BB:  MOVWF  70
06BC:  MOVF   61,W
06BD:  MOVWF  71
06BE:  MOVF   63,W
06BF:  BTFSC  03.0
06C0:  INCFSZ 63,W
06C1:  ADDWF  71,F
06C2:  MOVF   64,W
06C3:  ADDWF  70,W
06C4:  MOVWF  72
06C5:  MOVF   71,W
06C6:  MOVWF  73
06C7:  MOVF   65,W
06C8:  BTFSC  03.0
06C9:  INCFSZ 65,W
06CA:  ADDWF  73,F
06CB:  MOVF   73,W
06CC:  MOVWF  75
06CD:  MOVF   72,W
06CE:  MOVWF  74
06CF:  CLRF   77
06D0:  MOVLW  80
06D1:  MOVWF  76
*
070F:  MOVF   22,W
0710:  MOVWF  23
0711:  MOVF   21,W
0712:  MOVWF  20
0713:  MOVF   22,W
0714:  MOVWF  21
0715:  CLRF   22
0716:  CLRF   23
0717:  BTFSS  21.7
0718:  GOTO   71B
0719:  DECF   22,F
071A:  DECF   23,F
071B:  MOVF   23,W
071C:  MOVWF  6B
071D:  MOVF   22,W
071E:  MOVWF  6A
071F:  MOVF   21,W
0720:  MOVWF  69
0721:  MOVF   20,W
0722:  MOVWF  68
....................   if(ret > MAX_INT){ 
0723:  BTFSC  6B.7
0724:  GOTO   736
0725:  MOVF   6B,F
0726:  BTFSS  03.2
0727:  GOTO   72F
0728:  MOVF   6A,F
0729:  BTFSS  03.2
072A:  GOTO   72F
072B:  MOVF   69,W
072C:  SUBLW  7F
072D:  BTFSC  03.0
072E:  GOTO   736
....................     ret = MAX_INT; 
072F:  CLRF   6B
0730:  CLRF   6A
0731:  MOVLW  7F
0732:  MOVWF  69
0733:  MOVLW  FF
0734:  MOVWF  68
....................   } 
....................   else if(ret < -MAX_INT){ 
0735:  GOTO   755
0736:  BTFSS  6B.7
0737:  GOTO   755
0738:  MOVF   6B,W
0739:  SUBLW  FF
073A:  BTFSS  03.0
073B:  GOTO   755
073C:  BTFSS  03.2
073D:  GOTO   74E
073E:  MOVF   6A,W
073F:  SUBLW  FF
0740:  BTFSS  03.0
0741:  GOTO   755
0742:  BTFSS  03.2
0743:  GOTO   74E
0744:  MOVF   69,W
0745:  SUBLW  80
0746:  BTFSS  03.0
0747:  GOTO   755
0748:  BTFSS  03.2
0749:  GOTO   74E
074A:  MOVF   68,W
074B:  SUBLW  00
074C:  BTFSS  03.0
074D:  GOTO   755
....................     ret = -MAX_INT; 
074E:  MOVLW  FF
074F:  MOVWF  6B
0750:  MOVWF  6A
0751:  MOVLW  80
0752:  MOVWF  69
0753:  MOVLW  01
0754:  MOVWF  68
....................   } 
....................  
....................   return((signed int16)ret); 
0755:  MOVF   68,W
0756:  MOVWF  21
0757:  MOVF   69,W
0758:  MOVWF  22
.................... } 
0759:  BSF    0A.3
075A:  GOTO   1A1 (RETURN)
....................  
.................... /*! \brief Resets the integrator. 
....................  * 
....................  *  Calling this function will reset the integrator in the PID regulator. 
....................  */ 
.................... void pid_Reset_Integrator(pidData_t *pid_st) 
.................... { 
....................   pid_st->sumError = 0; 
.................... } 
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 373A   HS NOWDT NOPUT DEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
