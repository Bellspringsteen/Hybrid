CCS PCM C Compiler, Version 4.084, 46530               05-Jan-13 15:37

               Filename: HondaHybrid.lst

               ROM used: 1009 words (26%)
                         Largest free fragment is 1788
               RAM used: 56 (31%) at main() level
                         70 (39%) worst case
               Stack:    2 worst case (1 in main + 1 for interrupts)

*
0000:  NOP
0001:  MOVLW  00
0002:  MOVWF  0A
0003:  GOTO   2D9
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  26
0008:  MOVF   7F,W
0009:  MOVWF  25
000A:  MOVF   0A,W
000B:  MOVWF  2D
000C:  CLRF   0A
000D:  SWAPF  25,F
000E:  MOVF   04,W
000F:  MOVWF  27
0010:  MOVF   20,W
0011:  MOVWF  28
0012:  MOVF   21,W
0013:  MOVWF  29
0014:  MOVF   22,W
0015:  MOVWF  2A
0016:  MOVF   23,W
0017:  MOVWF  2B
0018:  MOVF   24,W
0019:  MOVWF  2C
001A:  BCF    03.7
001B:  BCF    03.5
001C:  MOVLW  8C
001D:  MOVWF  04
001E:  BTFSS  00.0
001F:  GOTO   022
0020:  BTFSC  0C.0
0021:  GOTO   03F
0022:  MOVLW  8D
0023:  MOVWF  04
0024:  BTFSS  00.0
0025:  GOTO   028
0026:  BTFSC  0D.0
0027:  GOTO   041
0028:  BTFSS  0B.5
0029:  GOTO   02C
002A:  BTFSC  0B.2
002B:  GOTO   043
002C:  MOVF   27,W
002D:  MOVWF  04
002E:  MOVF   28,W
002F:  MOVWF  20
0030:  MOVF   29,W
0031:  MOVWF  21
0032:  MOVF   2A,W
0033:  MOVWF  22
0034:  MOVF   2B,W
0035:  MOVWF  23
0036:  MOVF   2C,W
0037:  MOVWF  24
0038:  MOVF   2D,W
0039:  MOVWF  0A
003A:  SWAPF  26,W
003B:  MOVWF  03
003C:  SWAPF  7F,F
003D:  SWAPF  7F,W
003E:  RETFIE
003F:  BCF    0A.3
0040:  GOTO   051
0041:  BCF    0A.3
0042:  GOTO   054
0043:  BCF    0A.3
0044:  GOTO   045
.................... #include "HondaHybrid.h" 
.................... #include <16F873A.h> 
.................... //////// Standard Header file for the PIC16F873A device //////////////// 
.................... #device PIC16F873A 
.................... #list 
....................  
....................  
.................... //#include <16F737.h> 
.................... #device ICD=TRUE 
.................... #device adc=10 
.................... //#device adc=8 
.................... #use delay(clock=20000000) 
*
00D3:  MOVLW  54
00D4:  MOVWF  04
00D5:  MOVF   00,W
00D6:  BTFSC  03.2
00D7:  GOTO   0E5
00D8:  MOVLW  06
00D9:  MOVWF  21
00DA:  CLRF   20
00DB:  DECFSZ 20,F
00DC:  GOTO   0DB
00DD:  DECFSZ 21,F
00DE:  GOTO   0DA
00DF:  MOVLW  7B
00E0:  MOVWF  20
00E1:  DECFSZ 20,F
00E2:  GOTO   0E1
00E3:  DECFSZ 00,F
00E4:  GOTO   0D8
00E5:  RETLW  00
.................... #fuses HS,PUT,NOWDT 
.................... #use rs232 (DEBUGGER) 
.................... #include <mcp4921.c> 
.................... //////////////// Driver for MCP4921 D/A Converter /////////////////////// 
.................... ////                                                                 //// 
.................... ////  init_dac()    Call this before using a MCP4921 DAC             //// 
.................... ////                                                                 //// 
.................... ////  write_dac( long int )   Writes command and 12 bit resolution   //// 
.................... ////                          to the MCP4921 which converts it to a  //// 
.................... ////                          voltage                                //// 
.................... ////                          0-4095 input represents 0-vref V out.  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SELECT 
....................  
.................... #define DAC_CS     PIN_C4 
.................... #define DAC_CLK    PIN_C3 
.................... #define DAC_DI     PIN_C5 
.................... #define DAC_LDAC   PIN_B5 
....................  
.................... #endif 
....................  
.................... void init_dac() 
.................... { 
....................    output_high(DAC_CS); 
*
005F:  BCF    2E.4
0060:  MOVF   2E,W
0061:  BSF    03.5
0062:  MOVWF  07
0063:  BCF    03.5
0064:  BSF    07.4
....................    output_high(DAC_LDAC); 
0065:  BSF    03.5
0066:  BCF    06.5
0067:  BCF    03.5
0068:  BSF    06.5
....................    output_high(DAC_CLK); 
0069:  BCF    2E.3
006A:  MOVF   2E,W
006B:  BSF    03.5
006C:  MOVWF  07
006D:  BCF    03.5
006E:  BSF    07.3
....................    output_high(DAC_DI); 
006F:  BCF    2E.5
0070:  MOVF   2E,W
0071:  BSF    03.5
0072:  MOVWF  07
0073:  BCF    03.5
0074:  BSF    07.5
.................... } 
0075:  BCF    0A.3
0076:  GOTO   326 (RETURN)
....................  
.................... void write_dac(int16 data) { 
....................    BYTE cmd[3]; 
....................    BYTE i; 
....................  
....................    cmd[0]=data; 
0077:  MOVF   57,W
0078:  MOVWF  59
....................    cmd[1]=(data>>8); 
0079:  MOVF   58,W
007A:  MOVWF  5A
....................    cmd[2]=0x03;                            
007B:  MOVLW  03
007C:  MOVWF  5B
....................     
....................    output_high(DAC_LDAC); 
007D:  BSF    03.5
007E:  BCF    06.5
007F:  BCF    03.5
0080:  BSF    06.5
....................    output_low(DAC_CLK); 
0081:  BCF    2E.3
0082:  MOVF   2E,W
0083:  BSF    03.5
0084:  MOVWF  07
0085:  BCF    03.5
0086:  BCF    07.3
....................    output_low(DAC_CS); 
0087:  BCF    2E.4
0088:  MOVF   2E,W
0089:  BSF    03.5
008A:  MOVWF  07
008B:  BCF    03.5
008C:  BCF    07.4
....................  
....................    for(i=0; i<=23; ++i) 
008D:  CLRF   5C
008E:  MOVF   5C,W
008F:  SUBLW  17
0090:  BTFSS  03.0
0091:  GOTO   0BF
....................    { 
....................       if(i<4 || (i>7 && i<12)) 
0092:  MOVF   5C,W
0093:  SUBLW  03
0094:  BTFSC  03.0
0095:  GOTO   09E
0096:  MOVF   5C,W
0097:  SUBLW  07
0098:  BTFSC  03.0
0099:  GOTO   0A3
009A:  MOVF   5C,W
009B:  SUBLW  0B
009C:  BTFSS  03.0
009D:  GOTO   0A3
....................          shift_left(cmd,3,0); 
009E:  BCF    03.0
009F:  RLF    59,F
00A0:  RLF    5A,F
00A1:  RLF    5B,F
....................       else 
00A2:  GOTO   0BD
....................       { 
....................          output_bit(DAC_DI, shift_left(cmd,3,0)); 
00A3:  BCF    03.0
00A4:  RLF    59,F
00A5:  RLF    5A,F
00A6:  RLF    5B,F
00A7:  BTFSC  03.0
00A8:  GOTO   0AB
00A9:  BCF    07.5
00AA:  GOTO   0AC
00AB:  BSF    07.5
00AC:  BCF    2E.5
00AD:  MOVF   2E,W
00AE:  BSF    03.5
00AF:  MOVWF  07
....................  
....................          output_high(DAC_CLK); 
00B0:  BCF    03.5
00B1:  BCF    2E.3
00B2:  MOVF   2E,W
00B3:  BSF    03.5
00B4:  MOVWF  07
00B5:  BCF    03.5
00B6:  BSF    07.3
....................          output_low(DAC_CLK); 
00B7:  BCF    2E.3
00B8:  MOVF   2E,W
00B9:  BSF    03.5
00BA:  MOVWF  07
00BB:  BCF    03.5
00BC:  BCF    07.3
....................       } 
....................    } 
00BD:  INCF   5C,F
00BE:  GOTO   08E
....................    output_high(DAC_CS); 
00BF:  BCF    2E.4
00C0:  MOVF   2E,W
00C1:  BSF    03.5
00C2:  MOVWF  07
00C3:  BCF    03.5
00C4:  BSF    07.4
....................  
....................    output_low(DAC_LDAC); 
00C5:  BSF    03.5
00C6:  BCF    06.5
00C7:  BCF    03.5
00C8:  BCF    06.5
....................    delay_us(10); 
00C9:  MOVLW  10
00CA:  MOVWF  20
00CB:  DECFSZ 20,F
00CC:  GOTO   0CB
00CD:  NOP
....................     
....................    output_HIGH(DAC_LDAC); 
00CE:  BSF    03.5
00CF:  BCF    06.5
00D0:  BCF    03.5
00D1:  BSF    06.5
.................... } 
00D2:  RETLW  00
....................  
....................  
....................  
.................... #include "pid.h" 
.................... /*This file has been prepared for Doxygen automatic documentation generation.*/ 
.................... /*! \file ********************************************************************* 
....................  * 
....................  * \brief Header file for pid.c. 
....................  * 
....................  * - File:               pid.h 
....................  * - Compiler:           IAR EWAAVR 4.11A 
....................  * - Supported devices:  All AVR devices can be used. 
....................  * - AppNote:            AVR221 - Discrete PID controller 
....................  * 
....................  * \author               Atmel Corporation: http://www.atmel.com \n 
....................  *                       Support email: avr@atmel.com 
....................  * 
....................  * $Name$ 
....................  * $Revision: 456 $ 
....................  * $RCSfile$ 
....................  * $Date: 2006-02-16 12:46:13 +0100 (to, 16 feb 2006) $ 
....................  *****************************************************************************/ 
....................  
.................... #ifndef PID_H 
.................... #define PID_H 
....................  
.................... //#include "stdint.h" 
.................... #define INT16_MAX 32767 
.................... #define INT32_MAX 2147483647 
.................... #define SCALING_FACTOR  128 
....................  
.................... /*! \brief PID Status 
....................  * 
....................  * Setpoints and data used by the PID control algorithm 
....................  */ 
.................... typedef struct PID_DATA{ 
....................   //! Last process value, used to find derivative of process value. 
....................   int16 lastProcessValue; 
....................   //! Summation of errors, used for integrate calculations 
....................   int32 sumError; 
....................   //! The Proportional tuning constant, multiplied with SCALING_FACTOR 
....................   int16 P_Factor; 
....................   //! The Integral tuning constant, multiplied with SCALING_FACTOR 
....................   int16 I_Factor; 
....................   //! The Derivative tuning constant, multiplied with SCALING_FACTOR 
....................   int16 D_Factor; 
....................   //! Maximum allowed error, avoid overflow 
....................   int16 maxError; 
....................   //! Maximum allowed sumerror, avoid overflow 
....................   int32 maxSumError; 
.................... } pidData_t; 
....................  
.................... /*! \brief Maximum values 
....................  * 
....................  * Needed to avoid sign/overflow problems 
....................  */ 
.................... // Maximum value of variables 
.................... #define MAX_INT         INT16_MAX 
.................... #define MAX_LONG        INT32_MAX 
.................... #define MAX_I_TERM      (MAX_LONG / 2) 
....................  
.................... // Boolean values 
.................... #define FALSE           0 
.................... #define TRUE            1 
....................  
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid); 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st); 
.................... void pid_Reset_Integrator(pidData_t *pid_st); 
....................  
.................... #endif 
....................  
.................... /* 
.................... This is the main controller for the super capacitor hybrid scooter a.k.a RED 
.................... B2 close contactor 
.................... CONTROL BOX INPUTS 
.................... Athrottle- A0 - analog input representing the users input for speed, 10 bit 
.................... Vspeed - CCp2-a 16 bit representation of the speed of the vehicle 
.................... Acaps- A1 - analog input representing the current voltage of the supercapacitors, 10 bit 
....................  
.................... CONTROL BOX OUTPUT 
.................... ICEthrottle- B1 - a 16 bit number sent to the internal combustion engine(ICE) throttle  
.................... ELECthrottle-  - a 16 bit number sent as analog value representing the demanded electric power 
....................  
.................... SPECIFICS OF I/O 
....................  
.................... Athrottle - the electric throttle is a 3 wire unit with a 5 volt,ground, and analog out 
....................    representing how far throttle is turned. Pin AN0 is the input. 
....................     
.................... Vspeed - There is a encoder in the rear wheel/electric motor that is used by the electric 
....................    power controller. Tapping in to this this Main Controller receives a 5 Volt square wave 
....................    with 42 pulses. There are two options for measuring speed. The first is to measure the  
....................    length of the pulses. The second is to measure the rate of pulses. This controller currently 
....................    uses the rate method. The int_ccp2 interupt is called on each falling edge and stores the  
....................    Vspeed value as the max number of 16bit (65535-timer0_since_last_reset).  
....................     
....................    The RED scooter has a circumpherence of 16.3*2*pi = 102.4 
....................    X m/h * 63360 inch/mile * 1/3600 h/sec * 1/(102.4 inch/rev) = .171875* X 
....................    Examples 50 mph is 8.9 ms 1 overflow of timer0 
....................    Example 5 mph is 89 ms or 13 time overflow 
....................     
....................    #int_timer0 increments the counter number_of_overflows each time it overflows 
....................    On int ccp2 we multiply number_of_overflows * 256 + timer0 to get timer0_since_last_reset 
....................     
.................... Acaps - the analog voltage which is the 5volt representation of the voltage in the caps which 
....................    have a value of between 0-48v. The voltages are factored so that the voltage on AN1 goes 
....................    from 0 - 4.8 volts (TODO check this factor, think its 1/11 not 1/10) 
....................     
.................... ICEthrottle -  #int_timer1 is set to make sure the period follows the required below 
....................    The period for the servo is .020 seconds which is 50,000 operations 
....................    The leftmost position of the server is .001 seconds which is 2,500 
....................    The rightmost position of the server is .002 seconds which is 5,000 
....................     
....................    The output pin is pin_B1.-> 
....................  
.................... ELECthrottle 
....................    The electric power controller takes an analog voltage as input. The output voltage 
....................    is set by the DAC. The pins used are C3,C4,C5. if CHARGING_STATE is true then  
....................     
.................... ALGORITHM 
....................    The algorithm is basically a PID controller. In broad terms we are trying to set the 
....................    ICEthrottle and ICEelectric to maximize the use of electric and accelerate to meet the 
....................    requirements set by the rider with the Athrottle signal. When the demanded power is  
....................    less than the power output possible by the ICE and the caps are in the CHARGING_STATE  
....................    then the ICE is turned up to the max and the ELECthrottle is set to regen to 
....................    charge the capacitors.If CHARGING_STATE is false then the caps are supplying the drivig power 
....................    and the ICE is set to "off", the caps supply the power. Unless the user requested supply 
....................    is enough to require both power sources. 
....................     
....................    If CHARGING_STATE is true. Then pin_b2 is set as high which will close the brake number 
....................    for the electric power controller.  
....................     
....................    If CHARGING_STATE is false then the pin_b2 is set low which opens brake. 
....................     
....................     
....................  
....................  
.................... The encoder has 42 on and offs per rotation, i.e. 21 steps 
....................  
.................... Number of operations per second is CLOCK/4/Timer Divisions 
.................... Number of operations per second is 20,000,000/4/128 = 39062.5  
.................... Each operation takes 1/39062.5 = .256 micro (x10^-6) seconds 
.................... Seconds to Overflow timer0 8bit timer = .256x10^-6 * 256 = 6.55ms 
....................  
....................  
....................  
.................... */ 
.................... #define servo_pin PIN_B1  //Setting servo out pin to be hardware pin b1 
.................... #define brake_pin PIN_B4 
.................... #define ADC_DELAY delay_us(20) 
.................... #define Acaps_pin PIN_A1 
.................... #define Acaps_channel 1 
.................... #define Athrottle_pin PIN_A0  //Voltage goes from 1.5 (306)to 4.1(836) 
.................... #define Athrottle_Min 306 
.................... #define Athrottle_Max 836 
.................... #define Athrottle_Full Athrottle_Max-Athrottle_Min 
.................... #define Athrottle_channel 0 
.................... #define Electric_Controller_Switch PIN_B0 
.................... #define Contactor_Switch PIN_B2 
....................  
.................... //PID Values 
.................... #define K_P 1.00 
.................... #define K_I 1.00 
.................... #define K_D 0.00 
....................  
.................... int1 pid_Timer = 0; 
*
02EA:  BCF    2F.0
.................... struct PID_DATA pidData; 
.................... #define TIME_INTERVAL 157 //TODO replace 
....................  
.................... #define left_position 3950 
.................... #define right_position 4800 
.................... #define servo_difference  right_position-left_position 
.................... const float Athrottle_servo_factor = ((float) servo_difference)/((float) Athrottle_FULL); 
.................... #define servo_period   65356-50000 
.................... unsigned int16 current_servo_position=right_position; 
02EB:  MOVLW  C0
02EC:  MOVWF  42
02ED:  MOVLW  12
02EE:  MOVWF  43
.................... int1 SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0; 
02EF:  BCF    2F.1
.................... int1 test_boolean = 0; 
02F0:  BCF    2F.2
....................  
.................... int1 test_switch = 0; 
02F1:  BCF    2F.3
.................... unsigned int16 test_counter = 0; 
02F2:  CLRF   44
02F3:  CLRF   45
....................  
.................... unsigned int8 number_of_timer0_interupts_since_reset =0; 
02F4:  CLRF   46
.................... unsigned int16 timer0_since_last_reset= 0; 
02F5:  CLRF   47
02F6:  CLRF   48
.................... unsigned int16 vSpeed= 255; 
02F7:  MOVLW  FF
02F8:  MOVWF  49
02F9:  CLRF   4A
.................... unsigned int16 ELECthrottle = 0; 
02FA:  CLRF   4B
02FB:  CLRF   4C
.................... unsigned int16 ICEthrottle = 0; 
02FC:  CLRF   4D
02FD:  CLRF   4E
.................... unsigned int16 Athrottle = 0; 
02FE:  CLRF   4F
02FF:  CLRF   50
.................... unsigned int16 Acaps = 0; 
0300:  CLRF   51
0301:  CLRF   52
.................... int1 CURRENTLY_CHARGING = 0; 
0302:  BCF    2F.4
....................  
.................... /* 
.................... The #int_timer0 interupt is triggered on each timer0 8bit interupt 
.................... the function simply increments a overflow counter to be used by the ccp2 
.................... interupt to calculate speed 
.................... NUMBER OF OPERATIONS =  
.................... */ 
.................... #int_timer0 
.................... void timer0_isr(){ 
....................    if (number_of_timer0_interupts_since_reset!=255){ 
*
0045:  INCFSZ 46,W
0046:  GOTO   048
0047:  GOTO   04A
....................       number_of_timer0_interupts_since_reset++; 
0048:  INCF   46,F
....................       //current_servo_position=current_servo_position+1; 
....................        
....................    } 
....................    else { 
0049:  GOTO   04E
....................       vSpeed = 255; 
004A:  CLRF   4A
004B:  MOVLW  FF
004C:  MOVWF  49
....................       number_of_timer0_interupts_since_reset=0; 
004D:  CLRF   46
....................        
....................        
....................    } 
.................... } 
....................  
.................... /* 
.................... #int_timer1 is used by the ICEservo throttle to regulate the timing pulses. The  
.................... timer is setup for a pulsetrain of 20ms period. This is done as follows, 
....................  
.................... Period is 1/(CLOCK/4opsperclock)*(startingPostionOfClock) = 20 ms 
.................... for this setup 1/(20000000/4)*(50000) = 20 ms 
....................  
.................... The timer1 starts at 0 and counts up. So we set the beggining of the clock at 
.................... servo_period which is 65356-50000 so that the total time is 20ms. 
.................... */ 
004E:  BCF    0B.2
004F:  BCF    0A.3
0050:  GOTO   02C
.................... #int_timer1 
.................... void isr() 
.................... { 
....................  
.................... //Make sure that the position is within the left and right positions of the servo 
.................... //!   if (current_servo_position<left_position){ 
.................... //!      current_servo_position = left_position; 
.................... //!   } 
.................... //!   else if (current_servo_position > right_position){ 
.................... //!      current_servo_position = right_position; 
.................... //!   } 
.................... //! 
.................... //!   if(SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER) 
.................... //!      {  
.................... //!         output_high(servo_pin);        //Set the servo control pin to high  
.................... //!         SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0;  
.................... //!         set_timer1(65356-current_servo_position); //Set timer for the position high pulse 
.................... //!      }  
.................... //!   else  
.................... //!      {  
.................... //!         output_low(servo_pin);                      // Set the servo control pin to low   
.................... //!         SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 1;  
.................... //!         set_timer1(servo_period+current_servo_position);          //Set timer for the low position the length is the difference between  
.................... //!                                                     //the total int16 lenght - high pulse length 
.................... //!      }   
.................... } 
....................  
....................  
.................... /* 
.................... #int_ccp2 is called on the falling edge of the encoder pulse. We calculate the time 
.................... between pulses.  
.................... TODO will have to put some kind of smoothing mechanism 
.................... */ 
0051:  BCF    0C.0
0052:  BCF    0A.3
0053:  GOTO   02C
.................... #int_ccp2 
.................... void isr2() 
.................... { 
.................... if (number_of_timer0_interupts_since_reset>20){ 
0054:  MOVF   46,W
0055:  SUBLW  14
0056:  BTFSC  03.0
0057:  GOTO   05C
.................... vSpeed  = number_of_timer0_interupts_since_reset; 
0058:  CLRF   4A
0059:  MOVF   46,W
005A:  MOVWF  49
.................... number_of_timer0_interupts_since_reset = 0; 
005B:  CLRF   46
.................... } 
.................... } 
....................  
....................  
....................  
....................  
005C:  BCF    0D.0
005D:  BCF    0A.3
005E:  GOTO   02C
.................... void main() 
.................... {   
*
02D9:  CLRF   04
02DA:  MOVLW  1F
02DB:  ANDWF  03,F
02DC:  BSF    03.5
02DD:  BCF    06.3
02DE:  BCF    03.5
02DF:  BSF    06.3
02E0:  BSF    03.5
02E1:  BSF    1F.0
02E2:  BSF    1F.1
02E3:  BSF    1F.2
02E4:  BCF    1F.3
02E5:  MOVLW  07
02E6:  MOVWF  1C
....................     
....................    setup_adc_ports(NO_ANALOGS); 
*
0303:  BSF    03.5
0304:  BSF    1F.0
0305:  BSF    1F.1
0306:  BSF    1F.2
0307:  BCF    1F.3
....................    setup_adc(ADC_OFF); 
0308:  BCF    03.5
0309:  BCF    1F.0
....................    setup_spi(FALSE); 
030A:  CLRF   14
....................     
....................    setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
030B:  BSF    03.5
030C:  MOVF   01,W
030D:  ANDLW  C0
030E:  IORLW  00
030F:  MOVWF  01
0310:  CLRWDT
....................    setup_timer_1(T1_DISABLED); 
0311:  BCF    03.5
0312:  CLRF   10
....................    setup_timer_2(T2_DISABLED,0,1); 
0313:  MOVLW  00
0314:  MOVWF  21
0315:  MOVWF  12
0316:  MOVLW  00
0317:  BSF    03.5
0318:  MOVWF  12
....................    setup_port_a(ALL_ANALOG); 
0319:  BCF    1F.0
031A:  BCF    1F.1
031B:  BCF    1F.2
031C:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
031D:  BCF    1F.6
031E:  BCF    03.5
031F:  BSF    1F.6
0320:  BSF    1F.7
0321:  BSF    03.5
0322:  BSF    1F.7
0323:  BCF    03.5
0324:  BSF    1F.0
....................     
....................    init_dac(); 
0325:  GOTO   05F
....................   
....................    setup_timer_1(T1_DIV_BY_2| T1_INTERNAL);  
0326:  MOVLW  95
0327:  MOVWF  10
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_128); 
0328:  BSF    03.5
0329:  MOVF   01,W
032A:  ANDLW  C0
032B:  IORLW  06
032C:  MOVWF  01
....................    setup_ccp2(CCP_CAPTURE_RE);    // Configure CCP2 to capture fall 
032D:  BCF    03.5
032E:  BSF    2E.1
032F:  MOVF   2E,W
0330:  BSF    03.5
0331:  MOVWF  07
0332:  BCF    03.5
0333:  CLRF   1D
0334:  MOVLW  05
0335:  MOVWF  1D
....................    enable_interrupts(INT_CCP2);   // Setup interrupt on falling edge 
0336:  BSF    03.5
0337:  BSF    0D.0
....................    enable_interrupts(INT_TIMER0); 
0338:  BCF    03.5
0339:  BSF    0B.5
....................    enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
033A:  BSF    03.5
033B:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
033C:  MOVLW  C0
033D:  BCF    03.5
033E:  IORWF  0B,F
....................    output_low(Electric_Controller_Switch); 
033F:  BSF    03.5
0340:  BCF    06.0
0341:  BCF    03.5
0342:  BCF    06.0
....................    write_dac(0); 
0343:  CLRF   58
0344:  CLRF   57
0345:  CALL   077
....................    output_high(Contactor_Switch); 
0346:  BSF    03.5
0347:  BCF    06.2
0348:  BCF    03.5
0349:  BSF    06.2
....................    output_low(brake_pin); 
034A:  BSF    03.5
034B:  BCF    06.4
034C:  BCF    03.5
034D:  BCF    06.4
....................    //pid_Init(K_P * SCALING_FACTOR,K_I*SCALING_FACTOR,K_D*SCALING_FACTOR, & pidData); 
....................     
....................    delay_ms(1000); 
034E:  MOVLW  04
034F:  MOVWF  53
0350:  MOVLW  FA
0351:  MOVWF  54
0352:  CALL   0D3
0353:  DECFSZ 53,F
0354:  GOTO   350
....................    write_dac(1000); 
0355:  MOVLW  03
0356:  MOVWF  58
0357:  MOVLW  E8
0358:  MOVWF  57
0359:  CALL   077
....................    delay_ms(10000); 
035A:  MOVLW  28
035B:  MOVWF  53
035C:  MOVLW  FA
035D:  MOVWF  54
035E:  CALL   0D3
035F:  DECFSZ 53,F
0360:  GOTO   35C
....................    //output_high(Contactor_Switch); 
....................    output_high(brake_pin); 
0361:  BSF    03.5
0362:  BCF    06.4
0363:  BCF    03.5
0364:  BSF    06.4
....................    output_high(Electric_Controller_Switch); 
0365:  BSF    03.5
0366:  BCF    06.0
0367:  BCF    03.5
0368:  BSF    06.0
....................    while(TRUE) { 
....................  
....................       //GET INPUTS 
....................       //Vspeed happens in interrupts 
....................        
....................       set_adc_channel(Acaps_channel); 
0369:  MOVLW  08
036A:  MOVWF  21
036B:  MOVF   1F,W
036C:  ANDLW  C7
036D:  IORWF  21,W
036E:  MOVWF  1F
....................       ADC_DELAY; 
036F:  MOVLW  21
0370:  MOVWF  20
0371:  DECFSZ 20,F
0372:  GOTO   371
....................       Acaps = read_adc(); 
0373:  BSF    1F.2
0374:  BTFSC  1F.2
0375:  GOTO   374
0376:  BSF    03.5
0377:  MOVF   1E,W
0378:  BCF    03.5
0379:  MOVWF  51
037A:  MOVF   1E,W
037B:  MOVWF  52
....................        
....................       set_adc_channel(Athrottle_channel); 
037C:  MOVLW  00
037D:  MOVWF  21
037E:  MOVF   1F,W
037F:  ANDLW  C7
0380:  IORWF  21,W
0381:  MOVWF  1F
....................       ADC_DELAY; 
0382:  MOVLW  21
0383:  MOVWF  20
0384:  DECFSZ 20,F
0385:  GOTO   384
....................       Athrottle = read_adc(); 
0386:  BSF    1F.2
0387:  BTFSC  1F.2
0388:  GOTO   387
0389:  BSF    03.5
038A:  MOVF   1E,W
038B:  BCF    03.5
038C:  MOVWF  4F
038D:  MOVF   1E,W
038E:  MOVWF  50
....................  
....................       //CONTROL BOX 
....................  
....................        
....................       //current_servo_position=left_position+((Athrottle-Athrottle_Min)/Athrottle_Full)*servo_difference;//(vSpeed/65536.0)*(2500); 
....................       if (Athrottle<Athrottle_Min){ 
038F:  MOVF   50,W
0390:  SUBLW  01
0391:  BTFSS  03.0
0392:  GOTO   39D
0393:  BTFSS  03.2
0394:  GOTO   399
0395:  MOVF   4F,W
0396:  SUBLW  31
0397:  BTFSS  03.0
0398:  GOTO   39D
....................          Athrottle=Athrottle_Min; 
0399:  MOVLW  01
039A:  MOVWF  50
039B:  MOVLW  32
039C:  MOVWF  4F
....................       } 
....................       current_servo_position=right_position-(Athrottle-Athrottle_Min)*Athrottle_servo_factor;//(Athrottle/Athrottle_Full)*servo_difference;//(vSpeed/65536.0)*(2500); 
039D:  MOVLW  32
039E:  SUBWF  4F,W
039F:  MOVWF  53
03A0:  MOVF   50,W
03A1:  MOVWF  54
03A2:  MOVLW  01
03A3:  BTFSS  03.0
03A4:  MOVLW  02
03A5:  SUBWF  54,F
03A6:  MOVF   54,W
03A7:  MOVWF  56
03A8:  MOVF   53,W
03A9:  MOVWF  55
03AA:  GOTO   0E6
03AB:  MOVF   23,W
03AC:  MOVWF  58
03AD:  MOVF   22,W
03AE:  MOVWF  57
03AF:  MOVF   21,W
03B0:  MOVWF  56
03B1:  MOVF   20,W
03B2:  MOVWF  55
03B3:  MOVLW  74
03B4:  MOVWF  5C
03B5:  MOVLW  48
03B6:  MOVWF  5B
03B7:  MOVLW  4D
03B8:  MOVWF  5A
03B9:  MOVLW  7F
03BA:  MOVWF  59
03BB:  GOTO   104
03BC:  BSF    03.1
03BD:  CLRF   58
03BE:  CLRF   57
03BF:  MOVLW  16
03C0:  MOVWF  56
03C1:  MOVLW  8B
03C2:  MOVWF  55
03C3:  MOVF   23,W
03C4:  MOVWF  5C
03C5:  MOVF   22,W
03C6:  MOVWF  5B
03C7:  MOVF   21,W
03C8:  MOVWF  5A
03C9:  MOVF   20,W
03CA:  MOVWF  59
03CB:  GOTO   17A
03CC:  MOVF   23,W
03CD:  MOVWF  58
03CE:  MOVF   22,W
03CF:  MOVWF  57
03D0:  MOVF   21,W
03D1:  MOVWF  56
03D2:  MOVF   20,W
03D3:  MOVWF  55
03D4:  GOTO   2B9
03D5:  MOVF   22,W
03D6:  MOVWF  43
03D7:  MOVF   21,W
03D8:  MOVWF  42
....................       //printf("Analog Cap %d Analog Throttle %d\n",(int) Acaps, (int) Athrottle); 
....................        
....................     
....................       //SET OUTPUTS  
....................       //The writing of the ICEThrottle happens in interupts and all that is 
....................       //required is updating ICEthrottle 
....................        
....................       write_dac((right_position-current_servo_position)*4); 
03D9:  MOVF   42,W
03DA:  SUBLW  C0
03DB:  MOVWF  53
03DC:  MOVLW  12
03DD:  MOVWF  54
03DE:  MOVF   43,W
03DF:  BTFSS  03.0
03E0:  INCFSZ 43,W
03E1:  SUBWF  54,F
03E2:  RLF    53,W
03E3:  MOVWF  55
03E4:  RLF    54,W
03E5:  MOVWF  56
03E6:  RLF    55,F
03E7:  RLF    56,F
03E8:  MOVLW  FC
03E9:  ANDWF  55,F
03EA:  MOVF   56,W
03EB:  MOVWF  58
03EC:  MOVF   55,W
03ED:  MOVWF  57
03EE:  CALL   077
....................       //write_dac((right_position-current_servo_position)*4); 
....................    } 
03EF:  GOTO   369
....................     
....................  
.................... } 
....................  
.................... /*! \brief Initialisation of PID controller parameters. 
....................  * 
....................  *  Initialise the variables used by the PID algorithm. 
....................  * 
....................  *  \param p_factor  Proportional term. 
....................  *  \param i_factor  Integral term. 
....................  *  \param d_factor  Derivate term. 
....................  *  \param pid  Struct with PID status. 
....................  */ 
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid) 
.................... // Set up PID controller parameters 
03F0:  GOTO   3F0
.................... { 
....................   // Start values for PID controller 
....................   pid->sumError = 0; 
....................   pid->lastProcessValue = 0; 
....................   // Tuning constants for PID loop 
....................   pid->P_Factor = p_factor; 
....................   pid->I_Factor = i_factor; 
....................   pid->D_Factor = d_factor; 
....................   // Limits to avoid overflow 
....................   pid->maxError = MAX_INT / (pid->P_Factor + 1); 
....................   pid->maxSumError = MAX_I_TERM / (pid->I_Factor + 1); 
.................... } 
....................  
....................  
.................... /*! \brief PID control algorithm. 
....................  * 
....................  *  Calculates output from setpoint, process value and PID status. 
....................  * 
....................  *  \param setPoint  Desired value. 
....................  *  \param processValue  Measured value. 
....................  *  \param pid_st  PID status struct. 
....................  */ 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st) 
.................... { 
....................   int16 error, p_term, d_term; 
....................   int32 i_term, ret, temp; 
....................  
....................   error = setPoint - processValue; 
....................  
....................   // Calculate Pterm and limit error overflow 
....................   if (error > pid_st->maxError){ 
....................     p_term = MAX_INT; 
....................   } 
....................   else if (error < -pid_st->maxError){ 
....................     p_term = -MAX_INT; 
....................   } 
....................   else{ 
....................     p_term = pid_st->P_Factor * error; 
....................   } 
....................  
....................   // Calculate Iterm and limit integral runaway 
....................   temp = pid_st->sumError + error; 
....................   if(temp > pid_st->maxSumError){ 
....................     i_term = MAX_I_TERM; 
....................     pid_st->sumError = pid_st->maxSumError; 
....................   } 
....................   else if(temp < -pid_st->maxSumError){ 
....................     i_term = -MAX_I_TERM; 
....................     pid_st->sumError = -pid_st->maxSumError; 
....................   } 
....................   else{ 
....................     pid_st->sumError = temp; 
....................     i_term = pid_st->I_Factor * pid_st->sumError; 
....................   } 
....................  
....................   // Calculate Dterm 
....................   d_term = pid_st->D_Factor * (pid_st->lastProcessValue - processValue); 
....................  
....................   pid_st->lastProcessValue = processValue; 
....................  
....................   ret = (p_term + i_term + d_term) / SCALING_FACTOR; 
....................   if(ret > MAX_INT){ 
....................     ret = MAX_INT; 
....................   } 
....................   else if(ret < -MAX_INT){ 
....................     ret = -MAX_INT; 
....................   } 
....................  
....................   return((int16)ret); 
.................... } 
....................  
.................... /*! \brief Resets the integrator. 
....................  * 
....................  *  Calling this function will reset the integrator in the PID regulator. 
....................  */ 
.................... void pid_Reset_Integrator(pidData_t *pid_st) 
.................... { 
....................   pid_st->sumError = 0; 
.................... } 
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 373A   HS NOWDT NOPUT DEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
