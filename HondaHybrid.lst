CCS PCM C Compiler, Version 4.084, 46530               15-Jun-13 17:42

               Filename: HondaHybrid.lst

               ROM used: 2500 words (61%)
                         Largest free fragment is 1351
               RAM used: 60 (31%) at main() level
                         104 (54%) worst case
               Stack:    3 worst case (2 in main + 1 for interrupts)

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  26
0008:  MOVF   7F,W
0009:  MOVWF  25
000A:  MOVF   0A,W
000B:  MOVWF  2D
000C:  CLRF   0A
000D:  SWAPF  25,F
000E:  MOVF   04,W
000F:  MOVWF  27
0010:  MOVF   20,W
0011:  MOVWF  28
0012:  MOVF   21,W
0013:  MOVWF  29
0014:  MOVF   22,W
0015:  MOVWF  2A
0016:  MOVF   23,W
0017:  MOVWF  2B
0018:  MOVF   24,W
0019:  MOVWF  2C
001A:  BCF    03.7
001B:  BCF    03.5
001C:  MOVLW  8C
001D:  MOVWF  04
001E:  BTFSS  00.0
001F:  GOTO   022
0020:  BTFSC  0C.0
0021:  GOTO   03F
0022:  MOVLW  8D
0023:  MOVWF  04
0024:  BTFSS  00.0
0025:  GOTO   028
0026:  BTFSC  0D.0
0027:  GOTO   041
0028:  BTFSS  0B.5
0029:  GOTO   02C
002A:  BTFSC  0B.2
002B:  GOTO   043
002C:  MOVF   27,W
002D:  MOVWF  04
002E:  MOVF   28,W
002F:  MOVWF  20
0030:  MOVF   29,W
0031:  MOVWF  21
0032:  MOVF   2A,W
0033:  MOVWF  22
0034:  MOVF   2B,W
0035:  MOVWF  23
0036:  MOVF   2C,W
0037:  MOVWF  24
0038:  MOVF   2D,W
0039:  MOVWF  0A
003A:  SWAPF  26,W
003B:  MOVWF  03
003C:  SWAPF  7F,F
003D:  SWAPF  7F,W
003E:  RETFIE
003F:  BCF    0A.3
0040:  GOTO   101
0041:  BCF    0A.3
0042:  GOTO   159
0043:  BCF    0A.3
0044:  GOTO   0F3
.................... #include "HondaHybrid.h" 
.................... #include <16F873A.h> 
.................... //////// Standard Header file for the PIC16F873A device //////////////// 
.................... #device PIC16F873A 
.................... #list 
....................  
....................  
.................... //#include <16F737.h> 
.................... //#device ICD=TRUE 
.................... #device adc=10 
.................... //#device adc=8 
.................... #use delay(clock=20000000) 
*
02D9:  MOVLW  58
02DA:  MOVWF  04
02DB:  MOVF   00,W
02DC:  BTFSC  03.2
02DD:  GOTO   2EB
02DE:  MOVLW  06
02DF:  MOVWF  21
02E0:  CLRF   20
02E1:  DECFSZ 20,F
02E2:  GOTO   2E1
02E3:  DECFSZ 21,F
02E4:  GOTO   2E0
02E5:  MOVLW  7B
02E6:  MOVWF  20
02E7:  DECFSZ 20,F
02E8:  GOTO   2E7
02E9:  DECFSZ 00,F
02EA:  GOTO   2DE
02EB:  RETLW  00
.................... #fuses HS,PUT,NOWDT 
.................... #use rs232 (DEBUGGER) 
02EC:  MOVF   58,W
02ED:  RETLW  00
.................... #include <mcp4921.c> 
.................... //////////////// Driver for MCP4921 D/A Converter /////////////////////// 
.................... ////                                                                 //// 
.................... ////  init_dac()    Call this before using a MCP4921 DAC             //// 
.................... ////                                                                 //// 
.................... ////  write_dac( long int )   Writes command and 12 bit resolution   //// 
.................... ////                          to the MCP4921 which converts it to a  //// 
.................... ////                          voltage                                //// 
.................... ////                          0-4095 input represents 0-vref V out.  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SELECT 
....................  
.................... #define DAC_CS     PIN_C4 
.................... #define DAC_CLK    PIN_C3 
.................... #define DAC_DI     PIN_C5 
.................... #define DAC_LDAC   PIN_B5 
....................  
.................... #endif 
....................  
.................... void init_dac() 
.................... { 
....................    output_high(DAC_CS); 
*
0176:  BCF    2E.4
0177:  MOVF   2E,W
0178:  BSF    03.5
0179:  MOVWF  07
017A:  BCF    03.5
017B:  BSF    07.4
....................    output_high(DAC_LDAC); 
017C:  BSF    03.5
017D:  BCF    06.5
017E:  BCF    03.5
017F:  BSF    06.5
....................    output_high(DAC_CLK); 
0180:  BCF    2E.3
0181:  MOVF   2E,W
0182:  BSF    03.5
0183:  MOVWF  07
0184:  BCF    03.5
0185:  BSF    07.3
....................    output_high(DAC_DI); 
0186:  BCF    2E.5
0187:  MOVF   2E,W
0188:  BSF    03.5
0189:  MOVWF  07
018A:  BCF    03.5
018B:  BSF    07.5
.................... } 
018C:  BSF    0A.3
018D:  GOTO   04F (RETURN)
....................  
.................... void write_dac(int16 data) { 
....................    BYTE cmd[3]; 
....................    BYTE i; 
....................  
....................    cmd[0]=data; 
018E:  MOVF   5B,W
018F:  MOVWF  5D
....................    cmd[1]=(data>>8); 
0190:  MOVF   5C,W
0191:  MOVWF  5E
....................    cmd[2]=0x03;                            
0192:  MOVLW  03
0193:  MOVWF  5F
....................     
....................    output_high(DAC_LDAC); 
0194:  BSF    03.5
0195:  BCF    06.5
0196:  BCF    03.5
0197:  BSF    06.5
....................    output_low(DAC_CLK); 
0198:  BCF    2E.3
0199:  MOVF   2E,W
019A:  BSF    03.5
019B:  MOVWF  07
019C:  BCF    03.5
019D:  BCF    07.3
....................    output_low(DAC_CS); 
019E:  BCF    2E.4
019F:  MOVF   2E,W
01A0:  BSF    03.5
01A1:  MOVWF  07
01A2:  BCF    03.5
01A3:  BCF    07.4
....................  
....................    for(i=0; i<=23; ++i) 
01A4:  CLRF   60
01A5:  MOVF   60,W
01A6:  SUBLW  17
01A7:  BTFSS  03.0
01A8:  GOTO   1D6
....................    { 
....................       if(i<4 || (i>7 && i<12)) 
01A9:  MOVF   60,W
01AA:  SUBLW  03
01AB:  BTFSC  03.0
01AC:  GOTO   1B5
01AD:  MOVF   60,W
01AE:  SUBLW  07
01AF:  BTFSC  03.0
01B0:  GOTO   1BA
01B1:  MOVF   60,W
01B2:  SUBLW  0B
01B3:  BTFSS  03.0
01B4:  GOTO   1BA
....................          shift_left(cmd,3,0); 
01B5:  BCF    03.0
01B6:  RLF    5D,F
01B7:  RLF    5E,F
01B8:  RLF    5F,F
....................       else 
01B9:  GOTO   1D4
....................       { 
....................          output_bit(DAC_DI, shift_left(cmd,3,0)); 
01BA:  BCF    03.0
01BB:  RLF    5D,F
01BC:  RLF    5E,F
01BD:  RLF    5F,F
01BE:  BTFSC  03.0
01BF:  GOTO   1C2
01C0:  BCF    07.5
01C1:  GOTO   1C3
01C2:  BSF    07.5
01C3:  BCF    2E.5
01C4:  MOVF   2E,W
01C5:  BSF    03.5
01C6:  MOVWF  07
....................  
....................          output_high(DAC_CLK); 
01C7:  BCF    03.5
01C8:  BCF    2E.3
01C9:  MOVF   2E,W
01CA:  BSF    03.5
01CB:  MOVWF  07
01CC:  BCF    03.5
01CD:  BSF    07.3
....................          output_low(DAC_CLK); 
01CE:  BCF    2E.3
01CF:  MOVF   2E,W
01D0:  BSF    03.5
01D1:  MOVWF  07
01D2:  BCF    03.5
01D3:  BCF    07.3
....................       } 
....................    } 
01D4:  INCF   60,F
01D5:  GOTO   1A5
....................    output_high(DAC_CS); 
01D6:  BCF    2E.4
01D7:  MOVF   2E,W
01D8:  BSF    03.5
01D9:  MOVWF  07
01DA:  BCF    03.5
01DB:  BSF    07.4
....................  
....................    output_low(DAC_LDAC); 
01DC:  BSF    03.5
01DD:  BCF    06.5
01DE:  BCF    03.5
01DF:  BCF    06.5
....................    delay_us(10); 
01E0:  MOVLW  10
01E1:  MOVWF  20
01E2:  DECFSZ 20,F
01E3:  GOTO   1E2
01E4:  NOP
....................     
....................    output_HIGH(DAC_LDAC); 
01E5:  BSF    03.5
01E6:  BCF    06.5
01E7:  BCF    03.5
01E8:  BSF    06.5
.................... } 
01E9:  RETLW  00
....................  
....................  
....................  
.................... #include "pid.h" 
.................... /*This file has been prepared for Doxygen automatic documentation generation.*/ 
.................... /*! \file ********************************************************************* 
....................  * 
....................  * \brief Header file for pid.c. 
....................  * 
....................  * - File:               pid.h 
....................  * - Compiler:           IAR EWAAVR 4.11A 
....................  * - Supported devices:  All AVR devices can be used. 
....................  * - AppNote:            AVR221 - Discrete PID controller 
....................  * 
....................  * \author               Atmel Corporation: http://www.atmel.com \n 
....................  *                       Support email: avr@atmel.com 
....................  * 
....................  * $Name$ 
....................  * $Revision: 456 $ 
....................  * $RCSfile$ 
....................  * $Date: 2006-02-16 12:46:13 +0100 (to, 16 feb 2006) $ 
....................  *****************************************************************************/ 
....................  
.................... #ifndef PID_H 
.................... #define PID_H 
....................  
.................... //#include "stdint.h" 
.................... #define INT16_MAX 32767 
.................... #define INT32_MAX 2147483647 
.................... #define SCALING_FACTOR  128 
....................  
.................... /*! \brief PID Status 
....................  * 
....................  * Setpoints and data used by the PID control algorithm 
....................  */ 
.................... typedef struct PID_DATA{ 
....................   //! Last process value, used to find derivative of process value. 
....................   int16 lastProcessValue; 
....................   //! Summation of errors, used for integrate calculations 
....................   int32 sumError; 
....................   //! The Proportional tuning constant, multiplied with SCALING_FACTOR 
....................   int16 P_Factor; 
....................   //! The Integral tuning constant, multiplied with SCALING_FACTOR 
....................   int16 I_Factor; 
....................   //! The Derivative tuning constant, multiplied with SCALING_FACTOR 
....................   int16 D_Factor; 
....................   //! Maximum allowed error, avoid overflow 
....................   int16 maxError; 
....................   //! Maximum allowed sumerror, avoid overflow 
....................   int32 maxSumError; 
.................... } pidData_t; 
....................  
.................... /*! \brief Maximum values 
....................  * 
....................  * Needed to avoid sign/overflow problems 
....................  */ 
.................... // Maximum value of variables 
.................... #define MAX_INT         INT16_MAX 
.................... #define MAX_LONG        INT32_MAX 
.................... #define MAX_I_TERM      (MAX_LONG / 2) 
....................  
.................... // Boolean values 
.................... //#define FALSE           0 
.................... //#define TRUE            1 
....................  
.................... boolean checkRunnaway(struct PID_DATA *pid); 
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid); 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st); 
.................... void pid_Reset_Integrator(pidData_t *pid_st); 
....................  
.................... #endif 
....................  
.................... /* 
.................... This is the main controller for the super capacitor hybrid scooter a.k.a RED 
.................... B2 close contactor 
.................... CONTROL BOX INPUTS 
.................... Athrottle- A0 - analog input representing the users input for speed, 10 bit 
.................... Vspeed - CCp2-a 16 bit representation of the speed of the vehicle 
.................... Acaps- A1 - analog input representing the current voltage of the supercapacitors, 10 bit 
.................... There are 18 Supercaps with a maximum voltage of 2.7 (2.85 is breakdown) volts for a total of 48.6 V 
.................... The circuit has a 10/110 voltage divider into the ADC. So minimum voltage of 18 Volts is 335 and 48 Volts is 893. Measured 38.2V equal to 726 
....................  
.................... CONTROL BOX OUTPUT 
.................... ICEthrottle- B1 - a 16 bit number sent to the internal combustion engine(ICE) throttle  
.................... ELECthrottle-  - a 16 bit number sent as analog value representing the demanded electric power 
....................  
.................... SPECIFICS OF I/O 
....................  
.................... Athrottle - the electric throttle is a 3 wire unit with a 5 volt,ground, and analog out 
....................    representing how far throttle is turned. Pin AN0 is the input. 
....................     
.................... Vspeed - There is a encoder in the rear wheel/electric motor that is used by the electric 
....................    power controller. Tapping in to this this Main Controller receives a 5 Volt square wave 
....................    with 42 pulses. There are two options for measuring speed. The first is to measure the  
....................    length of the pulses. The second is to measure the rate of pulses. This controller currently 
....................    uses the rate method. The int_ccp2 interupt is called on each falling edge and stores the  
....................    Vspeed value as the max number of 16bit (65535-timer0_since_last_reset).  
....................     
....................    The RED scooter has a circumpherence of 16.3*2*pi = 102.4 
....................    X m/h * 63360 inch/mile * 1/3600 h/sec * 1/(102.4 inch/rev) = .171875* X 
....................    Examples 50 mph is 8.9 ms 1 overflow of timer0 
....................    Example 5 mph is 89 ms or 13 time overflow 
....................     
....................    #int_timer0 increments the counter number_of_overflows each time it overflows 
....................    On int ccp2 we multiply number_of_overflows * 256 + timer0 to get timer0_since_last_reset 
....................     
.................... Acaps - the analog voltage which is the 5volt representation of the voltage in the caps which 
....................    have a value of between 0-48v. The voltages are factored so that the voltage on AN1 goes 
....................    from 0 - 4.8 volts (TODO check this factor, think its 1/11 not 1/10) 
....................     
.................... ICEthrottle -  #int_timer1 is set to make sure the period follows the required below 
....................    The period for the servo is .020 seconds which is 50,000 operations 
....................    The leftmost position of the server is .001 seconds which is 2,500 
....................    The rightmost position of the server is .002 seconds which is 5,000 
....................     
....................    The output pin is pin_B1.-> 
....................  
.................... ELECthrottle 
....................    The electric power controller takes an analog voltage as input. The output voltage 
....................    is set by the DAC. The pins used are C3,C4,C5. if CHARGING_STATE is true then  
....................     
.................... ALGORITHM 
....................    The algorithm is basically a PID controller. In broad terms we are trying to set the 
....................    ICEthrottle and ICEelectric to maximize the use of electric and accelerate to meet the 
....................    requirements set by the rider with the Athrottle signal. When the demanded power is  
....................    less than the power output possible by the ICE and the caps are in the CHARGING_STATE  
....................    then the ICE is turned up to the max and the ELECthrottle is set to regen to 
....................    charge the capacitors.If CHARGING_STATE is false then the caps are supplying the drivig power 
....................    and the ICE is set to "off", the caps supply the power. Unless the user requested supply 
....................    is enough to require both power sources. 
....................     
....................    If CHARGING_STATE is true. Then pin_b2 is set as high which will close the brake number 
....................    for the electric power controller.  
....................     
....................    If CHARGING_STATE is false then the pin_b2 is set low which opens brake. 
....................     
....................     
....................  
....................  
.................... The encoder has 42 on and offs per rotation, i.e. 21 steps 
....................  
.................... Number of operations per second is CLOCK/4/Timer Divisions 
.................... Number of operations per second is 20,000,000/4/128 = 39062.5  
.................... Each operation takes 1/39062.5 = .256 micro (x10^-6) seconds 
.................... Seconds to Overflow timer0 8bit timer = .256x10^-6 * 256 = 6.55ms 
....................  
....................  
....................  
.................... */ 
.................... #define servo_pin PIN_B1  //Setting servo out pin to be hardware pin b1 
.................... #define brake_pin PIN_B4 
.................... #define ADC_DELAY delay_us(20) 
.................... #define Acaps_pin PIN_A1 
.................... #define Acaps_channel 1 
.................... #define Athrottle_pin PIN_A0  //Voltage goes from 1.5 (306)to 4.1(836) 
.................... #define Athrottle_Min 316 
.................... #define Athrottle_Max 860 
.................... #define Athrottle_Full Athrottle_Max-Athrottle_Min 
.................... #define Athrottle_channel 0 
.................... #define Electric_Controller_Switch PIN_B0 
.................... #define Contactor_Switch PIN_B2 
.................... #define A_CAPS_MAX 725//893 
.................... #define A_CAPS_MIN 335 
.................... #define A_CAPS_MID_LOW (A_CAPS_MIN + 100) //This is the low end of the middle ACaps range. The range in which discharge and charge are allowed.  
.................... #define A_CAPS_MID_HIGH (A_CAPS_MAX - 100) //This is the low end of the middle ACaps range. The range in which discharge and charge are allowed.  
.................... #define V_SPEED_REGEN_MIN 50 //Why is there a minimum speed? Because below this no regenerative action is possible with electric motor 
.................... #define INSUFFICIENT_BRAKING_RUNNAWAY_ERROR 50000 
....................  
.................... //PID Values 
.................... #define K_P 1.00 
.................... #define K_I 0.00 
.................... #define K_D 0.00 
....................  
.................... int1 pid_Timer = 0; 
*
080E:  BCF    2F.0
.................... struct PID_DATA pidData; 
.................... #define TIME_INTERVAL 157 //TODO replace 
....................  
.................... #define left_position 3500//4450 
.................... #define right_position 5300 
.................... #define servo_difference  right_position-left_position 
.................... #define servo_difference_div 5200 
.................... #define ELEC_CONTROLLER_OFFSET 900 
.................... const float Athrottle_servo_factor = ((float) servo_difference)/((float) Athrottle_FULL); 
.................... #define servo_period   65356-50000 
.................... unsigned int16 current_servo_position=right_position; 
080F:  MOVLW  B4
0810:  MOVWF  42
0811:  MOVLW  14
0812:  MOVWF  43
.................... int1 SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0; 
0813:  BCF    2F.1
.................... int1 test_boolean = 0; 
0814:  BCF    2F.2
....................  
.................... int1 test_switch = 0; 
0815:  BCF    2F.3
.................... unsigned int16 test_counter = 0; 
0816:  CLRF   44
0817:  CLRF   45
.................... //int16 returnedValue = 0; 
....................  
.................... unsigned int16 number_of_timer0_interupts_since_reset =0; 
0818:  CLRF   46
0819:  CLRF   47
.................... unsigned int16 timer0_since_last_reset= 0; 
081A:  CLRF   48
081B:  CLRF   49
.................... unsigned int16 vSpeed= 0; 
081C:  CLRF   4A
081D:  CLRF   4B
.................... signed int16 ELECthrottle = 0; 
081E:  CLRF   4C
081F:  CLRF   4D
.................... unsigned int16 ICEthrottle = 0; 
0820:  CLRF   4E
0821:  CLRF   4F
.................... unsigned int16 Athrottle = 0; 
0822:  CLRF   50
0823:  CLRF   51
.................... unsigned int16 Acaps = 0; 
0824:  CLRF   52
0825:  CLRF   53
.................... int1 ICE_ON = 0; 
0826:  BCF    2F.4
.................... int1 CURRENTLY_CHARGING = 0; 
0827:  BCF    2F.5
.................... int1 RUNNAWAY_CHECK = 0; 
0828:  BCF    2F.6
.................... signed int16 returnedValue =0;  
0829:  CLRF   54
082A:  CLRF   55
....................  
.................... enum{  
....................    EVERYTHING_OFF, 
....................    SPEED_TO_LOW_ICE_DIRECT, 
....................    CHARGING_ALLOWED,  
....................    DISCHARGING_ALLOWED,  
....................    CHARGING_AND_DISCHARING_ALLOWED, 
....................    INSUFFICIENT_BRAKING_RUNAWAY, 
....................    USER_INPUT_OFF 
.................... } CHARGING_STATE;  
....................  
.................... /* 
.................... The #int_timer0 interupt is triggered on each timer0 8bit interupt 
.................... the function simply increments a overflow counter to be used by the ccp2 
.................... interupt to calculate speed 
.................... NUMBER OF OPERATIONS =  
.................... */ 
.................... #int_timer0 
.................... void timer0_isr(){ 
....................     
....................       number_of_timer0_interupts_since_reset=number_of_timer0_interupts_since_reset+256; 
*
00F3:  MOVLW  01
00F4:  ADDWF  47,F
....................       //current_servo_position=current_servo_position+1; 
....................        
....................     
....................    if (number_of_timer0_interupts_since_reset>=1024){ 
00F5:  MOVF   47,W
00F6:  SUBLW  03
00F7:  BTFSC  03.0
00F8:  GOTO   0FE
....................       vSpeed = 0; 
00F9:  CLRF   4B
00FA:  CLRF   4A
....................       number_of_timer0_interupts_since_reset=1024; 
00FB:  MOVLW  04
00FC:  MOVWF  47
00FD:  CLRF   46
....................        
....................        
....................    } 
.................... } 
....................  
.................... /* 
.................... #int_timer1 is used by the ICEservo throttle to regulate the timing pulses. The  
.................... timer is setup for a pulsetrain of 20ms period. This is done as follows, 
....................  
.................... Period is 1/(CLOCK/4opsperclock)*(startingPostionOfClock) = 20 ms 
.................... for this setup 1/(20000000/4)*(50000) = 20 ms 
....................  
.................... The timer1 starts at 0 and counts up. So we set the beggining of the clock at 
.................... servo_period which is 65356-50000 so that the total time is 20ms. 
.................... */ 
00FE:  BCF    0B.2
00FF:  BCF    0A.3
0100:  GOTO   02C
.................... #int_timer1 
.................... void isr() 
.................... { 
....................  
.................... //Make sure that the position is within the left and right positions of the servo 
....................    if (current_servo_position<left_position){ 
0101:  MOVF   43,W
0102:  SUBLW  0D
0103:  BTFSS  03.0
0104:  GOTO   110
0105:  BTFSS  03.2
0106:  GOTO   10B
0107:  MOVF   42,W
0108:  SUBLW  AB
0109:  BTFSS  03.0
010A:  GOTO   110
....................       current_servo_position = left_position; 
010B:  MOVLW  0D
010C:  MOVWF  43
010D:  MOVLW  AC
010E:  MOVWF  42
....................    } 
....................    else if (current_servo_position > right_position){ 
010F:  GOTO   11F
0110:  MOVF   43,W
0111:  SUBLW  13
0112:  BTFSC  03.0
0113:  GOTO   11F
0114:  XORLW  FF
0115:  BTFSS  03.2
0116:  GOTO   11B
0117:  MOVF   42,W
0118:  SUBLW  B4
0119:  BTFSC  03.0
011A:  GOTO   11F
....................       current_servo_position = right_position; 
011B:  MOVLW  14
011C:  MOVWF  43
011D:  MOVLW  B4
011E:  MOVWF  42
....................    } 
.................... //printf("Current servo position %ld",current_servo_position); 
....................    if(SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER) 
011F:  BTFSS  2F.1
0120:  GOTO   13E
....................       {  
....................          output_high(servo_pin);        //Set the servo control pin to high  
0121:  BSF    03.5
0122:  BCF    06.1
0123:  BCF    03.5
0124:  BSF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0;  
0125:  BCF    2F.1
....................          set_timer1(65356-current_servo_position); //Set timer for the position high pulse 
0126:  MOVF   42,W
0127:  SUBLW  4C
0128:  BSF    03.5
0129:  MOVWF  26
012A:  MOVLW  FF
012B:  MOVWF  27
012C:  BCF    03.5
012D:  MOVF   43,W
012E:  BTFSS  03.0
012F:  INCFSZ 43,W
0130:  GOTO   132
0131:  GOTO   135
0132:  BSF    03.5
0133:  SUBWF  27,F
0134:  BCF    03.5
0135:  BSF    03.5
0136:  MOVF   27,W
0137:  BCF    03.5
0138:  MOVWF  0F
0139:  BSF    03.5
013A:  MOVF   26,W
013B:  BCF    03.5
013C:  MOVWF  0E
....................       }  
....................    else  
013D:  GOTO   156
....................       {  
....................          output_low(servo_pin);                      // Set the servo control pin to low   
013E:  BSF    03.5
013F:  BCF    06.1
0140:  BCF    03.5
0141:  BCF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 1;  
0142:  BSF    2F.1
....................          set_timer1(servo_period+current_servo_position);          //Set timer for the low position the length is the difference between  
0143:  MOVLW  FC
0144:  ADDWF  42,W
0145:  BSF    03.5
0146:  MOVWF  26
0147:  BCF    03.5
0148:  MOVF   43,W
0149:  BSF    03.5
014A:  MOVWF  27
014B:  MOVLW  3B
014C:  BTFSC  03.0
014D:  MOVLW  3C
014E:  ADDWF  27,F
014F:  MOVF   27,W
0150:  BCF    03.5
0151:  MOVWF  0F
0152:  BSF    03.5
0153:  MOVF   26,W
0154:  BCF    03.5
0155:  MOVWF  0E
....................                                                      //the total int16 lenght - high pulse length 
....................       }   
....................  
.................... } 
....................  
....................  
.................... /* 
.................... #int_ccp2 is called on the falling edge of the encoder pulse. We calculate the time 
.................... between pulses.  
.................... TODO will have to put some kind of smoothing mechanism 
.................... */ 
0156:  BCF    0C.0
0157:  BCF    0A.3
0158:  GOTO   02C
.................... #int_ccp2 
.................... void isr2() 
.................... { 
.................... if (number_of_timer0_interupts_since_reset>10){ 
0159:  MOVF   47,F
015A:  BTFSS  03.2
015B:  GOTO   160
015C:  MOVF   46,W
015D:  SUBLW  0A
015E:  BTFSC  03.0
015F:  GOTO   173
.................... vSpeed  = 1280 - (number_of_timer0_interupts_since_reset+get_timer0()); 
0160:  MOVF   01,W
0161:  ADDWF  46,W
0162:  MOVWF  21
0163:  MOVF   47,W
0164:  MOVWF  23
0165:  BTFSC  03.0
0166:  INCF   23,F
0167:  MOVF   21,W
0168:  SUBLW  00
0169:  MOVWF  4A
016A:  MOVLW  05
016B:  MOVWF  4B
016C:  MOVF   23,W
016D:  BTFSS  03.0
016E:  INCFSZ 23,W
016F:  SUBWF  4B,F
.................... //vSpeed  = -(get_timer0()); 
.................... set_timer0(0); 
0170:  CLRF   01
.................... number_of_timer0_interupts_since_reset = 0; 
0171:  CLRF   47
0172:  CLRF   46
.................... } 
.................... } 
....................  
0173:  BCF    0D.0
0174:  BCF    0A.3
0175:  GOTO   02C
.................... void trickBreaking(){ 
.................... write_dac((unsigned int16) 400+ELEC_CONTROLLER_OFFSET); 
*
06FD:  MOVLW  05
06FE:  MOVWF  5C
06FF:  MOVLW  14
0700:  MOVWF  5B
0701:  CALL   18E
.................... delay_ms(500);       
0702:  MOVLW  02
0703:  MOVWF  57
0704:  MOVLW  FA
0705:  MOVWF  58
0706:  CALL   2D9
0707:  DECFSZ 57,F
0708:  GOTO   704
.................... } 
0709:  BSF    0A.3
070A:  GOTO   242 (RETURN)
....................  
.................... void main() 
.................... {   
*
0800:  CLRF   04
0801:  MOVLW  1F
0802:  ANDWF  03,F
0803:  BSF    00.0
0804:  BSF    03.5
0805:  BSF    1F.0
0806:  BSF    1F.1
0807:  BSF    1F.2
0808:  BCF    1F.3
0809:  MOVLW  07
080A:  MOVWF  1C
....................     
....................    setup_adc_ports(NO_ANALOGS); 
*
082B:  BSF    03.5
082C:  BSF    1F.0
082D:  BSF    1F.1
082E:  BSF    1F.2
082F:  BCF    1F.3
....................    setup_adc(ADC_OFF); 
0830:  BCF    03.5
0831:  BCF    1F.0
....................    setup_spi(FALSE); 
0832:  CLRF   14
....................     
....................    setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
0833:  BSF    03.5
0834:  MOVF   01,W
0835:  ANDLW  C0
0836:  IORLW  00
0837:  MOVWF  01
0838:  CLRWDT
....................    setup_timer_1(T1_DISABLED); 
0839:  BCF    03.5
083A:  CLRF   10
....................    setup_timer_2(T2_DISABLED,0,1); 
083B:  MOVLW  00
083C:  MOVWF  21
083D:  MOVWF  12
083E:  MOVLW  00
083F:  BSF    03.5
0840:  MOVWF  12
....................    setup_port_a(ALL_ANALOG); 
0841:  BCF    1F.0
0842:  BCF    1F.1
0843:  BCF    1F.2
0844:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
0845:  BCF    1F.6
0846:  BCF    03.5
0847:  BSF    1F.6
0848:  BSF    1F.7
0849:  BSF    03.5
084A:  BSF    1F.7
084B:  BCF    03.5
084C:  BSF    1F.0
....................     
....................    init_dac(); 
084D:  BCF    0A.3
084E:  GOTO   176
084F:  BSF    0A.3
....................   
....................    setup_timer_1(T1_DIV_BY_2| T1_INTERNAL);  
0850:  MOVLW  95
0851:  MOVWF  10
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_128); 
0852:  BSF    03.5
0853:  MOVF   01,W
0854:  ANDLW  C0
0855:  IORLW  06
0856:  MOVWF  01
....................    setup_ccp2(CCP_CAPTURE_RE);    // Configure CCP2 to capture fall 
0857:  BCF    03.5
0858:  BSF    2E.1
0859:  MOVF   2E,W
085A:  BSF    03.5
085B:  MOVWF  07
085C:  BCF    03.5
085D:  CLRF   1D
085E:  MOVLW  05
085F:  MOVWF  1D
....................    enable_interrupts(INT_CCP2);   // Setup interrupt on falling edge 
0860:  BSF    03.5
0861:  BSF    0D.0
....................    enable_interrupts(INT_TIMER0); 
0862:  BCF    03.5
0863:  BSF    0B.5
....................    enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
0864:  BSF    03.5
0865:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
0866:  MOVLW  C0
0867:  BCF    03.5
0868:  IORWF  0B,F
....................     
....................    CHARGING_STATE = EVERYTHING_OFF; 
0869:  CLRF   56
....................    output_low(Electric_Controller_Switch); 
086A:  BSF    03.5
086B:  BCF    06.0
086C:  BCF    03.5
086D:  BCF    06.0
....................    write_dac(0); 
086E:  CLRF   5C
086F:  CLRF   5B
0870:  BCF    0A.3
0871:  CALL   18E
0872:  BSF    0A.3
....................    ICE_ON=TRUE; 
0873:  BSF    2F.4
....................    output_high(Contactor_Switch); 
0874:  BSF    03.5
0875:  BCF    06.2
0876:  BCF    03.5
0877:  BSF    06.2
....................    output_low(brake_pin); 
0878:  BSF    03.5
0879:  BCF    06.4
087A:  BCF    03.5
087B:  BCF    06.4
....................    pid_Init(K_P*SCALING_FACTOR,K_I*SCALING_FACTOR,K_D*SCALING_FACTOR, & pidData); 
087C:  CLRF   58
087D:  MOVLW  80
087E:  MOVWF  57
087F:  CLRF   5A
0880:  CLRF   59
0881:  CLRF   5C
0882:  CLRF   5B
0883:  MOVLW  30
0884:  MOVWF  5D
0885:  BCF    0A.3
0886:  GOTO   1EA
0887:  BSF    0A.3
....................    delay_ms(3000); 
0888:  MOVLW  0C
0889:  MOVWF  57
088A:  MOVLW  FA
088B:  MOVWF  58
088C:  BCF    0A.3
088D:  CALL   2D9
088E:  BSF    0A.3
088F:  DECFSZ 57,F
0890:  GOTO   08A
....................    //write_dac(1000); 
....................    //delay_ms(10000); 
....................    //output_high(Contactor_Switch); 
....................    //output_high(brake_pin); 
....................    //output_high(Electric_Controller_Switch); 
....................    while(TRUE) { 
....................       printf("Check"); 
0891:  CLRF   57
0892:  MOVF   57,W
0893:  BCF    0A.3
0894:  CALL   045
0895:  BSF    0A.3
0896:  INCF   57,F
0897:  MOVWF  20
0898:  MOVWF  58
0899:  BCF    0A.3
089A:  CALL   2EC
089B:  BSF    0A.3
089C:  MOVLW  05
089D:  SUBWF  57,W
089E:  BTFSS  03.2
089F:  GOTO   092
....................       //GET INPUTS 
....................       //Vspeedhappens in interrupts 
....................       delay_ms(150); 
08A0:  MOVLW  96
08A1:  MOVWF  58
08A2:  BCF    0A.3
08A3:  CALL   2D9
08A4:  BSF    0A.3
....................       set_adc_channel(Acaps_channel); 
08A5:  MOVLW  08
08A6:  MOVWF  21
08A7:  MOVF   1F,W
08A8:  ANDLW  C7
08A9:  IORWF  21,W
08AA:  MOVWF  1F
....................       ADC_DELAY; 
08AB:  MOVLW  21
08AC:  MOVWF  20
08AD:  DECFSZ 20,F
08AE:  GOTO   0AD
....................       Acaps = read_adc(); 
08AF:  BSF    1F.2
08B0:  BTFSC  1F.2
08B1:  GOTO   0B0
08B2:  BSF    03.5
08B3:  MOVF   1E,W
08B4:  BCF    03.5
08B5:  MOVWF  52
08B6:  MOVF   1E,W
08B7:  MOVWF  53
....................        
....................       set_adc_channel(Athrottle_channel); 
08B8:  MOVLW  00
08B9:  MOVWF  21
08BA:  MOVF   1F,W
08BB:  ANDLW  C7
08BC:  IORWF  21,W
08BD:  MOVWF  1F
....................       ADC_DELAY; 
08BE:  MOVLW  21
08BF:  MOVWF  20
08C0:  DECFSZ 20,F
08C1:  GOTO   0C0
....................       Athrottle = read_adc(); 
08C2:  BSF    1F.2
08C3:  BTFSC  1F.2
08C4:  GOTO   0C3
08C5:  BSF    03.5
08C6:  MOVF   1E,W
08C7:  BCF    03.5
08C8:  MOVWF  50
08C9:  MOVF   1E,W
08CA:  MOVWF  51
....................       if (Athrottle<Athrottle_Min){ 
08CB:  MOVF   51,W
08CC:  SUBLW  01
08CD:  BTFSS  03.0
08CE:  GOTO   0D9
08CF:  BTFSS  03.2
08D0:  GOTO   0D5
08D1:  MOVF   50,W
08D2:  SUBLW  3B
08D3:  BTFSS  03.0
08D4:  GOTO   0D9
....................          Athrottle=Athrottle_Min; 
08D5:  MOVLW  01
08D6:  MOVWF  51
08D7:  MOVLW  3C
08D8:  MOVWF  50
....................       } 
....................  
....................       //SET THE STATE 
....................       if (Acaps> (A_CAPS_MAX +10)){ 
08D9:  MOVF   53,W
08DA:  SUBLW  01
08DB:  BTFSC  03.0
08DC:  GOTO   100
08DD:  XORLW  FF
08DE:  BTFSS  03.2
08DF:  GOTO   0E4
08E0:  MOVF   52,W
08E1:  SUBLW  DF
08E2:  BTFSC  03.0
08E3:  GOTO   100
....................          //FREAK OUT 
....................          printf("State: Freak Out \n"); 
08E4:  CLRF   57
08E5:  MOVF   57,W
08E6:  BCF    0A.3
08E7:  CALL   04F
08E8:  BSF    0A.3
08E9:  INCF   57,F
08EA:  MOVWF  20
08EB:  MOVWF  58
08EC:  BCF    0A.3
08ED:  CALL   2EC
08EE:  BSF    0A.3
08EF:  MOVLW  12
08F0:  SUBWF  57,W
08F1:  BTFSS  03.2
08F2:  GOTO   0E5
....................          output_low(Electric_Controller_Switch); 
08F3:  BSF    03.5
08F4:  BCF    06.0
08F5:  BCF    03.5
08F6:  BCF    06.0
....................          write_dac(0); 
08F7:  CLRF   5C
08F8:  CLRF   5B
08F9:  BCF    0A.3
08FA:  CALL   18E
08FB:  BSF    0A.3
....................          //ICE_ON = FALSE; 
....................          ICEthrottle = 0; 
08FC:  CLRF   4F
08FD:  CLRF   4E
....................          //output_high(Contactor_Switch); 
....................          CHARGING_STATE =EVERYTHING_OFF; 
08FE:  CLRF   56
....................         //return; 
....................         //break; 
....................       } 
....................       else if (Athrottle<(Athrottle_Min+5)){ 
08FF:  GOTO   1B5
0900:  MOVF   51,W
0901:  SUBLW  01
0902:  BTFSS  03.0
0903:  GOTO   11C
0904:  BTFSS  03.2
0905:  GOTO   10A
0906:  MOVF   50,W
0907:  SUBLW  40
0908:  BTFSS  03.0
0909:  GOTO   11C
....................          CHARGING_STATE = USER_INPUT_OFF; 
090A:  MOVLW  06
090B:  MOVWF  56
....................          printf("State: Throttle Off \n"); 
090C:  CLRF   57
090D:  MOVF   57,W
090E:  BCF    0A.3
090F:  CALL   066
0910:  BSF    0A.3
0911:  INCF   57,F
0912:  MOVWF  20
0913:  MOVWF  58
0914:  BCF    0A.3
0915:  CALL   2EC
0916:  BSF    0A.3
0917:  MOVLW  15
0918:  SUBWF  57,W
0919:  BTFSS  03.2
091A:  GOTO   10D
....................       } 
....................       else if (ICE_ON&&(vSpeed<V_SPEED_REGEN_MIN)){ 
091B:  GOTO   1B5
091C:  BTFSS  2F.4
091D:  GOTO   137
091E:  MOVF   4B,F
091F:  BTFSS  03.2
0920:  GOTO   137
0921:  MOVF   4A,W
0922:  SUBLW  31
0923:  BTFSS  03.0
0924:  GOTO   137
....................          printf("State: Speed To Low \n"); 
0925:  CLRF   57
0926:  MOVF   57,W
0927:  BCF    0A.3
0928:  CALL   080
0929:  BSF    0A.3
092A:  INCF   57,F
092B:  MOVWF  20
092C:  MOVWF  58
092D:  BCF    0A.3
092E:  CALL   2EC
092F:  BSF    0A.3
0930:  MOVLW  15
0931:  SUBWF  57,W
0932:  BTFSS  03.2
0933:  GOTO   126
....................          CHARGING_STATE=SPEED_TO_LOW_ICE_DIRECT; 
0934:  MOVLW  01
0935:  MOVWF  56
....................       } 
....................       else if (checkRunnaway(& pidData)){// INSUFFICIENT_BRAKING_RUNNAWAY_ERROR){ 
0936:  GOTO   1B5
0937:  MOVLW  30
0938:  MOVWF  57
0939:  BCF    0A.3
093A:  GOTO   2EE
093B:  BSF    0A.3
093C:  MOVF   21,F
093D:  BTFSC  03.2
093E:  GOTO   152
....................          printf("State: RUNNAWAY \n"); 
093F:  CLRF   57
0940:  MOVF   57,W
0941:  BCF    0A.3
0942:  CALL   09A
0943:  BSF    0A.3
0944:  INCF   57,F
0945:  MOVWF  20
0946:  MOVWF  58
0947:  BCF    0A.3
0948:  CALL   2EC
0949:  BSF    0A.3
094A:  MOVLW  11
094B:  SUBWF  57,W
094C:  BTFSS  03.2
094D:  GOTO   140
....................          ICE_ON=TRUE; 
094E:  BSF    2F.4
....................          CHARGING_STATE=INSUFFICIENT_BRAKING_RUNAWAY; 
094F:  MOVLW  05
0950:  MOVWF  56
....................       } 
....................       else if ((Acaps > A_CAPS_MAX)&&(CHARGING_STATE==CHARGING_ALLOWED||CHARGING_STATE==CHARGING_AND_DISCHARING_ALLOWED)){ 
0951:  GOTO   1B5
0952:  MOVF   53,W
0953:  SUBLW  01
0954:  BTFSC  03.0
0955:  GOTO   178
0956:  XORLW  FF
0957:  BTFSS  03.2
0958:  GOTO   15D
0959:  MOVF   52,W
095A:  SUBLW  D5
095B:  BTFSC  03.0
095C:  GOTO   178
095D:  MOVF   56,W
095E:  SUBLW  02
095F:  BTFSC  03.2
0960:  GOTO   165
0961:  MOVF   56,W
0962:  SUBLW  04
0963:  BTFSS  03.2
0964:  GOTO   178
....................          //Stop Charging they are full 
....................          printf("State: Caps Full \n"); 
0965:  CLRF   57
0966:  MOVF   57,W
0967:  BCF    0A.3
0968:  CALL   0B0
0969:  BSF    0A.3
096A:  INCF   57,F
096B:  MOVWF  20
096C:  MOVWF  58
096D:  BCF    0A.3
096E:  CALL   2EC
096F:  BSF    0A.3
0970:  MOVLW  12
0971:  SUBWF  57,W
0972:  BTFSS  03.2
0973:  GOTO   166
....................         ICE_ON=FALSE; 
0974:  BCF    2F.4
....................         CHARGING_STATE=DISCHARGING_ALLOWED; 
0975:  MOVLW  03
0976:  MOVWF  56
....................       } 
....................       else if ((Acaps < A_CAPS_MIN)&& CHARGING_STATE!=CHARGING_ALLOWED){ 
0977:  GOTO   1B5
0978:  MOVF   53,W
0979:  SUBLW  01
097A:  BTFSS  03.0
097B:  GOTO   199
097C:  BTFSS  03.2
097D:  GOTO   182
097E:  MOVF   52,W
097F:  SUBLW  4E
0980:  BTFSS  03.0
0981:  GOTO   199
0982:  MOVF   56,W
0983:  SUBLW  02
0984:  BTFSC  03.2
0985:  GOTO   199
....................          //Stop running electric, the caps are almost empty 
....................         printf("State: Caps Empty \n"); 
0986:  CLRF   57
0987:  MOVF   57,W
0988:  BCF    0A.3
0989:  CALL   0C7
098A:  BSF    0A.3
098B:  INCF   57,F
098C:  MOVWF  20
098D:  MOVWF  58
098E:  BCF    0A.3
098F:  CALL   2EC
0990:  BSF    0A.3
0991:  MOVLW  13
0992:  SUBWF  57,W
0993:  BTFSS  03.2
0994:  GOTO   187
....................         ICE_ON=TRUE; 
0995:  BSF    2F.4
....................         CHARGING_STATE=CHARGING_ALLOWED; 
0996:  MOVLW  02
0997:  MOVWF  56
....................       } 
....................      else if (A_CAPS_MID_LOW < Acaps < A_CAPS_MID_HIGH){ 
0998:  GOTO   1B5
0999:  MOVF   53,W
099A:  SUBLW  00
099B:  BTFSC  03.0
099C:  GOTO   1A3
099D:  XORLW  FF
099E:  BTFSS  03.2
099F:  GOTO   1A4
09A0:  MOVF   52,W
09A1:  SUBLW  B3
09A2:  BTFSC  03.0
09A3:  MOVLW  00
....................         printf("State: Normal \n"); 
09A4:  CLRF   57
09A5:  MOVF   57,W
09A6:  BCF    0A.3
09A7:  CALL   0DF
09A8:  BSF    0A.3
09A9:  INCF   57,F
09AA:  MOVWF  20
09AB:  MOVWF  58
09AC:  BCF    0A.3
09AD:  CALL   2EC
09AE:  BSF    0A.3
09AF:  MOVLW  0F
09B0:  SUBWF  57,W
09B1:  BTFSS  03.2
09B2:  GOTO   1A5
....................         CHARGING_STATE=CHARGING_AND_DISCHARING_ALLOWED; 
09B3:  MOVLW  04
09B4:  MOVWF  56
....................      } 
....................       
....................       
.................... //PID CONTROLLER 
....................       //Servo to mirror Athrottle ->  
....................       //current_servo_position=right_position-(Athrottle-Athrottle_Min)*Athrottle_servo_factor;//(Athrottle/Athrottle_Full)*servo_difference;//(vSpeed/65536.0)*(2500); 
....................       ////printf("Analog Cap %d Analog Throttle %Lu\n",(int) Acaps,Athrottle); 
....................       //current_servo_position =right_position-vSpeed+200; 
....................       ////printf("Speed %lu \n",speeder); 
....................       //SET OUTPUTS  
....................       //The writing of the ICEThrottle happens in interupts and all that is 
....................       //required is updating ICEthrottle 
....................       ////printf("speed before %ld \n",vSpeed); 
....................        
....................       returnedValue = pid_Controller((Athrottle-AThrottle_Min),vSpeed,& pidData); 
09B5:  MOVLW  3C
09B6:  SUBWF  50,W
09B7:  MOVWF  57
09B8:  MOVF   51,W
09B9:  MOVWF  58
09BA:  MOVLW  01
09BB:  BTFSS  03.0
09BC:  MOVLW  02
09BD:  SUBWF  58,F
09BE:  MOVF   58,W
09BF:  MOVWF  5A
09C0:  MOVF   57,W
09C1:  MOVWF  59
09C2:  MOVF   4B,W
09C3:  MOVWF  5C
09C4:  MOVF   4A,W
09C5:  MOVWF  5B
09C6:  MOVLW  30
09C7:  MOVWF  5D
09C8:  BCF    0A.3
09C9:  GOTO   2F2
09CA:  BSF    0A.3
09CB:  MOVF   22,W
09CC:  MOVWF  55
09CD:  MOVF   21,W
09CE:  MOVWF  54
....................       ELECthrottle = ELECthrottle+returnedValue; 
09CF:  MOVF   54,W
09D0:  ADDWF  4C,F
09D1:  MOVF   55,W
09D2:  BTFSC  03.0
09D3:  INCFSZ 55,W
09D4:  ADDWF  4D,F
....................       
....................       
....................       if (ELECthrottle>2500){ 
09D5:  BTFSC  4D.7
09D6:  GOTO   1E7
09D7:  MOVF   4D,W
09D8:  SUBLW  08
09D9:  BTFSC  03.0
09DA:  GOTO   1E7
09DB:  XORLW  FF
09DC:  BTFSS  03.2
09DD:  GOTO   1E2
09DE:  MOVF   4C,W
09DF:  SUBLW  C4
09E0:  BTFSC  03.0
09E1:  GOTO   1E7
....................          ELECthrottle=2500; 
09E2:  MOVLW  09
09E3:  MOVWF  4D
09E4:  MOVLW  C4
09E5:  MOVWF  4C
....................       } 
....................       else if (ELECthrottle<-500){ 
09E6:  GOTO   1F7
09E7:  BTFSS  4D.7
09E8:  GOTO   1F7
09E9:  MOVF   4D,W
09EA:  SUBLW  FE
09EB:  BTFSS  03.0
09EC:  GOTO   1F7
09ED:  BTFSS  03.2
09EE:  GOTO   1F3
09EF:  MOVF   4C,W
09F0:  SUBLW  0B
09F1:  BTFSS  03.0
09F2:  GOTO   1F7
....................          ELECthrottle = -500; 
09F3:  MOVLW  FE
09F4:  MOVWF  4D
09F5:  MOVLW  0C
09F6:  MOVWF  4C
....................       } 
....................        
....................        
....................       //SET OUTPUTS 
....................       if (CHARGING_STATE==EVERYTHING_OFF||CHARGING_STATE==USER_INPUT_OFF){ 
09F7:  MOVF   56,F
09F8:  BTFSC  03.2
09F9:  GOTO   1FE
09FA:  MOVF   56,W
09FB:  SUBLW  06
09FC:  BTFSS  03.2
09FD:  GOTO   20B
....................          ICEthrottle = 0; 
09FE:  CLRF   4F
09FF:  CLRF   4E
....................          ICE_ON = FALSE; 
0A00:  BCF    2F.4
....................          current_servo_position =right_position; 
0A01:  MOVLW  14
0A02:  MOVWF  43
0A03:  MOVLW  B4
0A04:  MOVWF  42
....................          write_dac(0); 
0A05:  CLRF   5C
0A06:  CLRF   5B
0A07:  BCF    0A.3
0A08:  CALL   18E
0A09:  BSF    0A.3
....................       } 
....................       else if (CHARGING_STATE==SPEED_TO_LOW_ICE_DIRECT || CHARGING_STATE==INSUFFICIENT_BRAKING_RUNAWAY){ 
0A0A:  GOTO   2B7
0A0B:  DECFSZ 56,W
0A0C:  GOTO   20E
0A0D:  GOTO   212
0A0E:  MOVF   56,W
0A0F:  SUBLW  05
0A10:  BTFSS  03.2
0A11:  GOTO   234
....................          if (ELECthrottle>0){ 
0A12:  BTFSC  4D.7
0A13:  GOTO   229
0A14:  MOVF   4D,F
0A15:  BTFSS  03.2
0A16:  GOTO   21B
0A17:  MOVF   4C,W
0A18:  SUBLW  00
0A19:  BTFSC  03.0
0A1A:  GOTO   229
....................             current_servo_position =right_position- (ELECthrottle); 
0A1B:  MOVF   4C,W
0A1C:  SUBLW  B4
0A1D:  MOVWF  20
0A1E:  MOVLW  14
0A1F:  MOVWF  23
0A20:  MOVF   4D,W
0A21:  BTFSS  03.0
0A22:  INCFSZ 4D,W
0A23:  SUBWF  23,F
0A24:  MOVF   20,W
0A25:  MOVWF  42
0A26:  MOVF   23,W
0A27:  MOVWF  43
....................          } 
....................          else{ 
0A28:  GOTO   22D
....................             current_servo_position =right_position; 
0A29:  MOVLW  14
0A2A:  MOVWF  43
0A2B:  MOVLW  B4
0A2C:  MOVWF  42
....................          } 
....................          ICE_ON = TRUE; 
0A2D:  BSF    2F.4
....................          write_dac(0); 
0A2E:  CLRF   5C
0A2F:  CLRF   5B
0A30:  BCF    0A.3
0A31:  CALL   18E
0A32:  BSF    0A.3
....................       } 
....................       else{ 
0A33:  GOTO   2B7
....................       if (ELECthrottle<0){ 
0A34:  BTFSS  4D.7
0A35:  GOTO   274
....................         if (CHARGING_STATE==CHARGING_ALLOWED || CHARGING_STATE ==CHARGING_AND_DISCHARING_ALLOWED){ 
0A36:  MOVF   56,W
0A37:  SUBLW  02
0A38:  BTFSC  03.2
0A39:  GOTO   23E
0A3A:  MOVF   56,W
0A3B:  SUBLW  04
0A3C:  BTFSS  03.2
0A3D:  GOTO   26E
....................              if (CURRENTLY_CHARGING==1){ 
0A3E:  BTFSS  2F.5
0A3F:  GOTO   243
....................                 trickBreaking(); 
0A40:  BCF    0A.3
0A41:  GOTO   6FD
0A42:  BSF    0A.3
....................              } 
....................              //ELECthrottle = 300; 
....................              CURRENTLY_CHARGING=0; 
0A43:  BCF    2F.5
....................              output_high(brake_pin); 
0A44:  BSF    03.5
0A45:  BCF    06.4
0A46:  BCF    03.5
0A47:  BSF    06.4
....................              output_high(Electric_Controller_Switch); 
0A48:  BSF    03.5
0A49:  BCF    06.0
0A4A:  BCF    03.5
0A4B:  BSF    06.0
....................              //printf("BREAKING \n"); 
....................              write_dac((abs(ELECthrottle)+ELEC_CONTROLLER_OFFSET)); 
0A4C:  MOVF   4D,W
0A4D:  MOVWF  23
0A4E:  MOVF   4C,W
0A4F:  BTFSS  4D.7
0A50:  GOTO   25A
0A51:  MOVF   4C,W
0A52:  SUBLW  00
0A53:  MOVWF  20
0A54:  CLRF   23
0A55:  MOVF   4D,W
0A56:  BTFSS  03.0
0A57:  INCFSZ 4D,W
0A58:  SUBWF  23,F
0A59:  MOVF   20,W
0A5A:  MOVWF  57
0A5B:  MOVF   23,W
0A5C:  MOVWF  58
0A5D:  MOVLW  84
0A5E:  ADDWF  57,W
0A5F:  MOVWF  59
0A60:  MOVF   58,W
0A61:  MOVWF  5A
0A62:  MOVLW  03
0A63:  BTFSC  03.0
0A64:  MOVLW  04
0A65:  ADDWF  5A,F
0A66:  MOVF   5A,W
0A67:  MOVWF  5C
0A68:  MOVF   59,W
0A69:  MOVWF  5B
0A6A:  BCF    0A.3
0A6B:  CALL   18E
0A6C:  BSF    0A.3
....................         } 
....................         else{ 
0A6D:  GOTO   273
....................            //Decrease ICE throttle 
....................            write_dac(0); 
0A6E:  CLRF   5C
0A6F:  CLRF   5B
0A70:  BCF    0A.3
0A71:  CALL   18E
0A72:  BSF    0A.3
....................        
....................         } 
....................       } 
....................       else { 
0A73:  GOTO   2AC
....................         if (CHARGING_STATE==DISCHARGING_ALLOWED || CHARGING_STATE ==CHARGING_AND_DISCHARING_ALLOWED){ 
0A74:  MOVF   56,W
0A75:  SUBLW  03
0A76:  BTFSC  03.2
0A77:  GOTO   27C
0A78:  MOVF   56,W
0A79:  SUBLW  04
0A7A:  BTFSS  03.2
0A7B:  GOTO   2A7
....................              CURRENTLY_CHARGING=1; 
0A7C:  BSF    2F.5
....................              output_low(brake_pin); 
0A7D:  BSF    03.5
0A7E:  BCF    06.4
0A7F:  BCF    03.5
0A80:  BCF    06.4
....................              output_low(Electric_Controller_Switch); 
0A81:  BSF    03.5
0A82:  BCF    06.0
0A83:  BCF    03.5
0A84:  BCF    06.0
....................              //printf("ACCELERATING \n"); 
....................              write_dac((abs(ELECthrottle)+ELEC_CONTROLLER_OFFSET)); 
0A85:  MOVF   4D,W
0A86:  MOVWF  23
0A87:  MOVF   4C,W
0A88:  BTFSS  4D.7
0A89:  GOTO   293
0A8A:  MOVF   4C,W
0A8B:  SUBLW  00
0A8C:  MOVWF  20
0A8D:  CLRF   23
0A8E:  MOVF   4D,W
0A8F:  BTFSS  03.0
0A90:  INCFSZ 4D,W
0A91:  SUBWF  23,F
0A92:  MOVF   20,W
0A93:  MOVWF  57
0A94:  MOVF   23,W
0A95:  MOVWF  58
0A96:  MOVLW  84
0A97:  ADDWF  57,W
0A98:  MOVWF  59
0A99:  MOVF   58,W
0A9A:  MOVWF  5A
0A9B:  MOVLW  03
0A9C:  BTFSC  03.0
0A9D:  MOVLW  04
0A9E:  ADDWF  5A,F
0A9F:  MOVF   5A,W
0AA0:  MOVWF  5C
0AA1:  MOVF   59,W
0AA2:  MOVWF  5B
0AA3:  BCF    0A.3
0AA4:  CALL   18E
0AA5:  BSF    0A.3
....................         } 
....................         else{ 
0AA6:  GOTO   2AC
....................            //Increase ICE throttle 
....................            write_dac(0); 
0AA7:  CLRF   5C
0AA8:  CLRF   5B
0AA9:  BCF    0A.3
0AAA:  CALL   18E
0AAB:  BSF    0A.3
....................        
....................         } 
....................           
....................       } 
....................       if (ICE_ON){ 
0AAC:  BTFSS  2F.4
0AAD:  GOTO   2B3
....................          //printf("ICE NORMAL \n"); 
....................          current_servo_position =right_position-800; 
0AAE:  MOVLW  11
0AAF:  MOVWF  43
0AB0:  MOVLW  94
0AB1:  MOVWF  42
....................       } 
....................       else{ 
0AB2:  GOTO   2B7
....................          current_servo_position =right_position; 
0AB3:  MOVLW  14
0AB4:  MOVWF  43
0AB5:  MOVLW  B4
0AB6:  MOVWF  42
....................          //printf("ICE OFF \n"); 
....................       } 
....................       } 
....................             
....................    } 
0AB7:  GOTO   091
....................     
....................  
.................... } 
....................  
.................... boolean checkRunnaway(struct PID_DATA *pid) 
.................... { 
0AB8:  SLEEP
.................... //return (pid->sumError > INSUFFICIENT_BRAKING_RUNNAWAY_ERROR); 
.................... return FALSE; 
*
02EE:  MOVLW  00
02EF:  MOVWF  21
.................... } 
02F0:  BSF    0A.3
02F1:  GOTO   13B (RETURN)
....................  
.................... /*! \brief Initialisation of PID controller parameters. 
....................  * 
....................  *  Initialise the variables used by the PID algorithm. 
....................  * 
....................  *  \param p_factor  Proportional term. 
....................  *  \param i_factor  Integral term. 
....................  *  \param d_factor  Derivate term. 
....................  *  \param pid  Struct with PID status. 
....................  */ 
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid) 
.................... // Set up PID controller parameters 
.................... { 
....................   // Start values for PID controller 
....................   pid->sumError = 0; 
*
01EA:  MOVLW  02
01EB:  ADDWF  5D,W
01EC:  MOVWF  04
01ED:  INCF   04,F
01EE:  INCF   04,F
01EF:  INCF   04,F
01F0:  CLRF   00
01F1:  DECF   04,F
01F2:  CLRF   00
01F3:  DECF   04,F
01F4:  CLRF   00
01F5:  DECF   04,F
01F6:  CLRF   00
....................   pid->lastProcessValue = 0; 
01F7:  MOVF   5D,W
01F8:  MOVWF  04
01F9:  INCF   04,F
01FA:  CLRF   00
01FB:  DECF   04,F
01FC:  CLRF   00
....................   // Tuning constants for PID loop 
....................   pid->P_Factor = p_factor; 
01FD:  MOVLW  06
01FE:  ADDWF  5D,W
01FF:  MOVWF  04
0200:  INCF   04,F
0201:  MOVF   58,W
0202:  MOVWF  00
0203:  DECF   04,F
0204:  MOVF   57,W
0205:  MOVWF  00
....................   pid->I_Factor = i_factor; 
0206:  MOVLW  08
0207:  ADDWF  5D,W
0208:  MOVWF  04
0209:  INCF   04,F
020A:  MOVF   5A,W
020B:  MOVWF  00
020C:  DECF   04,F
020D:  MOVF   59,W
020E:  MOVWF  00
....................   pid->D_Factor = d_factor; 
020F:  MOVLW  0A
0210:  ADDWF  5D,W
0211:  MOVWF  04
0212:  INCF   04,F
0213:  MOVF   5C,W
0214:  MOVWF  00
0215:  DECF   04,F
0216:  MOVF   5B,W
0217:  MOVWF  00
....................   // Limits to avoid overflow 
....................   pid->maxError = MAX_INT / (pid->P_Factor + 1); 
0218:  MOVLW  0C
0219:  ADDWF  5D,W
021A:  MOVWF  5E
021B:  MOVLW  06
021C:  ADDWF  5D,W
021D:  MOVWF  04
021E:  INCF   04,F
021F:  MOVF   00,W
0220:  MOVWF  60
0221:  DECF   04,F
0222:  MOVF   00,W
0223:  MOVWF  5F
0224:  MOVLW  01
0225:  ADDWF  5F,W
0226:  MOVWF  21
0227:  MOVF   60,W
0228:  MOVWF  23
0229:  BTFSC  03.0
022A:  INCF   23,F
022B:  MOVF   21,W
022C:  MOVWF  61
022D:  MOVF   23,W
022E:  MOVWF  62
022F:  MOVLW  7F
0230:  MOVWF  64
0231:  MOVLW  FF
0232:  MOVWF  63
0233:  MOVF   62,W
0234:  MOVWF  66
0235:  MOVF   61,W
0236:  MOVWF  65
*
025B:  MOVF   5E,W
025C:  MOVWF  04
025D:  INCF   04,F
025E:  MOVF   22,W
025F:  MOVWF  00
0260:  DECF   04,F
0261:  MOVF   21,W
0262:  MOVWF  00
....................   ////printf("Max %ld factor %ld and pid %ld",MAX_INT,pid->I_Factor,pid->maxError); 
....................   pid->maxSumError = MAX_I_TERM / (pid->I_Factor + 1); 
0263:  MOVLW  0E
0264:  ADDWF  5D,W
0265:  MOVWF  5E
0266:  MOVLW  08
0267:  ADDWF  5D,W
0268:  MOVWF  04
0269:  INCF   04,F
026A:  MOVF   00,W
026B:  MOVWF  60
026C:  DECF   04,F
026D:  MOVF   00,W
026E:  MOVWF  5F
026F:  MOVLW  01
0270:  ADDWF  5F,W
0271:  MOVWF  21
0272:  MOVF   60,W
0273:  MOVWF  23
0274:  BTFSC  03.0
0275:  INCF   23,F
0276:  MOVF   21,W
0277:  MOVWF  61
0278:  MOVF   23,W
0279:  MOVWF  62
027A:  MOVF   04,W
027B:  MOVWF  63
027C:  MOVLW  3F
027D:  MOVWF  67
027E:  MOVLW  FF
027F:  MOVWF  66
0280:  MOVWF  65
0281:  MOVWF  64
0282:  CLRF   6B
0283:  CLRF   6A
0284:  MOVF   62,W
0285:  MOVWF  69
0286:  MOVF   61,W
0287:  MOVWF  68
*
02C8:  MOVF   63,W
02C9:  MOVWF  04
02CA:  MOVF   5E,W
02CB:  MOVWF  04
02CC:  MOVF   20,W
02CD:  MOVWF  00
02CE:  INCF   04,F
02CF:  MOVF   21,W
02D0:  MOVWF  00
02D1:  INCF   04,F
02D2:  MOVF   22,W
02D3:  MOVWF  00
02D4:  INCF   04,F
02D5:  MOVF   23,W
02D6:  MOVWF  00
.................... } 
02D7:  BSF    0A.3
02D8:  GOTO   087 (RETURN)
....................  
....................  
.................... /*! \brief PID control algorithm. 
....................  * 
....................  *  Calculates output from setpoint, process value and PID status. 
....................  * 
....................  *  \param setPoint  Desired value. 
....................  *  \param processValue  Measured value. 
....................  *  \param pid_st  PID status struct. 
....................  */ 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st) 
.................... { 
....................   signed int16 error, p_term, d_term; 
....................   signed int32 i_term, ret, temp; 
....................     processValue=processValue/4; 
*
02F2:  RRF    5C,F
02F3:  RRF    5B,F
02F4:  RRF    5C,F
02F5:  RRF    5B,F
02F6:  MOVLW  3F
02F7:  ANDWF  5C,F
....................   ////printf("input %ld speed %ld ",setPoint,processValue); 
....................   error = setPoint - processValue; 
02F8:  MOVF   5B,W
02F9:  SUBWF  59,W
02FA:  MOVWF  20
02FB:  MOVF   5A,W
02FC:  MOVWF  23
02FD:  MOVF   5C,W
02FE:  BTFSS  03.0
02FF:  INCFSZ 5C,W
0300:  SUBWF  23,F
0301:  MOVF   20,W
0302:  MOVWF  5E
0303:  MOVF   23,W
0304:  MOVWF  5F
....................    
....................   // Calculate Pterm and limit error overflow 
....................    
....................   if (error > (signed int16) pid_st->maxError){ 
0305:  MOVLW  0C
0306:  ADDWF  5D,W
0307:  MOVWF  04
0308:  INCF   04,F
0309:  MOVF   00,W
030A:  MOVWF  23
030B:  DECF   04,F
030C:  MOVF   00,W
030D:  MOVWF  21
030E:  BTFSS  23.7
030F:  GOTO   313
0310:  BTFSS  5F.7
0311:  GOTO   31F
0312:  GOTO   315
0313:  BTFSC  5F.7
0314:  GOTO   324
0315:  MOVF   23,W
0316:  SUBWF  5F,W
0317:  BTFSS  03.0
0318:  GOTO   324
0319:  BTFSS  03.2
031A:  GOTO   31F
031B:  MOVF   5E,W
031C:  SUBWF  21,W
031D:  BTFSC  03.0
031E:  GOTO   324
....................     p_term = MAX_INT; 
031F:  MOVLW  7F
0320:  MOVWF  61
0321:  MOVLW  FF
0322:  MOVWF  60
....................     ////printf("p greater error %ld a %ld p %ld",error,pid_st->maxError,p_term); 
....................  
....................   } 
....................   else if (error < (signed int16) -pid_st->maxError){ 
0323:  GOTO   484
0324:  MOVLW  0C
0325:  ADDWF  5D,W
0326:  MOVWF  04
0327:  INCF   04,F
0328:  MOVF   00,W
0329:  MOVWF  23
032A:  DECF   04,F
032B:  MOVF   00,W
032C:  SUBLW  00
032D:  MOVWF  20
032E:  MOVF   23,W
032F:  BTFSS  03.0
0330:  INCFSZ 23,W
0331:  GOTO   334
0332:  MOVLW  00
0333:  GOTO   335
0334:  SUBLW  00
0335:  MOVWF  23
0336:  MOVF   20,W
0337:  MOVWF  21
0338:  BTFSS  5F.7
0339:  GOTO   33D
033A:  BTFSS  23.7
033B:  GOTO   349
033C:  GOTO   33F
033D:  BTFSC  23.7
033E:  GOTO   34E
033F:  MOVF   5F,W
0340:  SUBWF  23,W
0341:  BTFSS  03.0
0342:  GOTO   34E
0343:  BTFSS  03.2
0344:  GOTO   349
0345:  MOVF   21,W
0346:  SUBWF  5E,W
0347:  BTFSC  03.0
0348:  GOTO   34E
....................     p_term = -MAX_INT; 
0349:  MOVLW  80
034A:  MOVWF  61
034B:  MOVLW  01
034C:  MOVWF  60
....................     ////printf("p less error %ld a %ld p %ld",error,-pid_st->maxError,p_term); 
....................  
....................   } 
....................   else{ 
034D:  GOTO   484
....................     p_term = (signed int16) (pid_st->P_Factor * (float) error); 
034E:  MOVLW  06
034F:  ADDWF  5D,W
0350:  MOVWF  04
0351:  INCF   04,F
0352:  MOVF   00,W
0353:  MOVWF  71
0354:  DECF   04,F
0355:  MOVF   00,W
0356:  MOVWF  70
0357:  MOVF   5F,W
0358:  MOVWF  73
0359:  MOVF   5E,W
035A:  MOVWF  72
*
037F:  MOVF   20,W
0380:  MOVWF  72
0381:  MOVF   21,W
0382:  MOVWF  73
0383:  MOVF   22,W
0384:  MOVWF  74
0385:  MOVF   23,W
0386:  MOVWF  75
0387:  MOVF   71,W
0388:  MOVWF  77
0389:  MOVF   70,W
038A:  MOVWF  76
*
03A7:  MOVF   23,W
03A8:  MOVWF  79
03A9:  MOVF   22,W
03AA:  MOVWF  78
03AB:  MOVF   21,W
03AC:  MOVWF  77
03AD:  MOVF   20,W
03AE:  MOVWF  76
03AF:  MOVF   75,W
03B0:  MOVWF  7D
03B1:  MOVF   74,W
03B2:  MOVWF  7C
03B3:  MOVF   73,W
03B4:  MOVWF  7B
03B5:  MOVF   72,W
03B6:  MOVWF  7A
*
045A:  MOVF   23,W
045B:  MOVWF  79
045C:  MOVF   22,W
045D:  MOVWF  78
045E:  MOVF   21,W
045F:  MOVWF  77
0460:  MOVF   20,W
0461:  MOVWF  76
*
0480:  MOVF   22,W
0481:  MOVWF  61
0482:  MOVF   21,W
0483:  MOVWF  60
....................     ////printf("error %ld a %ld p %ld",error,pid_st->maxError,p_term); 
....................   } 
....................    
....................   // Calculate Iterm and limit integral runaway 
....................   temp = pid_st->sumError + error; 
0484:  MOVLW  02
0485:  ADDWF  5D,W
0486:  MOVWF  04
0487:  MOVF   00,W
0488:  MOVWF  70
0489:  INCF   04,F
048A:  MOVF   00,W
048B:  MOVWF  71
048C:  INCF   04,F
048D:  MOVF   00,W
048E:  MOVWF  72
048F:  INCF   04,F
0490:  MOVF   00,W
0491:  MOVWF  73
0492:  MOVF   5E,W
0493:  MOVWF  20
0494:  MOVF   5F,W
0495:  MOVWF  21
0496:  CLRF   22
0497:  CLRF   23
0498:  BTFSS  5F.7
0499:  GOTO   49C
049A:  DECF   22,F
049B:  DECF   23,F
049C:  MOVF   20,W
049D:  ADDWF  70,W
049E:  MOVWF  6C
049F:  MOVF   71,W
04A0:  MOVWF  6D
04A1:  MOVF   21,W
04A2:  BTFSC  03.0
04A3:  INCFSZ 21,W
04A4:  ADDWF  6D,F
04A5:  MOVF   72,W
04A6:  MOVWF  6E
04A7:  MOVF   22,W
04A8:  BTFSC  03.0
04A9:  INCFSZ 22,W
04AA:  ADDWF  6E,F
04AB:  MOVF   73,W
04AC:  MOVWF  6F
04AD:  MOVF   23,W
04AE:  BTFSC  03.0
04AF:  INCFSZ 23,W
04B0:  ADDWF  6F,F
....................   if(temp > (signed int32)pid_st->maxSumError){ 
04B1:  MOVLW  0E
04B2:  ADDWF  5D,W
04B3:  MOVWF  04
04B4:  MOVF   00,W
04B5:  MOVWF  20
04B6:  INCF   04,F
04B7:  MOVF   00,W
04B8:  MOVWF  21
04B9:  INCF   04,F
04BA:  MOVF   00,W
04BB:  MOVWF  22
04BC:  INCF   04,F
04BD:  MOVF   00,W
04BE:  MOVWF  23
04BF:  BTFSS  23.7
04C0:  GOTO   4C4
04C1:  BTFSS  6F.7
04C2:  GOTO   4DC
04C3:  GOTO   4C6
04C4:  BTFSC  6F.7
04C5:  GOTO   501
04C6:  MOVF   23,W
04C7:  SUBWF  6F,W
04C8:  BTFSS  03.0
04C9:  GOTO   501
04CA:  BTFSS  03.2
04CB:  GOTO   4DC
04CC:  MOVF   22,W
04CD:  SUBWF  6E,W
04CE:  BTFSS  03.0
04CF:  GOTO   501
04D0:  BTFSS  03.2
04D1:  GOTO   4DC
04D2:  MOVF   21,W
04D3:  SUBWF  6D,W
04D4:  BTFSS  03.0
04D5:  GOTO   501
04D6:  BTFSS  03.2
04D7:  GOTO   4DC
04D8:  MOVF   6C,W
04D9:  SUBWF  20,W
04DA:  BTFSC  03.0
04DB:  GOTO   501
....................     i_term = MAX_I_TERM; 
04DC:  MOVLW  3F
04DD:  MOVWF  67
04DE:  MOVLW  FF
04DF:  MOVWF  66
04E0:  MOVWF  65
04E1:  MOVWF  64
....................     pid_st->sumError = pid_st->maxSumError; 
04E2:  MOVLW  02
04E3:  ADDWF  5D,W
04E4:  MOVWF  70
04E5:  MOVLW  0E
04E6:  ADDWF  5D,W
04E7:  MOVWF  04
04E8:  MOVF   00,W
04E9:  MOVWF  20
04EA:  INCF   04,F
04EB:  MOVF   00,W
04EC:  MOVWF  21
04ED:  INCF   04,F
04EE:  MOVF   00,W
04EF:  MOVWF  22
04F0:  INCF   04,F
04F1:  MOVF   00,W
04F2:  MOVWF  23
04F3:  MOVF   70,W
04F4:  MOVWF  04
04F5:  MOVF   20,W
04F6:  MOVWF  00
04F7:  INCF   04,F
04F8:  MOVF   21,W
04F9:  MOVWF  00
04FA:  INCF   04,F
04FB:  MOVF   22,W
04FC:  MOVWF  00
04FD:  INCF   04,F
04FE:  MOVF   23,W
04FF:  MOVWF  00
....................     ////printf("\n greater temp %ld a %ld sum %ld",temp,pid_st->maxSumError,pid_st->sumError); 
....................  
....................  } 
....................   else if(temp < (signed int32)-pid_st->maxSumError){ 
0500:  GOTO   615
0501:  MOVLW  0E
0502:  ADDWF  5D,W
0503:  MOVWF  04
0504:  MOVF   00,W
0505:  MOVWF  20
0506:  INCF   04,F
0507:  MOVF   00,W
0508:  MOVWF  21
0509:  INCF   04,F
050A:  MOVF   00,W
050B:  MOVWF  22
050C:  INCF   04,F
050D:  MOVF   00,W
050E:  MOVWF  23
050F:  MOVLW  FD
0510:  ADDWF  04,F
0511:  MOVF   20,W
0512:  SUBLW  00
0513:  MOVWF  20
0514:  MOVF   21,W
0515:  BTFSS  03.0
0516:  INCFSZ 21,W
0517:  GOTO   51A
0518:  MOVLW  00
0519:  GOTO   51B
051A:  SUBLW  00
051B:  MOVWF  21
051C:  MOVF   22,W
051D:  BTFSS  03.0
051E:  INCFSZ 22,W
051F:  GOTO   522
0520:  MOVLW  00
0521:  GOTO   523
0522:  SUBLW  00
0523:  MOVWF  22
0524:  MOVF   23,W
0525:  BTFSS  03.0
0526:  INCFSZ 23,W
0527:  GOTO   52A
0528:  MOVLW  00
0529:  GOTO   52B
052A:  SUBLW  00
052B:  MOVWF  23
052C:  BTFSS  6F.7
052D:  GOTO   531
052E:  BTFSS  23.7
052F:  GOTO   549
0530:  GOTO   533
0531:  BTFSC  23.7
0532:  GOTO   58C
0533:  MOVF   6F,W
0534:  SUBWF  23,W
0535:  BTFSS  03.0
0536:  GOTO   58C
0537:  BTFSS  03.2
0538:  GOTO   549
0539:  MOVF   6E,W
053A:  SUBWF  22,W
053B:  BTFSS  03.0
053C:  GOTO   58C
053D:  BTFSS  03.2
053E:  GOTO   549
053F:  MOVF   6D,W
0540:  SUBWF  21,W
0541:  BTFSS  03.0
0542:  GOTO   58C
0543:  BTFSS  03.2
0544:  GOTO   549
0545:  MOVF   20,W
0546:  SUBWF  6C,W
0547:  BTFSC  03.0
0548:  GOTO   58C
....................     i_term = -MAX_I_TERM; 
0549:  MOVLW  C0
054A:  MOVWF  67
054B:  CLRF   66
054C:  CLRF   65
054D:  MOVLW  01
054E:  MOVWF  64
....................     pid_st->sumError = -pid_st->maxSumError; 
054F:  MOVLW  02
0550:  ADDWF  5D,W
0551:  MOVWF  70
0552:  MOVLW  0E
0553:  ADDWF  5D,W
0554:  MOVWF  04
0555:  MOVF   00,W
0556:  MOVWF  20
0557:  INCF   04,F
0558:  MOVF   00,W
0559:  MOVWF  21
055A:  INCF   04,F
055B:  MOVF   00,W
055C:  MOVWF  22
055D:  INCF   04,F
055E:  MOVF   00,W
055F:  MOVWF  23
0560:  MOVLW  FD
0561:  ADDWF  04,F
0562:  MOVF   20,W
0563:  SUBLW  00
0564:  MOVWF  20
0565:  MOVF   21,W
0566:  BTFSS  03.0
0567:  INCFSZ 21,W
0568:  GOTO   56B
0569:  MOVLW  00
056A:  GOTO   56C
056B:  SUBLW  00
056C:  MOVWF  21
056D:  MOVF   22,W
056E:  BTFSS  03.0
056F:  INCFSZ 22,W
0570:  GOTO   573
0571:  MOVLW  00
0572:  GOTO   574
0573:  SUBLW  00
0574:  MOVWF  22
0575:  MOVF   23,W
0576:  BTFSS  03.0
0577:  INCFSZ 23,W
0578:  GOTO   57B
0579:  MOVLW  00
057A:  GOTO   57C
057B:  SUBLW  00
057C:  MOVWF  23
057D:  MOVWF  74
057E:  MOVF   70,W
057F:  MOVWF  04
0580:  MOVF   20,W
0581:  MOVWF  00
0582:  INCF   04,F
0583:  MOVF   21,W
0584:  MOVWF  00
0585:  INCF   04,F
0586:  MOVF   22,W
0587:  MOVWF  00
0588:  INCF   04,F
0589:  MOVF   74,W
058A:  MOVWF  00
....................     ////printf("\n less temp %ld a %ld sum %ld",temp,pid_st->maxSumError,pid_st->sumError); 
....................  
....................   } 
....................   else{ 
058B:  GOTO   615
....................     pid_st->sumError = temp; 
058C:  MOVLW  02
058D:  ADDWF  5D,W
058E:  MOVWF  04
058F:  MOVF   6C,W
0590:  MOVWF  00
0591:  INCF   04,F
0592:  MOVF   6D,W
0593:  MOVWF  00
0594:  INCF   04,F
0595:  MOVF   6E,W
0596:  MOVWF  00
0597:  INCF   04,F
0598:  MOVF   6F,W
0599:  MOVWF  00
....................     i_term = pid_st->I_Factor * pid_st->sumError; 
059A:  MOVLW  08
059B:  ADDWF  5D,W
059C:  MOVWF  04
059D:  INCF   04,F
059E:  MOVF   00,W
059F:  MOVWF  71
05A0:  DECF   04,F
05A1:  MOVF   00,W
05A2:  MOVWF  70
05A3:  MOVLW  02
05A4:  ADDWF  5D,W
05A5:  MOVWF  04
05A6:  MOVF   00,W
05A7:  MOVWF  20
05A8:  INCF   04,F
05A9:  MOVF   00,W
05AA:  MOVWF  21
05AB:  INCF   04,F
05AC:  MOVF   00,W
05AD:  MOVWF  22
05AE:  INCF   04,F
05AF:  MOVF   00,W
05B0:  MOVWF  23
05B1:  MOVLW  FD
05B2:  ADDWF  04,F
05B3:  MOVF   23,W
05B4:  MOVWF  75
05B5:  MOVF   22,W
05B6:  MOVWF  74
05B7:  MOVF   21,W
05B8:  MOVWF  73
05B9:  MOVF   20,W
05BA:  MOVWF  72
05BB:  MOVF   04,W
05BC:  MOVWF  76
05BD:  CLRF   7A
05BE:  CLRF   79
05BF:  MOVF   71,W
05C0:  MOVWF  78
05C1:  MOVF   70,W
05C2:  MOVWF  77
05C3:  MOVF   75,W
05C4:  MOVWF  7E
05C5:  MOVF   74,W
05C6:  MOVWF  7D
05C7:  MOVF   73,W
05C8:  MOVWF  7C
05C9:  MOVF   72,W
05CA:  MOVWF  7B
*
060A:  BCF    03.5
060B:  MOVF   76,W
060C:  MOVWF  04
060D:  MOVF   23,W
060E:  MOVWF  67
060F:  MOVF   22,W
0610:  MOVWF  66
0611:  MOVF   21,W
0612:  MOVWF  65
0613:  MOVF   20,W
0614:  MOVWF  64
....................     ////printf("\n eror temp %ld i_term %ld sum %ld error %ld ",temp,i_term,pid_st->sumError,error); 
....................  
....................   } 
....................  
....................   // Calculate Dterm 
....................   d_term = pid_st->D_Factor * (pid_st->lastProcessValue - processValue); 
0615:  MOVLW  0A
0616:  ADDWF  5D,W
0617:  MOVWF  04
0618:  INCF   04,F
0619:  MOVF   00,W
061A:  MOVWF  71
061B:  DECF   04,F
061C:  MOVF   00,W
061D:  MOVWF  70
061E:  MOVF   5D,W
061F:  MOVWF  04
0620:  INCF   04,F
0621:  MOVF   00,W
0622:  MOVWF  73
0623:  DECF   04,F
0624:  MOVF   00,W
0625:  MOVWF  72
0626:  MOVF   5B,W
0627:  SUBWF  72,W
0628:  MOVWF  20
0629:  MOVF   73,W
062A:  MOVWF  23
062B:  MOVF   5C,W
062C:  BTFSS  03.0
062D:  INCFSZ 5C,W
062E:  SUBWF  23,F
062F:  MOVF   20,W
0630:  MOVWF  74
0631:  MOVF   23,W
0632:  MOVWF  75
0633:  MOVF   71,W
0634:  MOVWF  77
0635:  MOVF   70,W
0636:  MOVWF  76
0637:  MOVF   75,W
0638:  MOVWF  79
0639:  MOVF   74,W
063A:  MOVWF  78
*
064F:  MOVF   21,W
0650:  MOVWF  62
0651:  MOVF   22,W
0652:  MOVWF  63
.................... ////printf("\n p_term %ld d_term %ld i_term %ld",p_term,d_term,i_term); 
....................   pid_st->lastProcessValue = processValue; 
0653:  MOVF   5D,W
0654:  MOVWF  04
0655:  INCF   04,F
0656:  MOVF   5C,W
0657:  MOVWF  00
0658:  DECF   04,F
0659:  MOVF   5B,W
065A:  MOVWF  00
....................  
....................   //ret = (p_term + i_term + d_term) / SCALING_FACTOR; 
....................    ret = (p_term+d_term+(signed int16)i_term) / SCALING_FACTOR; 
065B:  MOVF   62,W
065C:  ADDWF  60,W
065D:  MOVWF  70
065E:  MOVF   61,W
065F:  MOVWF  71
0660:  MOVF   63,W
0661:  BTFSC  03.0
0662:  INCFSZ 63,W
0663:  ADDWF  71,F
0664:  MOVF   64,W
0665:  ADDWF  70,W
0666:  MOVWF  72
0667:  MOVF   71,W
0668:  MOVWF  73
0669:  MOVF   65,W
066A:  BTFSC  03.0
066B:  INCFSZ 65,W
066C:  ADDWF  73,F
066D:  MOVF   73,W
066E:  MOVWF  75
066F:  MOVF   72,W
0670:  MOVWF  74
0671:  CLRF   77
0672:  MOVLW  80
0673:  MOVWF  76
*
06B1:  MOVF   22,W
06B2:  MOVWF  23
06B3:  MOVF   21,W
06B4:  MOVWF  20
06B5:  MOVF   22,W
06B6:  MOVWF  21
06B7:  CLRF   22
06B8:  CLRF   23
06B9:  BTFSS  21.7
06BA:  GOTO   6BD
06BB:  DECF   22,F
06BC:  DECF   23,F
06BD:  MOVF   23,W
06BE:  MOVWF  6B
06BF:  MOVF   22,W
06C0:  MOVWF  6A
06C1:  MOVF   21,W
06C2:  MOVWF  69
06C3:  MOVF   20,W
06C4:  MOVWF  68
....................   if(ret > MAX_INT){ 
06C5:  BTFSC  6B.7
06C6:  GOTO   6D8
06C7:  MOVF   6B,F
06C8:  BTFSS  03.2
06C9:  GOTO   6D1
06CA:  MOVF   6A,F
06CB:  BTFSS  03.2
06CC:  GOTO   6D1
06CD:  MOVF   69,W
06CE:  SUBLW  7F
06CF:  BTFSC  03.0
06D0:  GOTO   6D8
....................     ret = MAX_INT; 
06D1:  CLRF   6B
06D2:  CLRF   6A
06D3:  MOVLW  7F
06D4:  MOVWF  69
06D5:  MOVLW  FF
06D6:  MOVWF  68
....................   } 
....................   else if(ret < -MAX_INT){ 
06D7:  GOTO   6F7
06D8:  BTFSS  6B.7
06D9:  GOTO   6F7
06DA:  MOVF   6B,W
06DB:  SUBLW  FF
06DC:  BTFSS  03.0
06DD:  GOTO   6F7
06DE:  BTFSS  03.2
06DF:  GOTO   6F0
06E0:  MOVF   6A,W
06E1:  SUBLW  FF
06E2:  BTFSS  03.0
06E3:  GOTO   6F7
06E4:  BTFSS  03.2
06E5:  GOTO   6F0
06E6:  MOVF   69,W
06E7:  SUBLW  80
06E8:  BTFSS  03.0
06E9:  GOTO   6F7
06EA:  BTFSS  03.2
06EB:  GOTO   6F0
06EC:  MOVF   68,W
06ED:  SUBLW  00
06EE:  BTFSS  03.0
06EF:  GOTO   6F7
....................     ret = -MAX_INT; 
06F0:  MOVLW  FF
06F1:  MOVWF  6B
06F2:  MOVWF  6A
06F3:  MOVLW  80
06F4:  MOVWF  69
06F5:  MOVLW  01
06F6:  MOVWF  68
....................   } 
....................  
....................   return((signed int16)ret); 
06F7:  MOVF   68,W
06F8:  MOVWF  21
06F9:  MOVF   69,W
06FA:  MOVWF  22
.................... } 
06FB:  BSF    0A.3
06FC:  GOTO   1CA (RETURN)
....................  
.................... /*! \brief Resets the integrator. 
....................  * 
....................  *  Calling this function will reset the integrator in the PID regulator. 
....................  */ 
.................... void pid_Reset_Integrator(pidData_t *pid_st) 
.................... { 
....................   pid_st->sumError = 0; 
.................... } 
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
