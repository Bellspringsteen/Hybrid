CCS PCM C Compiler, Version 4.084, 46530               20-Apr-13 12:56

               Filename: HondaHybrid.lst

               ROM used: 1534 words (37%)
                         Largest free fragment is 2048
               RAM used: 59 (31%) at main() level
                         85 (45%) worst case
               Stack:    4 worst case (3 in main + 1 for interrupts)

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   4FF
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  26
0008:  MOVF   7F,W
0009:  MOVWF  25
000A:  MOVF   0A,W
000B:  MOVWF  2D
000C:  CLRF   0A
000D:  SWAPF  25,F
000E:  MOVF   04,W
000F:  MOVWF  27
0010:  MOVF   20,W
0011:  MOVWF  28
0012:  MOVF   21,W
0013:  MOVWF  29
0014:  MOVF   22,W
0015:  MOVWF  2A
0016:  MOVF   23,W
0017:  MOVWF  2B
0018:  MOVF   24,W
0019:  MOVWF  2C
001A:  BCF    03.7
001B:  BCF    03.5
001C:  MOVLW  8C
001D:  MOVWF  04
001E:  BTFSS  00.0
001F:  GOTO   022
0020:  BTFSC  0C.0
0021:  GOTO   03F
0022:  MOVLW  8D
0023:  MOVWF  04
0024:  BTFSS  00.0
0025:  GOTO   028
0026:  BTFSC  0D.0
0027:  GOTO   041
0028:  BTFSS  0B.5
0029:  GOTO   02C
002A:  BTFSC  0B.2
002B:  GOTO   043
002C:  MOVF   27,W
002D:  MOVWF  04
002E:  MOVF   28,W
002F:  MOVWF  20
0030:  MOVF   29,W
0031:  MOVWF  21
0032:  MOVF   2A,W
0033:  MOVWF  22
0034:  MOVF   2B,W
0035:  MOVWF  23
0036:  MOVF   2C,W
0037:  MOVWF  24
0038:  MOVF   2D,W
0039:  MOVWF  0A
003A:  SWAPF  26,W
003B:  MOVWF  03
003C:  SWAPF  7F,F
003D:  SWAPF  7F,W
003E:  RETFIE
003F:  BCF    0A.3
0040:  GOTO   077
0041:  BCF    0A.3
0042:  GOTO   0BF
0043:  BCF    0A.3
0044:  GOTO   068
.................... #include "HondaHybrid.h" 
.................... #include <16F873A.h> 
.................... //////// Standard Header file for the PIC16F873A device //////////////// 
.................... #device PIC16F873A 
.................... #list 
....................  
....................  
.................... //#include <16F737.h> 
.................... //#device ICD=TRUE 
.................... #device adc=10 
.................... //#device adc=8 
.................... #use delay(clock=20000000) 
*
02F8:  MOVLW  59
02F9:  MOVWF  04
02FA:  MOVF   00,W
02FB:  BTFSC  03.2
02FC:  GOTO   149
02FD:  MOVLW  06
02FE:  MOVWF  21
02FF:  CLRF   20
0300:  DECFSZ 20,F
0301:  GOTO   300
0302:  DECFSZ 21,F
0303:  GOTO   2FF
0304:  MOVLW  7B
0305:  MOVWF  20
0306:  DECFSZ 20,F
0307:  GOTO   306
0308:  DECFSZ 00,F
0309:  GOTO   2FD
030A:  BCF    0A.3
030B:  GOTO   587 (RETURN)
.................... #fuses HS,PUT,NOWDT 
.................... #use rs232 (DEBUGGER) 
*
0148:  MOVF   6E,W
0149:  RETLW  00
.................... #include <mcp4921.c> 
.................... //////////////// Driver for MCP4921 D/A Converter /////////////////////// 
.................... ////                                                                 //// 
.................... ////  init_dac()    Call this before using a MCP4921 DAC             //// 
.................... ////                                                                 //// 
.................... ////  write_dac( long int )   Writes command and 12 bit resolution   //// 
.................... ////                          to the MCP4921 which converts it to a  //// 
.................... ////                          voltage                                //// 
.................... ////                          0-4095 input represents 0-vref V out.  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SELECT 
....................  
.................... #define DAC_CS     PIN_C4 
.................... #define DAC_CLK    PIN_C3 
.................... #define DAC_DI     PIN_C5 
.................... #define DAC_LDAC   PIN_B5 
....................  
.................... #endif 
....................  
.................... void init_dac() 
.................... { 
....................    output_high(DAC_CS); 
*
00D3:  BCF    2E.4
00D4:  MOVF   2E,W
00D5:  BSF    03.5
00D6:  MOVWF  07
00D7:  BCF    03.5
00D8:  BSF    07.4
....................    output_high(DAC_LDAC); 
00D9:  BSF    03.5
00DA:  BCF    06.5
00DB:  BCF    03.5
00DC:  BSF    06.5
....................    output_high(DAC_CLK); 
00DD:  BCF    2E.3
00DE:  MOVF   2E,W
00DF:  BSF    03.5
00E0:  MOVWF  07
00E1:  BCF    03.5
00E2:  BSF    07.3
....................    output_high(DAC_DI); 
00E3:  BCF    2E.5
00E4:  MOVF   2E,W
00E5:  BSF    03.5
00E6:  MOVWF  07
00E7:  BCF    03.5
00E8:  BSF    07.5
.................... } 
00E9:  BCF    0A.3
00EA:  GOTO   54F (RETURN)
....................  
.................... void write_dac(int16 data) { 
....................    BYTE cmd[3]; 
....................    BYTE i; 
....................  
....................    cmd[0]=data; 
00EB:  MOVF   58,W
00EC:  MOVWF  5A
....................    cmd[1]=(data>>8); 
00ED:  MOVF   59,W
00EE:  MOVWF  5B
....................    cmd[2]=0x03;                            
00EF:  MOVLW  03
00F0:  MOVWF  5C
....................     
....................    output_high(DAC_LDAC); 
00F1:  BSF    03.5
00F2:  BCF    06.5
00F3:  BCF    03.5
00F4:  BSF    06.5
....................    output_low(DAC_CLK); 
00F5:  BCF    2E.3
00F6:  MOVF   2E,W
00F7:  BSF    03.5
00F8:  MOVWF  07
00F9:  BCF    03.5
00FA:  BCF    07.3
....................    output_low(DAC_CS); 
00FB:  BCF    2E.4
00FC:  MOVF   2E,W
00FD:  BSF    03.5
00FE:  MOVWF  07
00FF:  BCF    03.5
0100:  BCF    07.4
....................  
....................    for(i=0; i<=23; ++i) 
0101:  CLRF   5D
0102:  MOVF   5D,W
0103:  SUBLW  17
0104:  BTFSS  03.0
0105:  GOTO   133
....................    { 
....................       if(i<4 || (i>7 && i<12)) 
0106:  MOVF   5D,W
0107:  SUBLW  03
0108:  BTFSC  03.0
0109:  GOTO   112
010A:  MOVF   5D,W
010B:  SUBLW  07
010C:  BTFSC  03.0
010D:  GOTO   117
010E:  MOVF   5D,W
010F:  SUBLW  0B
0110:  BTFSS  03.0
0111:  GOTO   117
....................          shift_left(cmd,3,0); 
0112:  BCF    03.0
0113:  RLF    5A,F
0114:  RLF    5B,F
0115:  RLF    5C,F
....................       else 
0116:  GOTO   131
....................       { 
....................          output_bit(DAC_DI, shift_left(cmd,3,0)); 
0117:  BCF    03.0
0118:  RLF    5A,F
0119:  RLF    5B,F
011A:  RLF    5C,F
011B:  BTFSC  03.0
011C:  GOTO   11F
011D:  BCF    07.5
011E:  GOTO   120
011F:  BSF    07.5
0120:  BCF    2E.5
0121:  MOVF   2E,W
0122:  BSF    03.5
0123:  MOVWF  07
....................  
....................          output_high(DAC_CLK); 
0124:  BCF    03.5
0125:  BCF    2E.3
0126:  MOVF   2E,W
0127:  BSF    03.5
0128:  MOVWF  07
0129:  BCF    03.5
012A:  BSF    07.3
....................          output_low(DAC_CLK); 
012B:  BCF    2E.3
012C:  MOVF   2E,W
012D:  BSF    03.5
012E:  MOVWF  07
012F:  BCF    03.5
0130:  BCF    07.3
....................       } 
....................    } 
0131:  INCF   5D,F
0132:  GOTO   102
....................    output_high(DAC_CS); 
0133:  BCF    2E.4
0134:  MOVF   2E,W
0135:  BSF    03.5
0136:  MOVWF  07
0137:  BCF    03.5
0138:  BSF    07.4
....................  
....................    output_low(DAC_LDAC); 
0139:  BSF    03.5
013A:  BCF    06.5
013B:  BCF    03.5
013C:  BCF    06.5
....................    delay_us(10); 
013D:  MOVLW  10
013E:  MOVWF  20
013F:  DECFSZ 20,F
0140:  GOTO   13F
0141:  NOP
....................     
....................    output_HIGH(DAC_LDAC); 
0142:  BSF    03.5
0143:  BCF    06.5
0144:  BCF    03.5
0145:  BSF    06.5
.................... } 
0146:  BCF    0A.3
0147:  GOTO   56F (RETURN)
....................  
....................  
....................  
.................... #include "pid.h" 
.................... /*This file has been prepared for Doxygen automatic documentation generation.*/ 
.................... /*! \file ********************************************************************* 
....................  * 
....................  * \brief Header file for pid.c. 
....................  * 
....................  * - File:               pid.h 
....................  * - Compiler:           IAR EWAAVR 4.11A 
....................  * - Supported devices:  All AVR devices can be used. 
....................  * - AppNote:            AVR221 - Discrete PID controller 
....................  * 
....................  * \author               Atmel Corporation: http://www.atmel.com \n 
....................  *                       Support email: avr@atmel.com 
....................  * 
....................  * $Name$ 
....................  * $Revision: 456 $ 
....................  * $RCSfile$ 
....................  * $Date: 2006-02-16 12:46:13 +0100 (to, 16 feb 2006) $ 
....................  *****************************************************************************/ 
....................  
.................... #ifndef PID_H 
.................... #define PID_H 
....................  
.................... //#include "stdint.h" 
.................... #define INT16_MAX 32767 
.................... #define INT32_MAX 2147483647 
.................... #define SCALING_FACTOR  128 
....................  
.................... /*! \brief PID Status 
....................  * 
....................  * Setpoints and data used by the PID control algorithm 
....................  */ 
.................... typedef struct PID_DATA{ 
....................   //! Last process value, used to find derivative of process value. 
....................   int16 lastProcessValue; 
....................   //! Summation of errors, used for integrate calculations 
....................   int32 sumError; 
....................   //! The Proportional tuning constant, multiplied with SCALING_FACTOR 
....................   int16 P_Factor; 
....................   //! The Integral tuning constant, multiplied with SCALING_FACTOR 
....................   int16 I_Factor; 
....................   //! The Derivative tuning constant, multiplied with SCALING_FACTOR 
....................   int16 D_Factor; 
....................   //! Maximum allowed error, avoid overflow 
....................   int16 maxError; 
....................   //! Maximum allowed sumerror, avoid overflow 
....................   int32 maxSumError; 
.................... } pidData_t; 
....................  
.................... /*! \brief Maximum values 
....................  * 
....................  * Needed to avoid sign/overflow problems 
....................  */ 
.................... // Maximum value of variables 
.................... #define MAX_INT         INT16_MAX 
.................... #define MAX_LONG        INT32_MAX 
.................... #define MAX_I_TERM      (MAX_LONG / 2) 
....................  
.................... // Boolean values 
.................... //#define FALSE           0 
.................... //#define TRUE            1 
....................  
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid); 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st); 
.................... void pid_Reset_Integrator(pidData_t *pid_st); 
....................  
.................... #endif 
....................  
.................... /* 
.................... This is the main controller for the super capacitor hybrid scooter a.k.a RED 
.................... B2 close contactor 
.................... CONTROL BOX INPUTS 
.................... Athrottle- A0 - analog input representing the users input for speed, 10 bit 
.................... Vspeed - CCp2-a 16 bit representation of the speed of the vehicle 
.................... Acaps- A1 - analog input representing the current voltage of the supercapacitors, 10 bit 
....................  
.................... CONTROL BOX OUTPUT 
.................... ICEthrottle- B1 - a 16 bit number sent to the internal combustion engine(ICE) throttle  
.................... ELECthrottle-  - a 16 bit number sent as analog value representing the demanded electric power 
....................  
.................... SPECIFICS OF I/O 
....................  
.................... Athrottle - the electric throttle is a 3 wire unit with a 5 volt,ground, and analog out 
....................    representing how far throttle is turned. Pin AN0 is the input. 
....................     
.................... Vspeed - There is a encoder in the rear wheel/electric motor that is used by the electric 
....................    power controller. Tapping in to this this Main Controller receives a 5 Volt square wave 
....................    with 42 pulses. There are two options for measuring speed. The first is to measure the  
....................    length of the pulses. The second is to measure the rate of pulses. This controller currently 
....................    uses the rate method. The int_ccp2 interupt is called on each falling edge and stores the  
....................    Vspeed value as the max number of 16bit (65535-timer0_since_last_reset).  
....................     
....................    The RED scooter has a circumpherence of 16.3*2*pi = 102.4 
....................    X m/h * 63360 inch/mile * 1/3600 h/sec * 1/(102.4 inch/rev) = .171875* X 
....................    Examples 50 mph is 8.9 ms 1 overflow of timer0 
....................    Example 5 mph is 89 ms or 13 time overflow 
....................     
....................    #int_timer0 increments the counter number_of_overflows each time it overflows 
....................    On int ccp2 we multiply number_of_overflows * 256 + timer0 to get timer0_since_last_reset 
....................     
.................... Acaps - the analog voltage which is the 5volt representation of the voltage in the caps which 
....................    have a value of between 0-48v. The voltages are factored so that the voltage on AN1 goes 
....................    from 0 - 4.8 volts (TODO check this factor, think its 1/11 not 1/10) 
....................     
.................... ICEthrottle -  #int_timer1 is set to make sure the period follows the required below 
....................    The period for the servo is .020 seconds which is 50,000 operations 
....................    The leftmost position of the server is .001 seconds which is 2,500 
....................    The rightmost position of the server is .002 seconds which is 5,000 
....................     
....................    The output pin is pin_B1.-> 
....................  
.................... ELECthrottle 
....................    The electric power controller takes an analog voltage as input. The output voltage 
....................    is set by the DAC. The pins used are C3,C4,C5. if CHARGING_STATE is true then  
....................     
.................... ALGORITHM 
....................    The algorithm is basically a PID controller. In broad terms we are trying to set the 
....................    ICEthrottle and ICEelectric to maximize the use of electric and accelerate to meet the 
....................    requirements set by the rider with the Athrottle signal. When the demanded power is  
....................    less than the power output possible by the ICE and the caps are in the CHARGING_STATE  
....................    then the ICE is turned up to the max and the ELECthrottle is set to regen to 
....................    charge the capacitors.If CHARGING_STATE is false then the caps are supplying the drivig power 
....................    and the ICE is set to "off", the caps supply the power. Unless the user requested supply 
....................    is enough to require both power sources. 
....................     
....................    If CHARGING_STATE is true. Then pin_b2 is set as high which will close the brake number 
....................    for the electric power controller.  
....................     
....................    If CHARGING_STATE is false then the pin_b2 is set low which opens brake. 
....................     
....................     
....................  
....................  
.................... The encoder has 42 on and offs per rotation, i.e. 21 steps 
....................  
.................... Number of operations per second is CLOCK/4/Timer Divisions 
.................... Number of operations per second is 20,000,000/4/128 = 39062.5  
.................... Each operation takes 1/39062.5 = .256 micro (x10^-6) seconds 
.................... Seconds to Overflow timer0 8bit timer = .256x10^-6 * 256 = 6.55ms 
....................  
....................  
....................  
.................... */ 
.................... #define servo_pin PIN_B1  //Setting servo out pin to be hardware pin b1 
.................... #define brake_pin PIN_B4 
.................... #define ADC_DELAY delay_us(20) 
.................... #define Acaps_pin PIN_A1 
.................... #define Acaps_channel 1 
.................... #define Athrottle_pin PIN_A0  //Voltage goes from 1.5 (306)to 4.1(836) 
.................... #define Athrottle_Min 316 
.................... #define Athrottle_Max 860 
.................... #define Athrottle_Full Athrottle_Max-Athrottle_Min 
.................... #define Athrottle_channel 0 
.................... #define Electric_Controller_Switch PIN_B0 
.................... #define Contactor_Switch PIN_B2 
....................  
.................... //PID Values 
.................... #define K_P 1.00 
.................... #define K_I 0.00 
.................... #define K_D 0.85 
....................  
.................... int1 pid_Timer = 0; 
*
050D:  BCF    2F.0
.................... struct PID_DATA pidData; 
.................... #define TIME_INTERVAL 157 //TODO replace 
....................  
.................... #define left_position 4450 
.................... #define right_position 5300 
.................... #define servo_difference  right_position-left_position 
.................... const float Athrottle_servo_factor = ((float) servo_difference)/((float) Athrottle_FULL); 
.................... #define servo_period   65356-50000 
.................... unsigned int16 current_servo_position=right_position; 
050E:  MOVLW  B4
050F:  MOVWF  42
0510:  MOVLW  14
0511:  MOVWF  43
.................... int1 SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0; 
0512:  BCF    2F.1
.................... int1 test_boolean = 0; 
0513:  BCF    2F.2
....................  
.................... int1 test_switch = 0; 
0514:  BCF    2F.3
.................... unsigned int16 test_counter = 0; 
0515:  CLRF   44
0516:  CLRF   45
.................... //int16 returnedValue = 0; 
....................  
.................... unsigned int16 number_of_timer0_interupts_since_reset =0; 
0517:  CLRF   46
0518:  CLRF   47
.................... unsigned int16 timer0_since_last_reset= 0; 
0519:  CLRF   48
051A:  CLRF   49
.................... unsigned int16 vSpeed= 0; 
051B:  CLRF   4A
051C:  CLRF   4B
.................... signed int16 ELECthrottle = 900; 
051D:  MOVLW  84
051E:  MOVWF  4C
051F:  MOVLW  03
0520:  MOVWF  4D
.................... unsigned int16 ICEthrottle = 0; 
0521:  CLRF   4E
0522:  CLRF   4F
.................... unsigned int16 Athrottle = 0; 
0523:  CLRF   50
0524:  CLRF   51
.................... unsigned int16 Acaps = 0; 
0525:  CLRF   52
0526:  CLRF   53
.................... int1 CURRENTLY_CHARGING = 0; 
0527:  BCF    2F.4
.................... signed int16 returnedValue =0; 
0528:  CLRF   54
0529:  CLRF   55
.................... int16 speeder = 0;  
052A:  CLRF   56
052B:  CLRF   57
.................... /* 
.................... The #int_timer0 interupt is triggered on each timer0 8bit interupt 
.................... the function simply increments a overflow counter to be used by the ccp2 
.................... interupt to calculate speed 
.................... NUMBER OF OPERATIONS =  
.................... */ 
.................... #int_timer0 
.................... void timer0_isr(){ 
....................     
....................       number_of_timer0_interupts_since_reset=number_of_timer0_interupts_since_reset+256; 
*
0068:  MOVLW  01
0069:  ADDWF  47,F
....................       //current_servo_position=current_servo_position+1; 
....................        
....................     
....................    if (number_of_timer0_interupts_since_reset>=1024){ 
006A:  MOVF   47,W
006B:  SUBLW  03
006C:  BTFSC  03.0
006D:  GOTO   074
....................       vSpeed = 1280; 
006E:  MOVLW  05
006F:  MOVWF  4B
0070:  CLRF   4A
....................       number_of_timer0_interupts_since_reset=1024; 
0071:  MOVLW  04
0072:  MOVWF  47
0073:  CLRF   46
....................        
....................        
....................    } 
.................... } 
....................  
.................... /* 
.................... #int_timer1 is used by the ICEservo throttle to regulate the timing pulses. The  
.................... timer is setup for a pulsetrain of 20ms period. This is done as follows, 
....................  
.................... Period is 1/(CLOCK/4opsperclock)*(startingPostionOfClock) = 20 ms 
.................... for this setup 1/(20000000/4)*(50000) = 20 ms 
....................  
.................... The timer1 starts at 0 and counts up. So we set the beggining of the clock at 
.................... servo_period which is 65356-50000 so that the total time is 20ms. 
.................... */ 
0074:  BCF    0B.2
0075:  BCF    0A.3
0076:  GOTO   02C
.................... #int_timer1 
.................... void isr() 
.................... { 
....................  
.................... //Make sure that the position is within the left and right positions of the servo 
....................    if (current_servo_position<left_position){ 
0077:  MOVF   43,W
0078:  SUBLW  11
0079:  BTFSS  03.0
007A:  GOTO   086
007B:  BTFSS  03.2
007C:  GOTO   081
007D:  MOVF   42,W
007E:  SUBLW  61
007F:  BTFSS  03.0
0080:  GOTO   086
....................       current_servo_position = left_position; 
0081:  MOVLW  11
0082:  MOVWF  43
0083:  MOVLW  62
0084:  MOVWF  42
....................    } 
....................    else if (current_servo_position > right_position){ 
0085:  GOTO   095
0086:  MOVF   43,W
0087:  SUBLW  13
0088:  BTFSC  03.0
0089:  GOTO   095
008A:  XORLW  FF
008B:  BTFSS  03.2
008C:  GOTO   091
008D:  MOVF   42,W
008E:  SUBLW  B4
008F:  BTFSC  03.0
0090:  GOTO   095
....................       current_servo_position = right_position; 
0091:  MOVLW  14
0092:  MOVWF  43
0093:  MOVLW  B4
0094:  MOVWF  42
....................    } 
....................  
....................    if(SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER) 
0095:  BTFSS  2F.1
0096:  GOTO   0AA
....................       {  
....................          output_high(servo_pin);        //Set the servo control pin to high  
0097:  BSF    03.5
0098:  BCF    06.1
0099:  BCF    03.5
009A:  BSF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0;  
009B:  BCF    2F.1
....................          set_timer1(65356-current_servo_position); //Set timer for the position high pulse 
009C:  MOVF   42,W
009D:  SUBLW  4C
009E:  MOVWF  72
009F:  MOVLW  FF
00A0:  MOVWF  73
00A1:  MOVF   43,W
00A2:  BTFSS  03.0
00A3:  INCFSZ 43,W
00A4:  SUBWF  73,F
00A5:  MOVF   73,W
00A6:  MOVWF  0F
00A7:  MOVF   72,W
00A8:  MOVWF  0E
....................       }  
....................    else  
00A9:  GOTO   0BC
....................       {  
....................          output_low(servo_pin);                      // Set the servo control pin to low   
00AA:  BSF    03.5
00AB:  BCF    06.1
00AC:  BCF    03.5
00AD:  BCF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 1;  
00AE:  BSF    2F.1
....................          set_timer1(servo_period+current_servo_position);          //Set timer for the low position the length is the difference between  
00AF:  MOVLW  FC
00B0:  ADDWF  42,W
00B1:  MOVWF  72
00B2:  MOVF   43,W
00B3:  MOVWF  73
00B4:  MOVLW  3B
00B5:  BTFSC  03.0
00B6:  MOVLW  3C
00B7:  ADDWF  73,F
00B8:  MOVF   73,W
00B9:  MOVWF  0F
00BA:  MOVF   72,W
00BB:  MOVWF  0E
....................                                                      //the total int16 lenght - high pulse length 
....................       }   
.................... } 
....................  
....................  
.................... /* 
.................... #int_ccp2 is called on the falling edge of the encoder pulse. We calculate the time 
.................... between pulses.  
.................... TODO will have to put some kind of smoothing mechanism 
.................... */ 
00BC:  BCF    0C.0
00BD:  BCF    0A.3
00BE:  GOTO   02C
.................... #int_ccp2 
.................... void isr2() 
.................... { 
.................... if (number_of_timer0_interupts_since_reset>10){ 
00BF:  MOVF   47,F
00C0:  BTFSS  03.2
00C1:  GOTO   0C6
00C2:  MOVF   46,W
00C3:  SUBLW  0A
00C4:  BTFSC  03.0
00C5:  GOTO   0D0
.................... vSpeed  = (number_of_timer0_interupts_since_reset+get_timer0()); 
00C6:  MOVF   01,W
00C7:  ADDWF  46,W
00C8:  MOVWF  4A
00C9:  MOVF   47,W
00CA:  MOVWF  4B
00CB:  BTFSC  03.0
00CC:  INCF   4B,F
.................... //vSpeed  = -(get_timer0()); 
.................... set_timer0(0); 
00CD:  CLRF   01
.................... number_of_timer0_interupts_since_reset = 0; 
00CE:  CLRF   47
00CF:  CLRF   46
.................... } 
.................... } 
....................  
....................  
....................  
....................  
00D0:  BCF    0D.0
00D1:  BCF    0A.3
00D2:  GOTO   02C
.................... void main() 
.................... {   
*
04FF:  CLRF   04
0500:  MOVLW  1F
0501:  ANDWF  03,F
0502:  BSF    00.0
0503:  BSF    03.5
0504:  BSF    1F.0
0505:  BSF    1F.1
0506:  BSF    1F.2
0507:  BCF    1F.3
0508:  MOVLW  07
0509:  MOVWF  1C
....................     
....................    setup_adc_ports(NO_ANALOGS); 
*
052C:  BSF    03.5
052D:  BSF    1F.0
052E:  BSF    1F.1
052F:  BSF    1F.2
0530:  BCF    1F.3
....................    setup_adc(ADC_OFF); 
0531:  BCF    03.5
0532:  BCF    1F.0
....................    setup_spi(FALSE); 
0533:  CLRF   14
....................     
....................    setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
0534:  BSF    03.5
0535:  MOVF   01,W
0536:  ANDLW  C0
0537:  IORLW  00
0538:  MOVWF  01
0539:  CLRWDT
....................    setup_timer_1(T1_DISABLED); 
053A:  BCF    03.5
053B:  CLRF   10
....................    setup_timer_2(T2_DISABLED,0,1); 
053C:  MOVLW  00
053D:  MOVWF  21
053E:  MOVWF  12
053F:  MOVLW  00
0540:  BSF    03.5
0541:  MOVWF  12
....................    setup_port_a(ALL_ANALOG); 
0542:  BCF    1F.0
0543:  BCF    1F.1
0544:  BCF    1F.2
0545:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
0546:  BCF    1F.6
0547:  BCF    03.5
0548:  BSF    1F.6
0549:  BSF    1F.7
054A:  BSF    03.5
054B:  BSF    1F.7
054C:  BCF    03.5
054D:  BSF    1F.0
....................     
....................    init_dac(); 
054E:  GOTO   0D3
....................   
....................    setup_timer_1(T1_DIV_BY_2| T1_INTERNAL);  
054F:  MOVLW  95
0550:  MOVWF  10
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_128); 
0551:  BSF    03.5
0552:  MOVF   01,W
0553:  ANDLW  C0
0554:  IORLW  06
0555:  MOVWF  01
....................    setup_ccp2(CCP_CAPTURE_RE);    // Configure CCP2 to capture fall 
0556:  BCF    03.5
0557:  BSF    2E.1
0558:  MOVF   2E,W
0559:  BSF    03.5
055A:  MOVWF  07
055B:  BCF    03.5
055C:  CLRF   1D
055D:  MOVLW  05
055E:  MOVWF  1D
....................    enable_interrupts(INT_CCP2);   // Setup interrupt on falling edge 
055F:  BSF    03.5
0560:  BSF    0D.0
....................    enable_interrupts(INT_TIMER0); 
0561:  BCF    03.5
0562:  BSF    0B.5
....................    enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
0563:  BSF    03.5
0564:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
0565:  MOVLW  C0
0566:  BCF    03.5
0567:  IORWF  0B,F
....................    output_low(Electric_Controller_Switch); 
0568:  BSF    03.5
0569:  BCF    06.0
056A:  BCF    03.5
056B:  BCF    06.0
....................    write_dac(0); 
056C:  CLRF   59
056D:  CLRF   58
056E:  GOTO   0EB
....................    output_high(Contactor_Switch); 
056F:  BSF    03.5
0570:  BCF    06.2
0571:  BCF    03.5
0572:  BSF    06.2
....................    output_low(brake_pin); 
0573:  BSF    03.5
0574:  BCF    06.4
0575:  BCF    03.5
0576:  BCF    06.4
....................    pid_Init(K_P*SCALING_FACTOR,K_I*SCALING_FACTOR,K_D*SCALING_FACTOR, & pidData); 
0577:  CLRF   59
0578:  MOVLW  80
0579:  MOVWF  58
057A:  CLRF   5B
057B:  CLRF   5A
057C:  CLRF   5D
057D:  MOVLW  6C
057E:  MOVWF  5C
057F:  MOVLW  30
0580:  MOVWF  5E
0581:  GOTO   1BF
....................     
....................    delay_ms(3000); 
0582:  MOVLW  0C
0583:  MOVWF  58
0584:  MOVLW  FA
0585:  MOVWF  59
0586:  GOTO   2F8
0587:  DECFSZ 58,F
0588:  GOTO   584
....................    //write_dac(1000); 
....................    //delay_ms(10000); 
....................    //output_high(Contactor_Switch); 
....................    //output_high(brake_pin); 
....................    //output_high(Electric_Controller_Switch); 
....................    while(TRUE) { 
....................  
....................       //GET INPUTS 
....................       //Vspeedhappens in interrupts 
....................        
....................       set_adc_channel(Acaps_channel); 
0589:  MOVLW  08
058A:  MOVWF  21
058B:  MOVF   1F,W
058C:  ANDLW  C7
058D:  IORWF  21,W
058E:  MOVWF  1F
....................       ADC_DELAY; 
058F:  MOVLW  21
0590:  MOVWF  20
0591:  DECFSZ 20,F
0592:  GOTO   591
....................       Acaps = read_adc(); 
0593:  BSF    1F.2
0594:  BTFSC  1F.2
0595:  GOTO   594
0596:  BSF    03.5
0597:  MOVF   1E,W
0598:  BCF    03.5
0599:  MOVWF  52
059A:  MOVF   1E,W
059B:  MOVWF  53
....................        
....................       set_adc_channel(Athrottle_channel); 
059C:  MOVLW  00
059D:  MOVWF  21
059E:  MOVF   1F,W
059F:  ANDLW  C7
05A0:  IORWF  21,W
05A1:  MOVWF  1F
....................       ADC_DELAY; 
05A2:  MOVLW  21
05A3:  MOVWF  20
05A4:  DECFSZ 20,F
05A5:  GOTO   5A4
....................       Athrottle = read_adc(); 
05A6:  BSF    1F.2
05A7:  BTFSC  1F.2
05A8:  GOTO   5A7
05A9:  BSF    03.5
05AA:  MOVF   1E,W
05AB:  BCF    03.5
05AC:  MOVWF  50
05AD:  MOVF   1E,W
05AE:  MOVWF  51
....................  
....................       //CONTROL BOX 
....................  
....................        
....................       if (Athrottle<Athrottle_Min){ 
05AF:  MOVF   51,W
05B0:  SUBLW  01
05B1:  BTFSS  03.0
05B2:  GOTO   5BD
05B3:  BTFSS  03.2
05B4:  GOTO   5B9
05B5:  MOVF   50,W
05B6:  SUBLW  3B
05B7:  BTFSS  03.0
05B8:  GOTO   5BD
....................          Athrottle=Athrottle_Min; 
05B9:  MOVLW  01
05BA:  MOVWF  51
05BB:  MOVLW  3C
05BC:  MOVWF  50
....................       } 
....................       //Servo to mirror Athrottle ->  
....................       current_servo_position=right_position-(Athrottle-Athrottle_Min)*Athrottle_servo_factor;//(Athrottle/Athrottle_Full)*servo_difference;//(vSpeed/65536.0)*(2500); 
05BD:  MOVLW  3C
05BE:  SUBWF  50,W
05BF:  MOVWF  58
05C0:  MOVF   51,W
05C1:  MOVWF  59
05C2:  MOVLW  01
05C3:  BTFSS  03.0
05C4:  MOVLW  02
05C5:  SUBWF  59,F
05C6:  MOVF   59,W
05C7:  MOVWF  5B
05C8:  MOVF   58,W
05C9:  MOVWF  5A
05CA:  GOTO   30C
05CB:  MOVF   23,W
05CC:  MOVWF  5D
05CD:  MOVF   22,W
05CE:  MOVWF  5C
05CF:  MOVF   21,W
05D0:  MOVWF  5B
05D1:  MOVF   20,W
05D2:  MOVWF  5A
05D3:  CLRF   61
05D4:  CLRF   60
05D5:  MOVLW  48
05D6:  MOVWF  5F
05D7:  MOVLW  7F
05D8:  MOVWF  5E
05D9:  GOTO   32A
05DA:  BSF    03.1
05DB:  CLRF   5D
05DC:  MOVLW  A0
05DD:  MOVWF  5C
05DE:  MOVLW  25
05DF:  MOVWF  5B
05E0:  MOVLW  8B
05E1:  MOVWF  5A
05E2:  MOVF   23,W
05E3:  MOVWF  61
05E4:  MOVF   22,W
05E5:  MOVWF  60
05E6:  MOVF   21,W
05E7:  MOVWF  5F
05E8:  MOVF   20,W
05E9:  MOVWF  5E
05EA:  GOTO   3A0
05EB:  MOVF   23,W
05EC:  MOVWF  5D
05ED:  MOVF   22,W
05EE:  MOVWF  5C
05EF:  MOVF   21,W
05F0:  MOVWF  5B
05F1:  MOVF   20,W
05F2:  MOVWF  5A
05F3:  GOTO   4DF
05F4:  MOVF   22,W
05F5:  MOVWF  43
05F6:  MOVF   21,W
05F7:  MOVWF  42
....................       //printf("Analog Cap %d Analog Throttle %Lu\n",(int) Acaps,Athrottle); 
....................       //current_servo_position =right_position-vSpeed+200; 
....................       speeder = vSpeed; 
05F8:  MOVF   4B,W
05F9:  MOVWF  57
05FA:  MOVF   4A,W
05FB:  MOVWF  56
....................       //printf("Speed %lu \n",speeder); 
....................       //SET OUTPUTS  
....................       //The writing of the ICEThrottle happens in interupts and all that is 
....................       //required is updating ICEthrottle 
....................       //printf("speed before %ld \n",vSpeed); 
....................       /* 
....................       returnedValue = pid_Controller((Athrottle-AThrottle_Min),(1280-speeder),& pidData); 
....................       ELECthrottle = ELECthrottle+returnedValue;    
....................       if (ELECthrottle<0){ 
....................          output_high(brake_pin); 
....................          output_high(Electric_Controller_Switch); 
....................          printf("BREAKING /n"); 
....................       } 
....................       else { 
....................          output_low(brake_pin); 
....................          output_low(Electric_Controller_Switch); 
....................       } 
....................       printf("input %ld r %lu speed %ld throttle %lu",Athrottle-Athrottle_Min,((unsigned int16) returnedValue),1280-speeder,(unsigned int16)ELECthrottle); 
....................       write_dac((unsigned int16)ELECthrottle); 
....................       //write_dac((right_position-(right_position-(Athrottle-Athrottle_Min)*Athrottle_servo_factor))*4); 
....................       //write_dac(((Athrottle-AThrottle_Min)*2)+950); 
.................... */ 
....................       //write_dac((right_position-current_servo_position)*4); 
....................    } 
05FC:  GOTO   589
....................     
....................  
.................... } 
....................  
.................... /*! \brief Initialisation of PID controller parameters. 
....................  * 
....................  *  Initialise the variables used by the PID algorithm. 
....................  * 
....................  *  \param p_factor  Proportional term. 
....................  *  \param i_factor  Integral term. 
....................  *  \param d_factor  Derivate term. 
....................  *  \param pid  Struct with PID status. 
....................  */ 
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid) 
.................... // Set up PID controller parameters 
05FD:  SLEEP
.................... { 
....................   // Start values for PID controller 
....................   pid->sumError = 0; 
*
01BF:  MOVLW  02
01C0:  ADDWF  5E,W
01C1:  MOVWF  04
01C2:  INCF   04,F
01C3:  INCF   04,F
01C4:  INCF   04,F
01C5:  CLRF   00
01C6:  DECF   04,F
01C7:  CLRF   00
01C8:  DECF   04,F
01C9:  CLRF   00
01CA:  DECF   04,F
01CB:  CLRF   00
....................   pid->lastProcessValue = 0; 
01CC:  MOVF   5E,W
01CD:  MOVWF  04
01CE:  INCF   04,F
01CF:  CLRF   00
01D0:  DECF   04,F
01D1:  CLRF   00
....................   // Tuning constants for PID loop 
....................   pid->P_Factor = p_factor; 
01D2:  MOVLW  06
01D3:  ADDWF  5E,W
01D4:  MOVWF  04
01D5:  INCF   04,F
01D6:  MOVF   59,W
01D7:  MOVWF  00
01D8:  DECF   04,F
01D9:  MOVF   58,W
01DA:  MOVWF  00
....................   pid->I_Factor = i_factor; 
01DB:  MOVLW  08
01DC:  ADDWF  5E,W
01DD:  MOVWF  04
01DE:  INCF   04,F
01DF:  MOVF   5B,W
01E0:  MOVWF  00
01E1:  DECF   04,F
01E2:  MOVF   5A,W
01E3:  MOVWF  00
....................   pid->D_Factor = d_factor; 
01E4:  MOVLW  0A
01E5:  ADDWF  5E,W
01E6:  MOVWF  04
01E7:  INCF   04,F
01E8:  MOVF   5D,W
01E9:  MOVWF  00
01EA:  DECF   04,F
01EB:  MOVF   5C,W
01EC:  MOVWF  00
....................   // Limits to avoid overflow 
....................   pid->maxError = MAX_INT / (pid->P_Factor + 1); 
01ED:  MOVLW  0C
01EE:  ADDWF  5E,W
01EF:  MOVWF  5F
01F0:  MOVLW  06
01F1:  ADDWF  5E,W
01F2:  MOVWF  04
01F3:  INCF   04,F
01F4:  MOVF   00,W
01F5:  MOVWF  61
01F6:  DECF   04,F
01F7:  MOVF   00,W
01F8:  MOVWF  60
01F9:  MOVLW  01
01FA:  ADDWF  60,W
01FB:  MOVWF  21
01FC:  MOVF   61,W
01FD:  MOVWF  23
01FE:  BTFSC  03.0
01FF:  INCF   23,F
0200:  MOVF   21,W
0201:  MOVWF  62
0202:  MOVF   23,W
0203:  MOVWF  63
0204:  MOVLW  7F
0205:  MOVWF  65
0206:  MOVLW  FF
0207:  MOVWF  64
0208:  MOVF   63,W
0209:  MOVWF  67
020A:  MOVF   62,W
020B:  MOVWF  66
*
0230:  MOVF   5F,W
0231:  MOVWF  04
0232:  INCF   04,F
0233:  MOVF   22,W
0234:  MOVWF  00
0235:  DECF   04,F
0236:  MOVF   21,W
0237:  MOVWF  00
....................   printf("Max %ld factor %ld and pid %ld",MAX_INT,pid->I_Factor,pid->maxError); 
0238:  MOVLW  08
0239:  ADDWF  5E,W
023A:  MOVWF  04
023B:  INCF   04,F
023C:  MOVF   00,W
023D:  MOVWF  60
023E:  DECF   04,F
023F:  MOVF   00,W
0240:  MOVWF  5F
0241:  MOVLW  0C
0242:  ADDWF  5E,W
0243:  MOVWF  04
0244:  INCF   04,F
0245:  MOVF   00,W
0246:  MOVWF  62
0247:  DECF   04,F
0248:  MOVF   00,W
0249:  MOVWF  61
024A:  CLRF   63
024B:  MOVF   63,W
024C:  CALL   045
024D:  INCF   63,F
024E:  MOVWF  20
024F:  MOVWF  6E
0250:  CALL   148
0251:  MOVLW  04
0252:  SUBWF  63,W
0253:  BTFSS  03.2
0254:  GOTO   24B
0255:  MOVLW  10
0256:  MOVWF  04
0257:  MOVLW  7F
0258:  MOVWF  67
0259:  MOVLW  FF
025A:  MOVWF  66
025B:  CALL   14A
025C:  MOVLW  07
025D:  MOVWF  64
025E:  MOVF   64,W
025F:  CALL   045
0260:  INCF   64,F
0261:  MOVWF  20
0262:  MOVWF  6E
0263:  CALL   148
0264:  MOVLW  0F
0265:  SUBWF  64,W
0266:  BTFSS  03.2
0267:  GOTO   25E
0268:  MOVLW  10
0269:  MOVWF  04
026A:  MOVF   60,W
026B:  MOVWF  67
026C:  MOVF   5F,W
026D:  MOVWF  66
026E:  CALL   14A
026F:  MOVLW  12
0270:  MOVWF  65
0271:  MOVF   65,W
0272:  CALL   045
0273:  INCF   65,F
0274:  MOVWF  20
0275:  MOVWF  6E
0276:  CALL   148
0277:  MOVLW  1B
0278:  SUBWF  65,W
0279:  BTFSS  03.2
027A:  GOTO   271
027B:  MOVLW  10
027C:  MOVWF  04
027D:  MOVF   62,W
027E:  MOVWF  67
027F:  MOVF   61,W
0280:  MOVWF  66
0281:  CALL   14A
....................   pid->maxSumError = MAX_I_TERM / (pid->I_Factor + 1); 
0282:  MOVLW  0E
0283:  ADDWF  5E,W
0284:  MOVWF  5F
0285:  MOVLW  08
0286:  ADDWF  5E,W
0287:  MOVWF  04
0288:  INCF   04,F
0289:  MOVF   00,W
028A:  MOVWF  61
028B:  DECF   04,F
028C:  MOVF   00,W
028D:  MOVWF  60
028E:  MOVLW  01
028F:  ADDWF  60,W
0290:  MOVWF  21
0291:  MOVF   61,W
0292:  MOVWF  23
0293:  BTFSC  03.0
0294:  INCF   23,F
0295:  MOVF   21,W
0296:  MOVWF  62
0297:  MOVF   23,W
0298:  MOVWF  63
0299:  MOVF   04,W
029A:  MOVWF  64
029B:  MOVLW  3F
029C:  MOVWF  68
029D:  MOVLW  FF
029E:  MOVWF  67
029F:  MOVWF  66
02A0:  MOVWF  65
02A1:  CLRF   6C
02A2:  CLRF   6B
02A3:  MOVF   63,W
02A4:  MOVWF  6A
02A5:  MOVF   62,W
02A6:  MOVWF  69
*
02E7:  MOVF   64,W
02E8:  MOVWF  04
02E9:  MOVF   5F,W
02EA:  MOVWF  04
02EB:  MOVF   20,W
02EC:  MOVWF  00
02ED:  INCF   04,F
02EE:  MOVF   21,W
02EF:  MOVWF  00
02F0:  INCF   04,F
02F1:  MOVF   22,W
02F2:  MOVWF  00
02F3:  INCF   04,F
02F4:  MOVF   23,W
02F5:  MOVWF  00
.................... } 
02F6:  BCF    0A.3
02F7:  GOTO   582 (RETURN)
....................  
....................  
.................... /*! \brief PID control algorithm. 
....................  * 
....................  *  Calculates output from setpoint, process value and PID status. 
....................  * 
....................  *  \param setPoint  Desired value. 
....................  *  \param processValue  Measured value. 
....................  *  \param pid_st  PID status struct. 
....................  */ 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st) 
.................... { 
....................   signed int16 error, p_term, d_term; 
....................   signed int32 i_term, ret, temp; 
....................     processValue=processValue/4; 
....................   //printf("input %ld speed %ld ",setPoint,processValue); 
....................   error = setPoint - processValue; 
....................    
....................   // Calculate Pterm and limit error overflow 
....................    
....................   if (error > (signed int16) pid_st->maxError){ 
....................     p_term = MAX_INT; 
....................     printf("p greater error %ld a %ld p %ld",error,pid_st->maxError,p_term); 
....................  
....................   } 
....................   else if (error < (signed int16) -pid_st->maxError){ 
....................     p_term = -MAX_INT; 
....................     printf("p less error %ld a %ld p %ld",error,-pid_st->maxError,p_term); 
....................  
....................   } 
....................   else{ 
....................     p_term = (signed int16) (pid_st->P_Factor * (float) error); 
....................     //printf("error %ld a %ld p %ld",error,pid_st->maxError,p_term); 
....................   } 
....................    
....................   // Calculate Iterm and limit integral runaway 
....................   temp = pid_st->sumError + error; 
....................   if(temp > (signed int32)pid_st->maxSumError){ 
....................     i_term = MAX_I_TERM; 
....................     pid_st->sumError = pid_st->maxSumError; 
....................     printf("\n greater temp %ld a %ld sum %ld",temp,pid_st->maxSumError,pid_st->sumError); 
....................  
....................  } 
....................   else if(temp < (signed int32)-pid_st->maxSumError){ 
....................     i_term = -MAX_I_TERM; 
....................     pid_st->sumError = -pid_st->maxSumError; 
....................     printf("\n less temp %ld a %ld sum %ld",temp,pid_st->maxSumError,pid_st->sumError); 
....................  
....................   } 
....................   else{ 
....................     pid_st->sumError = temp; 
....................     i_term = pid_st->I_Factor * pid_st->sumError; 
....................     //printf("\n eror temp %ld i_term %ld sum %ld error %ld ",temp,i_term,pid_st->sumError,error); 
....................  
....................   } 
....................  
....................   // Calculate Dterm 
....................   d_term = pid_st->D_Factor * (pid_st->lastProcessValue - processValue); 
.................... printf("\n p_term %ld d_term %ld i_term %ld",p_term,d_term,i_term); 
....................   pid_st->lastProcessValue = processValue; 
....................  
....................   //ret = (p_term + i_term + d_term) / SCALING_FACTOR; 
....................    ret = (p_term+d_term+(signed int16)i_term) / SCALING_FACTOR; 
....................   if(ret > MAX_INT){ 
....................     ret = MAX_INT; 
....................   } 
....................   else if(ret < -MAX_INT){ 
....................     ret = -MAX_INT; 
....................   } 
....................  
....................   return((signed int16)ret); 
.................... } 
....................  
.................... /*! \brief Resets the integrator. 
....................  * 
....................  *  Calling this function will reset the integrator in the PID regulator. 
....................  */ 
.................... void pid_Reset_Integrator(pidData_t *pid_st) 
.................... { 
....................   pid_st->sumError = 0; 
.................... } 
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
