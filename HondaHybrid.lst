CCS PCM C Compiler, Version 4.084, 46530               28-Dec-13 14:59

               Filename: HondaHybrid.lst

               ROM used: 2291 words (56%)
                         Largest free fragment is 1325
               RAM used: 56 (29%) at main() level
                         103 (54%) worst case
               Stack:    3 worst case (2 in main + 1 for interrupts)

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  26
0008:  MOVF   7F,W
0009:  MOVWF  25
000A:  MOVF   0A,W
000B:  MOVWF  2D
000C:  CLRF   0A
000D:  SWAPF  25,F
000E:  MOVF   04,W
000F:  MOVWF  27
0010:  MOVF   20,W
0011:  MOVWF  28
0012:  MOVF   21,W
0013:  MOVWF  29
0014:  MOVF   22,W
0015:  MOVWF  2A
0016:  MOVF   23,W
0017:  MOVWF  2B
0018:  MOVF   24,W
0019:  MOVWF  2C
001A:  BCF    03.7
001B:  BCF    03.5
001C:  MOVLW  8C
001D:  MOVWF  04
001E:  BTFSS  00.0
001F:  GOTO   022
0020:  BTFSC  0C.0
0021:  GOTO   03F
0022:  MOVLW  8C
0023:  MOVWF  04
0024:  BTFSS  00.2
0025:  GOTO   028
0026:  BTFSC  0C.2
0027:  GOTO   041
0028:  BTFSS  0B.5
0029:  GOTO   02C
002A:  BTFSC  0B.2
002B:  GOTO   043
002C:  MOVF   27,W
002D:  MOVWF  04
002E:  MOVF   28,W
002F:  MOVWF  20
0030:  MOVF   29,W
0031:  MOVWF  21
0032:  MOVF   2A,W
0033:  MOVWF  22
0034:  MOVF   2B,W
0035:  MOVWF  23
0036:  MOVF   2C,W
0037:  MOVWF  24
0038:  MOVF   2D,W
0039:  MOVWF  0A
003A:  SWAPF  26,W
003B:  MOVWF  03
003C:  SWAPF  7F,F
003D:  SWAPF  7F,W
003E:  RETFIE
003F:  BCF    0A.3
0040:  GOTO   053
0041:  BCF    0A.3
0042:  GOTO   0AB
0043:  BCF    0A.3
0044:  GOTO   045
.................... //#define DEBUG 
.................... //#define BOARDV1 
.................... //#define TEST 
.................... #include "HondaHybrid.h" 
.................... #include <16F873A.h> 
.................... //////// Standard Header file for the PIC16F873A device //////////////// 
.................... #device PIC16F873A 
.................... #list 
....................  
....................  
.................... #ifdef DEBUG 
....................    #device ICD=TRUE 
.................... #endif 
....................  
.................... #device adc=10 
.................... #use delay(clock=20000000) 
*
022B:  MOVLW  54
022C:  MOVWF  04
022D:  MOVF   00,W
022E:  BTFSC  03.2
022F:  GOTO   23D
0230:  MOVLW  06
0231:  MOVWF  21
0232:  CLRF   20
0233:  DECFSZ 20,F
0234:  GOTO   233
0235:  DECFSZ 21,F
0236:  GOTO   232
0237:  MOVLW  7B
0238:  MOVWF  20
0239:  DECFSZ 20,F
023A:  GOTO   239
023B:  DECFSZ 00,F
023C:  GOTO   230
023D:  RETLW  00
.................... #ifdef DEBUG 
....................    #use rs232 (DEBUGGER) 
.................... #endif 
.................... #fuses HS,PUT,NOWDT 
.................... #include <mcp4921.c> 
.................... //////////////// Driver for MCP4921 D/A Converter /////////////////////// 
.................... ////                                                                 //// 
.................... ////  init_dac()    Call this before using a MCP4921 DAC             //// 
.................... ////                                                                 //// 
.................... ////  write_dac( long int )   Writes command and 12 bit resolution   //// 
.................... ////                          to the MCP4921 which converts it to a  //// 
.................... ////                          voltage                                //// 
.................... ////                          0-4095 input represents 0-vref V out.  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SELECT 
....................  
.................... #define DAC_CS     PIN_C4 
.................... #define DAC_CLK    PIN_C3 
.................... #define DAC_DI     PIN_C5 
.................... #define DAC_LDAC   PIN_B4 
....................  
.................... #endif 
....................  
.................... void init_dac() 
.................... { 
....................    output_high(DAC_CS); 
*
00C8:  BCF    2E.4
00C9:  MOVF   2E,W
00CA:  BSF    03.5
00CB:  MOVWF  07
00CC:  BCF    03.5
00CD:  BSF    07.4
....................    output_high(DAC_LDAC); 
00CE:  BSF    03.5
00CF:  BCF    06.4
00D0:  BCF    03.5
00D1:  BSF    06.4
....................    output_high(DAC_CLK); 
00D2:  BCF    2E.3
00D3:  MOVF   2E,W
00D4:  BSF    03.5
00D5:  MOVWF  07
00D6:  BCF    03.5
00D7:  BSF    07.3
....................    output_high(DAC_DI); 
00D8:  BCF    2E.5
00D9:  MOVF   2E,W
00DA:  BSF    03.5
00DB:  MOVWF  07
00DC:  BCF    03.5
00DD:  BSF    07.5
.................... } 
00DE:  BSF    0A.3
00DF:  GOTO   047 (RETURN)
....................  
.................... void write_dac(int16 data) { 
....................    BYTE cmd[3]; 
....................    BYTE i; 
....................  
....................    cmd[0]=data; 
00E0:  MOVF   57,W
00E1:  MOVWF  59
....................    cmd[1]=(data>>8); 
00E2:  MOVF   58,W
00E3:  MOVWF  5A
....................    cmd[2]=0x03;                            
00E4:  MOVLW  03
00E5:  MOVWF  5B
....................     
....................    output_high(DAC_LDAC); 
00E6:  BSF    03.5
00E7:  BCF    06.4
00E8:  BCF    03.5
00E9:  BSF    06.4
....................    output_low(DAC_CLK); 
00EA:  BCF    2E.3
00EB:  MOVF   2E,W
00EC:  BSF    03.5
00ED:  MOVWF  07
00EE:  BCF    03.5
00EF:  BCF    07.3
....................    output_low(DAC_CS); 
00F0:  BCF    2E.4
00F1:  MOVF   2E,W
00F2:  BSF    03.5
00F3:  MOVWF  07
00F4:  BCF    03.5
00F5:  BCF    07.4
....................  
....................    for(i=0; i<=23; ++i) 
00F6:  CLRF   5C
00F7:  MOVF   5C,W
00F8:  SUBLW  17
00F9:  BTFSS  03.0
00FA:  GOTO   128
....................    { 
....................       if(i<4 || (i>7 && i<12)) 
00FB:  MOVF   5C,W
00FC:  SUBLW  03
00FD:  BTFSC  03.0
00FE:  GOTO   107
00FF:  MOVF   5C,W
0100:  SUBLW  07
0101:  BTFSC  03.0
0102:  GOTO   10C
0103:  MOVF   5C,W
0104:  SUBLW  0B
0105:  BTFSS  03.0
0106:  GOTO   10C
....................          shift_left(cmd,3,0); 
0107:  BCF    03.0
0108:  RLF    59,F
0109:  RLF    5A,F
010A:  RLF    5B,F
....................       else 
010B:  GOTO   126
....................       { 
....................          output_bit(DAC_DI, shift_left(cmd,3,0)); 
010C:  BCF    03.0
010D:  RLF    59,F
010E:  RLF    5A,F
010F:  RLF    5B,F
0110:  BTFSC  03.0
0111:  GOTO   114
0112:  BCF    07.5
0113:  GOTO   115
0114:  BSF    07.5
0115:  BCF    2E.5
0116:  MOVF   2E,W
0117:  BSF    03.5
0118:  MOVWF  07
....................  
....................          output_high(DAC_CLK); 
0119:  BCF    03.5
011A:  BCF    2E.3
011B:  MOVF   2E,W
011C:  BSF    03.5
011D:  MOVWF  07
011E:  BCF    03.5
011F:  BSF    07.3
....................          output_low(DAC_CLK); 
0120:  BCF    2E.3
0121:  MOVF   2E,W
0122:  BSF    03.5
0123:  MOVWF  07
0124:  BCF    03.5
0125:  BCF    07.3
....................       } 
....................    } 
0126:  INCF   5C,F
0127:  GOTO   0F7
....................    output_high(DAC_CS); 
0128:  BCF    2E.4
0129:  MOVF   2E,W
012A:  BSF    03.5
012B:  MOVWF  07
012C:  BCF    03.5
012D:  BSF    07.4
....................  
....................    output_low(DAC_LDAC); 
012E:  BSF    03.5
012F:  BCF    06.4
0130:  BCF    03.5
0131:  BCF    06.4
....................    delay_us(10); 
0132:  MOVLW  10
0133:  MOVWF  20
0134:  DECFSZ 20,F
0135:  GOTO   134
0136:  NOP
....................     
....................    output_HIGH(DAC_LDAC); 
0137:  BSF    03.5
0138:  BCF    06.4
0139:  BCF    03.5
013A:  BSF    06.4
.................... } 
013B:  RETLW  00
....................  
....................  
....................  
.................... #include "pid.h" 
.................... /*This file has been prepared for Doxygen automatic documentation generation.*/ 
.................... /*! \file ********************************************************************* 
....................  * 
....................  * \brief Header file for pid.c. 
....................  * 
....................  * - File:               pid.h 
....................  * - Compiler:           IAR EWAAVR 4.11A 
....................  * - Supported devices:  All AVR devices can be used. 
....................  * - AppNote:            AVR221 - Discrete PID controller 
....................  * 
....................  * \author               Atmel Corporation: http://www.atmel.com \n 
....................  *                       Support email: avr@atmel.com 
....................  * 
....................  * $Name$ 
....................  * $Revision: 456 $ 
....................  * $RCSfile$ 
....................  * $Date: 2006-02-16 12:46:13 +0100 (to, 16 feb 2006) $ 
....................  *****************************************************************************/ 
....................  
.................... #ifndef PID_H 
.................... #define PID_H 
....................  
.................... //#include "stdint.h" 
.................... #define INT16_MAX 32767 
.................... #define INT32_MAX 2147483647 
.................... #define SCALING_FACTOR  128 
....................  
.................... /*! \brief PID Status 
....................  * 
....................  * Setpoints and data used by the PID control algorithm 
....................  */ 
.................... typedef struct PID_DATA{ 
....................   //! Last process value, used to find derivative of process value. 
....................   int16 lastProcessValue; 
....................   //! Summation of errors, used for integrate calculations 
....................   int32 sumError; 
....................   //! The Proportional tuning constant, multiplied with SCALING_FACTOR 
....................   int16 P_Factor; 
....................   //! The Integral tuning constant, multiplied with SCALING_FACTOR 
....................   int16 I_Factor; 
....................   //! The Derivative tuning constant, multiplied with SCALING_FACTOR 
....................   int16 D_Factor; 
....................   //! Maximum allowed error, avoid overflow 
....................   int16 maxError; 
....................   //! Maximum allowed sumerror, avoid overflow 
....................   int32 maxSumError; 
.................... } pidData_t; 
....................  
.................... /*! \brief Maximum values 
....................  * 
....................  * Needed to avoid sign/overflow problems 
....................  */ 
.................... // Maximum value of variables 
.................... #define MAX_INT         INT16_MAX 
.................... #define MAX_LONG        INT32_MAX 
.................... #define MAX_I_TERM      (MAX_LONG / 2) 
....................  
.................... // Boolean values 
.................... //#define FALSE           0 
.................... //#define TRUE            1 
....................  
.................... boolean checkRunnaway(struct PID_DATA *pid); 
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid); 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st); 
.................... void pid_Reset_Integrator(pidData_t *pid_st); 
....................  
.................... #endif 
....................  
.................... /* 
.................... This is the main controller for the super capacitor hybrid scooter a.k.a RED 
.................... B2 close contactor 
.................... CONTROL BOX INPUTS 
.................... Athrottle- A0 - analog input representing the users input for speed, 10 bit 
.................... Vspeed - CCp2-a 16 bit representation of the speed of the vehicle 
.................... Acaps- A1 - analog input representing the current voltage of the supercapacitors, 10 bit 
.................... There are 18 Supercaps with a maximum voltage of 2.7 (2.85 is breakdown) volts for a total of 48.6 V 
.................... The circuit has a 10/110 voltage divider into the ADC. So minimum voltage of 18 Volts is 335 and 48 Volts is 893. Measured 38.2V equal to 726 
....................  
.................... CONTROL BOX OUTPUT 
.................... ICEthrottle- B1 - a 16 bit number sent to the internal combustion engine(ICE) throttle  
.................... ELECthrottle-  - a 16 bit number sent as analog value representing the demanded electric power 
....................  
.................... SPECIFICS OF I/O 
....................  
.................... Athrottle - the electric throttle is a 3 wire unit with a 5 volt,ground, and analog out 
....................    representing how far throttle is turned. Pin AN0 is the input. 
....................     
.................... Vspeed - There is a encoder in the rear wheel/electric motor that is used by the electric 
....................    power controller. Tapping in to this this Main Controller receives a 5 Volt square wave 
....................    with 42 pulses. There are two options for measuring speed. The first is to measure the  
....................    length of the pulses. The second is to measure the rate of pulses. This controller currently 
....................    uses the rate method. The int_ccp2 interupt is called on each falling edge and stores the  
....................    Vspeed value as the max number of 16bit (65535-timer0_since_last_reset).  
....................     
....................    The RED scooter has a circumpherence of 16.3*2*pi = 102.4 
....................    X m/h * 63360 inch/mile * 1/3600 h/sec * 1/(102.4 inch/rev) = .171875* X 
....................    Examples 50 mph is 8.9 ms 1 overflow of timer0 
....................    Example 5 mph is 89 ms or 13 time overflow 
....................     
....................    #int_timer0 increments the counter number_of_overflows each time it overflows 
....................    On int ccp2 we multiply number_of_overflows * 256 + timer0 to get timer0_since_last_reset 
....................     
.................... Acaps - the analog voltage which is the 5volt representation of the voltage in the caps which 
....................    have a value of between 0-48v. The voltages are factored so that the voltage on AN1 goes 
....................    from 0 - 4.8 volts (TODO check this factor, think its 1/11 not 1/10) 
....................     
.................... ICEthrottle -  #int_timer1 is set to make sure the period follows the required below 
....................    The period for the servo is .020 seconds which is 50,000 operations 
....................    The leftmost position of the server is .001 seconds which is 2,500 
....................    The rightmost position of the server is .002 seconds which is 5,000 
....................     
....................    The output pin is pin_B1.-> 
....................  
.................... ELECthrottle 
....................    The electric power controller takes an analog voltage as input. The output voltage 
....................    is set by the DAC. The pins used are C3,C4,C5. if CHARGING_STATE is true then  
....................     
.................... ALGORITHM 
....................    The algorithm is basically a PID controller. In broad terms we are trying to set the 
....................    ICEthrottle and ICEelectric to maximize the use of electric and accelerate to meet the 
....................    requirements set by the rider with the Athrottle signal. When the demanded power is  
....................    less than the power output possible by the ICE and the caps are in the CHARGING_STATE  
....................    then the ICE is turned up to the max and the ELECthrottle is set to regen to 
....................    charge the capacitors.If CHARGING_STATE is false then the caps are supplying the drivig power 
....................    and the ICE is set to "off", the caps supply the power. Unless the user requested supply 
....................    is enough to require both power sources. 
....................     
....................    If CHARGING_STATE is true. Then pin_b2 is set as high which will close the brake number 
....................    for the electric power controller.  
....................     
....................    If CHARGING_STATE is false then the pin_b2 is set low which opens brake. 
....................     
....................    
....................  
....................  
.................... The encoder has 42 on and offs per rotation, i.e. 21 steps 
....................  
.................... Number of operations per second is CLOCK/4/Timer Divisions 
.................... Number of operations per second is 20,000,000/4/128 = 39062.5  
.................... Each operation takes 1/39062.5 = .256 micro (x10^-6) seconds 
.................... Seconds to Overflow timer0 8bit timer = .256x10^-6 * 256 = 6.55ms 
....................  
....................   
....................  
.................... */ 
.................... #define servo_pin PIN_B1  //Setting servo out pin to be hardware pin b1 
.................... #define brake_pin PIN_B4 
.................... #define ADC_DELAY delay_us(20) 
.................... #define Acaps_pin PIN_A1 
.................... #define Acaps_channel 1 
.................... #define Athrottle_pin PIN_A0  //Voltage goes from 1.5 (306)to 4.1(836) 
.................... #define Athrottle_Min 316 
.................... #define Athrottle_Max 860 
.................... #define Athrottle_3quarter 520 
.................... #define Athrottle_Full Athrottle_Max-Athrottle_Min 
.................... #define Athrottle_channel 0 
.................... #ifdef BOARDV1 
.................... #define Electric_Controller_Switch PIN_B0 
.................... #define Contactor_Switch PIN_B2 
.................... #else 
.................... #define Contactor_Switch PIN_B5 
.................... #define Controller_Power_Switch PIN_B2 
.................... #define Electric_Controller_Switch PIN_B0 //this is the switch from acceleration/breaking with driving high as breaking 
.................... #define ALGORITHM_INPUT_SWITCH PIN_A2 
.................... #endif 
.................... #define A_CAPS_MAX 725//893 
.................... #define A_CAPS_MIN 400//335 
.................... #define A_CAPS_MID_LOW (A_CAPS_MIN + 100) //This is the low end of the middle ACaps range. The range in which discharge and charge are allowed.  
.................... #define A_CAPS_MID_HIGH (A_CAPS_MAX - 100) //This is the low end of the middle ACaps range. The range in which discharge and charge are allowed.  
.................... #define V_SPEED_REGEN_MIN 250 //Why is there a minimum speed? Because below this no regenerative action is possible with electric motor 
.................... #define INSUFFICIENT_BRAKING_RUNNAWAY_ERROR 50000 
....................  
.................... //PID Values 
.................... #define K_P 1.50 
.................... #define K_I 0.00 
.................... #define K_D 0.20 
....................  
.................... struct PID_DATA pidData; 
.................... #define TIME_INTERVAL 157 //TODO replace 
....................  
.................... #define left_position 2500//4450 
.................... #define right_position 4600 
.................... #define servo_difference  right_position-left_position 
.................... #define servo_difference_div 5200 
.................... #define ELEC_CONTROLLER_OFFSET 900 
.................... //const float Athrottle_servo_factor = ((float) servo_difference)/((float) Athrottle_FULL); 
.................... #define servo_period   65356-50000 
.................... unsigned int16 current_servo_position=right_position; 
*
080D:  MOVLW  F8
080E:  MOVWF  41
080F:  MOVLW  11
0810:  MOVWF  42
.................... int1 SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0; 
0811:  BCF    43.0
....................  
.................... unsigned int16 number_of_timer0_interupts_since_reset =0; 
0812:  CLRF   44
0813:  CLRF   45
.................... unsigned int16 vSpeed= 0; 
0814:  CLRF   46
0815:  CLRF   47
.................... signed int16 ELECthrottle = 0; 
0816:  CLRF   48
0817:  CLRF   49
.................... unsigned int16 ICEthrottle = 0; 
0818:  CLRF   4A
0819:  CLRF   4B
.................... unsigned int16 Athrottle = 0; 
081A:  CLRF   4C
081B:  CLRF   4D
.................... unsigned int16 Acaps = 0; 
081C:  CLRF   4E
081D:  CLRF   4F
.................... int1 ICE_ON = 0; 
081E:  BCF    43.1
.................... int1 CURRENTLY_CHARGING = 0; 
081F:  BCF    43.2
.................... int1 RUNNAWAY_CHECK = 0; 
0820:  BCF    43.3
.................... signed int16 returnedValue =0; 
0821:  CLRF   50
0822:  CLRF   51
....................  
.................... enum{  
....................    EVERYTHING_OFF, 
....................    SPEED_TO_LOW_ICE_DIRECT, 
....................    CHARGING_ALLOWED,  
....................    DISCHARGING_ALLOWED,  
....................    CHARGING_AND_DISCHARING_ALLOWED, 
....................    INSUFFICIENT_BRAKING_RUNAWAY, 
....................    USER_INPUT_OFF 
.................... } CHARGING_STATE; 
....................  
.................... /* 
.................... The #int_timer0 interupt is triggered on each timer0 8bit interupt 
.................... the function simply increments a overflow counter to be used by the ccp2 
.................... interupt to calculate speed 
.................... NUMBER OF OPERATIONS =  
.................... */ 
.................... #int_timer0 
.................... void timer0_isr(){ 
....................     
....................       number_of_timer0_interupts_since_reset=number_of_timer0_interupts_since_reset+256; 
*
0045:  MOVLW  01
0046:  ADDWF  45,F
....................       //current_servo_position=current_servo_position+1; 
....................        
....................     
....................    if (number_of_timer0_interupts_since_reset>=1024){ 
0047:  MOVF   45,W
0048:  SUBLW  03
0049:  BTFSC  03.0
004A:  GOTO   050
....................       vSpeed = 0; 
004B:  CLRF   47
004C:  CLRF   46
....................       number_of_timer0_interupts_since_reset=1024; 
004D:  MOVLW  04
004E:  MOVWF  45
004F:  CLRF   44
....................        
....................        
....................    } 
.................... } 
....................  
.................... /* 
.................... #int_timer1 is used by the ICEservo throttle to regulate the timing pulses. The  
.................... timer is setup for a pulsetrain of 20ms period. This is done as follows, 
....................  
.................... Period is 1/(CLOCK/4opsperclock)*(startingPostionOfClock) = 20 ms 
.................... for this setup 1/(20000000/4)*(50000) = 20 ms 
....................  
.................... The timer1 starts at 0 and counts up. So we set the beggining of the clock at 
.................... servo_period which is 65356-50000 so that the total time is 20ms. 
.................... */ 
0050:  BCF    0B.2
0051:  BCF    0A.3
0052:  GOTO   02C
.................... #int_timer1 
.................... void isr() 
.................... { 
....................  
.................... //Make sure that the position is within the left and right positions of the servo 
....................    if (current_servo_position<left_position){ 
0053:  MOVF   42,W
0054:  SUBLW  09
0055:  BTFSS  03.0
0056:  GOTO   062
0057:  BTFSS  03.2
0058:  GOTO   05D
0059:  MOVF   41,W
005A:  SUBLW  C3
005B:  BTFSS  03.0
005C:  GOTO   062
....................       current_servo_position = left_position; 
005D:  MOVLW  09
005E:  MOVWF  42
005F:  MOVLW  C4
0060:  MOVWF  41
....................    } 
....................    else if (current_servo_position > right_position){ 
0061:  GOTO   071
0062:  MOVF   42,W
0063:  SUBLW  10
0064:  BTFSC  03.0
0065:  GOTO   071
0066:  XORLW  FF
0067:  BTFSS  03.2
0068:  GOTO   06D
0069:  MOVF   41,W
006A:  SUBLW  F8
006B:  BTFSC  03.0
006C:  GOTO   071
....................       current_servo_position = right_position; 
006D:  MOVLW  11
006E:  MOVWF  42
006F:  MOVLW  F8
0070:  MOVWF  41
....................    } 
.................... //printf("Current servo position %ld",current_servo_position); 
....................    if(SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER) 
0071:  BTFSS  43.0
0072:  GOTO   090
....................       {  
....................          output_high(servo_pin);        //Set the servo control pin to high  
0073:  BSF    03.5
0074:  BCF    06.1
0075:  BCF    03.5
0076:  BSF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0;  
0077:  BCF    43.0
....................          set_timer1(65356-current_servo_position); //Set timer for the position high pulse 
0078:  MOVF   41,W
0079:  SUBLW  4C
007A:  BSF    03.5
007B:  MOVWF  25
007C:  MOVLW  FF
007D:  MOVWF  26
007E:  BCF    03.5
007F:  MOVF   42,W
0080:  BTFSS  03.0
0081:  INCFSZ 42,W
0082:  GOTO   084
0083:  GOTO   087
0084:  BSF    03.5
0085:  SUBWF  26,F
0086:  BCF    03.5
0087:  BSF    03.5
0088:  MOVF   26,W
0089:  BCF    03.5
008A:  MOVWF  0F
008B:  BSF    03.5
008C:  MOVF   25,W
008D:  BCF    03.5
008E:  MOVWF  0E
....................       }  
....................    else  
008F:  GOTO   0A8
....................       {  
....................          output_low(servo_pin);                      // Set the servo control pin to low   
0090:  BSF    03.5
0091:  BCF    06.1
0092:  BCF    03.5
0093:  BCF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 1;  
0094:  BSF    43.0
....................          set_timer1(servo_period+current_servo_position);          //Set timer for the low position the length is the difference between  
0095:  MOVLW  FC
0096:  ADDWF  41,W
0097:  BSF    03.5
0098:  MOVWF  25
0099:  BCF    03.5
009A:  MOVF   42,W
009B:  BSF    03.5
009C:  MOVWF  26
009D:  MOVLW  3B
009E:  BTFSC  03.0
009F:  MOVLW  3C
00A0:  ADDWF  26,F
00A1:  MOVF   26,W
00A2:  BCF    03.5
00A3:  MOVWF  0F
00A4:  BSF    03.5
00A5:  MOVF   25,W
00A6:  BCF    03.5
00A7:  MOVWF  0E
....................                                                      //the total int16 lenght - high pulse length 
....................       }  
....................  
.................... } 
....................  
....................  
.................... /* 
.................... #int_ccp2 is called on the falling edge of the encoder pulse. We calculate the time 
.................... between pulses.  
.................... TODO will have to put some kind of smoothing mechanism 
.................... */ 
.................... #ifdef BOARDV1 
.................... #int_ccp2 
.................... #else 
00A8:  BCF    0C.0
00A9:  BCF    0A.3
00AA:  GOTO   02C
.................... #int_ccp1 
.................... #endif 
.................... void isr2() 
.................... { 
.................... if (number_of_timer0_interupts_since_reset>10){ 
00AB:  MOVF   45,F
00AC:  BTFSS  03.2
00AD:  GOTO   0B2
00AE:  MOVF   44,W
00AF:  SUBLW  0A
00B0:  BTFSC  03.0
00B1:  GOTO   0C5
.................... vSpeed  = 1280 - (number_of_timer0_interupts_since_reset+get_timer0()); 
00B2:  MOVF   01,W
00B3:  ADDWF  44,W
00B4:  MOVWF  21
00B5:  MOVF   45,W
00B6:  MOVWF  23
00B7:  BTFSC  03.0
00B8:  INCF   23,F
00B9:  MOVF   21,W
00BA:  SUBLW  00
00BB:  MOVWF  46
00BC:  MOVLW  05
00BD:  MOVWF  47
00BE:  MOVF   23,W
00BF:  BTFSS  03.0
00C0:  INCFSZ 23,W
00C1:  SUBWF  47,F
.................... //vSpeed  = -(get_timer0()); 
.................... set_timer0(0); 
00C2:  CLRF   01
.................... number_of_timer0_interupts_since_reset = 0; 
00C3:  CLRF   45
00C4:  CLRF   44
.................... } 
.................... } 
....................  
00C5:  BCF    0C.2
00C6:  BCF    0A.3
00C7:  GOTO   02C
.................... void trickBreaking(){ 
.................... write_dac((unsigned int16) 400+ELEC_CONTROLLER_OFFSET); 
.................... delay_ms(500);       
.................... } 
....................  
.................... void printfLogf(char string){ 
....................    #ifdef DEBUG 
....................       printf("IN PrintfLog"); 
....................       printf("%c",string); 
....................    #else 
....................       //delay_ms(250); 
....................    #endif 
.................... } 
....................  
.................... #ifdef TEST 
....................  
.................... /* 
.................... TEST SUITE 
.................... */ 
....................  
.................... void createHeartbeat(){ 
....................   //This creates a heartbeat on pin B1 
....................   while (1){ 
....................            output_high(servo_pin);        //Set the servo control pin to high 
....................            delay_ms(1000); 
....................            output_low(servo_pin); 
....................            delay_ms(1000); 
....................     } 
.................... } 
....................  
.................... void wiperAnalogVoltage(){ 
....................   
....................  //signed int16 test =0; 
....................  unsigned int16 wiperValue = 0; 
....................     while (1){ 
.................... printf("Wiper Value is now %ld",wiperValue); 
....................    
....................   if (wiperValue>(4095)){ 
....................      wiperValue = 0; 
....................     printf("Wiper Value is now %ld",wiperValue); 
....................   } 
....................   wiperValue=wiperValue+10; 
....................   write_dac(wiperValue); 
....................   delay_ms(10); 
....................     } 
.................... } 
....................  
.................... void heartbeatElectricControllerPower(){ 
....................     while (1){ 
....................  
....................   output_high(Contactor_Switch);        //Set the servo control pin to high 
....................            delay_ms(1000); 
....................            output_low(Contactor_Switch); 
....................            delay_ms(1000); 
....................     } 
.................... } 
....................  
.................... void wiperServo(){ 
....................     unsigned int32 wiperValue = 0; 
....................   current_servo_position = left_position; 
....................     while (1){ 
....................   printf("Servo Value %ld",current_servo_position); 
....................   if ((current_servo_position+10)>right_position){ 
....................     current_servo_position = left_position;//servo_difference; 
....................   } 
....................   current_servo_position =current_servo_position+10; 
....................   //delay_ms(1); 
....................     } 
.................... } 
....................  
.................... void printAnalogThrottleInput(){ 
....................     set_adc_channel(Athrottle_channel); 
....................       ADC_DELAY; 
....................       Athrottle = read_adc(); 
....................   printf("Analog Throttle is %ld",Athrottle ); 
.................... } 
....................  
.................... void main() 
.................... { 
....................  
....................    setup_adc_ports(NO_ANALOGS); 
....................    setup_adc(ADC_OFF); 
....................    setup_spi(FALSE); 
....................  
....................    setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
....................    setup_timer_1(T1_DISABLED); 
....................    setup_timer_2(T2_DISABLED,0,1); 
....................    setup_port_a(ALL_ANALOG); 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
....................  
....................    init_dac(); 
....................  
....................    setup_timer_1(T1_DIV_BY_2| T1_INTERNAL); 
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_128); 
....................        // Configure CCP2 to capture fall 
....................    #ifdef BOARDV1 
....................    setup_ccp2(CCP_CAPTURE_RE); 
....................    enable_interrupts(INT_CCP2);   // Setup interrupt on falling edge 
....................    #else 
....................    setup_ccp1(CCP_CAPTURE_RE); 
....................    enable_interrupts(INT_CCP1); 
....................    #endif 
....................    enable_interrupts(INT_TIMER0); 
....................    enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
....................    enable_interrupts(GLOBAL); 
....................  
....................  
....................    CHARGING_STATE = EVERYTHING_OFF; 
....................    output_high(Electric_Controller_Switch); 
....................    output_high(Controller_Power_Switch); 
....................    write_dac(0); 
....................    ICE_ON=TRUE; 
....................    output_high(Contactor_Switch); 
....................    output_high(brake_pin); 
....................    pid_Init(K_P*SCALING_FACTOR,K_I*SCALING_FACTOR,K_D*SCALING_FACTOR, & pidData); 
....................    delay_ms(3000); 
....................    current_servo_position =right_position-1000; 
....................    delay_ms(3000); 
....................    current_servo_position =right_position; 
....................    //write_dac(1000); 
....................    //delay_ms(10000); 
....................    //output_high(Contactor_Switch); 
....................    //output_high(brake_pin); 
....................    //output_high(Electric_Controller_Switch); 
....................    while(TRUE) { 
....................        
....................       //GET INPUTS 
....................       //Vspeedhappens in interrupts 
....................       //set_adc_channel(Acaps_channel); 
....................       //ADC_DELAY; 
....................       //Acaps = read_adc(); 
....................        
....................       //set_adc_channel(Athrottle_channel); 
....................       //ADC_DELAY; 
....................       //Athrottle = read_adc(); 
....................       //current_servo_position = right_position - (Athrottle-Athrottle_Min)*4; 
....................       //#ifdef DEBUG 
....................             printf("State: Weak HybridTEZT \n");   
....................         // #else 
....................          //   delay_ms(250); 
....................         /// #endif 
....................       //if ((Athrottle>Athrottle_3quarter)&&(Acaps>A_CAPS_MIN)){ 
....................          //CURRENTLY_CHARGING=1; 
....................           
....................          output_low(Electric_Controller_Switch); 
....................          write_dac(0); 
....................          output_low(brake_pin); 
....................          //set electric motor to drive 
....................          //#ifdef DEBUG 
....................            // printf("drive \n");   
....................          //#else 
....................            // delay_ms(250); 
....................          //#endif 
....................           
....................           
....................       //} 
....................       } 
....................  
.................... } 
....................  
....................   
....................  
.................... #else 
.................... void main() 
.................... {   
*
0800:  CLRF   04
0801:  MOVLW  1F
0802:  ANDWF  03,F
0803:  BSF    03.5
0804:  BSF    1F.0
0805:  BSF    1F.1
0806:  BSF    1F.2
0807:  BCF    1F.3
0808:  MOVLW  07
0809:  MOVWF  1C
....................     
....................    setup_adc_ports(NO_ANALOGS); 
*
0823:  BSF    03.5
0824:  BSF    1F.0
0825:  BSF    1F.1
0826:  BSF    1F.2
0827:  BCF    1F.3
....................    setup_adc(ADC_OFF); 
0828:  BCF    03.5
0829:  BCF    1F.0
....................    setup_spi(FALSE); 
082A:  CLRF   14
....................     
....................    setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
082B:  BSF    03.5
082C:  MOVF   01,W
082D:  ANDLW  C0
082E:  IORLW  00
082F:  MOVWF  01
0830:  CLRWDT
....................    setup_timer_1(T1_DISABLED); 
0831:  BCF    03.5
0832:  CLRF   10
....................    setup_timer_2(T2_DISABLED,0,1); 
0833:  MOVLW  00
0834:  MOVWF  21
0835:  MOVWF  12
0836:  MOVLW  00
0837:  BSF    03.5
0838:  MOVWF  12
....................    setup_port_a(AN0_AN1_AN3); 
0839:  BCF    1F.0
083A:  BCF    1F.1
083B:  BSF    1F.2
083C:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
083D:  BCF    1F.6
083E:  BCF    03.5
083F:  BSF    1F.6
0840:  BSF    1F.7
0841:  BSF    03.5
0842:  BSF    1F.7
0843:  BCF    03.5
0844:  BSF    1F.0
....................     
....................    init_dac(); 
0845:  BCF    0A.3
0846:  GOTO   0C8
0847:  BSF    0A.3
....................   
....................    setup_timer_1(T1_DIV_BY_2| T1_INTERNAL);  
0848:  MOVLW  95
0849:  MOVWF  10
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_128); 
084A:  BSF    03.5
084B:  MOVF   01,W
084C:  ANDLW  C0
084D:  IORLW  06
084E:  MOVWF  01
....................    #ifdef BOARDV1 
....................    setup_ccp2(CCP_CAPTURE_RE); 
....................    enable_interrupts(INT_CCP2);   // Setup interrupt on falling edge 
....................    #else 
....................    setup_ccp1(CCP_CAPTURE_RE); 
084F:  BCF    03.5
0850:  BSF    2E.2
0851:  MOVF   2E,W
0852:  BSF    03.5
0853:  MOVWF  07
0854:  BCF    03.5
0855:  CLRF   17
0856:  MOVLW  05
0857:  MOVWF  17
....................    enable_interrupts(INT_CCP1); 
0858:  BSF    03.5
0859:  BSF    0C.2
....................    #endif 
....................    enable_interrupts(INT_TIMER0); 
085A:  BCF    03.5
085B:  BSF    0B.5
....................    enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
085C:  BSF    03.5
085D:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
085E:  MOVLW  C0
085F:  BCF    03.5
0860:  IORWF  0B,F
....................     
....................     
....................     
....................     
....................    CHARGING_STATE = EVERYTHING_OFF; 
0861:  CLRF   52
....................    output_high(Electric_Controller_Switch); 
0862:  BSF    03.5
0863:  BCF    06.0
0864:  BCF    03.5
0865:  BSF    06.0
....................    output_high(Controller_Power_Switch); 
0866:  BSF    03.5
0867:  BCF    06.2
0868:  BCF    03.5
0869:  BSF    06.2
....................    write_dac(0); 
086A:  CLRF   58
086B:  CLRF   57
086C:  BCF    0A.3
086D:  CALL   0E0
086E:  BSF    0A.3
....................    ICE_ON=TRUE; 
086F:  BSF    43.1
....................    output_high(Contactor_Switch); 
0870:  BSF    03.5
0871:  BCF    06.5
0872:  BCF    03.5
0873:  BSF    06.5
....................    output_high(brake_pin); 
0874:  BSF    03.5
0875:  BCF    06.4
0876:  BCF    03.5
0877:  BSF    06.4
....................    pid_Init(K_P*SCALING_FACTOR,K_I*SCALING_FACTOR,K_D*SCALING_FACTOR, & pidData); 
0878:  CLRF   54
0879:  MOVLW  C0
087A:  MOVWF  53
087B:  CLRF   56
087C:  CLRF   55
087D:  CLRF   58
087E:  MOVLW  19
087F:  MOVWF  57
0880:  MOVLW  2F
0881:  MOVWF  59
0882:  BCF    0A.3
0883:  GOTO   13C
0884:  BSF    0A.3
....................    delay_ms(3000); 
0885:  MOVLW  0C
0886:  MOVWF  53
0887:  MOVLW  FA
0888:  MOVWF  54
0889:  BCF    0A.3
088A:  CALL   22B
088B:  BSF    0A.3
088C:  DECFSZ 53,F
088D:  GOTO   087
....................    current_servo_position =right_position-1000; 
088E:  MOVLW  0E
088F:  MOVWF  42
0890:  MOVLW  10
0891:  MOVWF  41
....................    delay_ms(3000); 
0892:  MOVLW  0C
0893:  MOVWF  53
0894:  MOVLW  FA
0895:  MOVWF  54
0896:  BCF    0A.3
0897:  CALL   22B
0898:  BSF    0A.3
0899:  DECFSZ 53,F
089A:  GOTO   094
....................    current_servo_position =right_position; 
089B:  MOVLW  11
089C:  MOVWF  42
089D:  MOVLW  F8
089E:  MOVWF  41
....................    //write_dac(1000); 
....................    //delay_ms(10000); 
....................    //output_high(Contactor_Switch); 
....................    //output_high(brake_pin); 
....................    //output_high(Electric_Controller_Switch); 
....................    while(TRUE) { 
....................        
....................       //GET INPUTS 
....................       //Vspeedhappens in interrupts 
....................       set_adc_channel(Acaps_channel); 
089F:  MOVLW  08
08A0:  MOVWF  21
08A1:  MOVF   1F,W
08A2:  ANDLW  C7
08A3:  IORWF  21,W
08A4:  MOVWF  1F
....................       ADC_DELAY; 
08A5:  MOVLW  21
08A6:  MOVWF  20
08A7:  DECFSZ 20,F
08A8:  GOTO   0A7
....................       Acaps = read_adc(); 
08A9:  BSF    1F.2
08AA:  BTFSC  1F.2
08AB:  GOTO   0AA
08AC:  BSF    03.5
08AD:  MOVF   1E,W
08AE:  BCF    03.5
08AF:  MOVWF  4E
08B0:  MOVF   1E,W
08B1:  MOVWF  4F
....................        
....................       set_adc_channel(Athrottle_channel); 
08B2:  MOVLW  00
08B3:  MOVWF  21
08B4:  MOVF   1F,W
08B5:  ANDLW  C7
08B6:  IORWF  21,W
08B7:  MOVWF  1F
....................       ADC_DELAY; 
08B8:  MOVLW  21
08B9:  MOVWF  20
08BA:  DECFSZ 20,F
08BB:  GOTO   0BA
....................       Athrottle = read_adc(); 
08BC:  BSF    1F.2
08BD:  BTFSC  1F.2
08BE:  GOTO   0BD
08BF:  BSF    03.5
08C0:  MOVF   1E,W
08C1:  BCF    03.5
08C2:  MOVWF  4C
08C3:  MOVF   1E,W
08C4:  MOVWF  4D
....................       if (!input(ALGORITHM_INPUT_SWITCH)){ 
08C5:  BSF    03.5
08C6:  BSF    05.2
08C7:  BCF    03.5
08C8:  BTFSC  05.2
08C9:  GOTO   13A
....................       delay_ms(1); 
08CA:  MOVLW  01
08CB:  MOVWF  54
08CC:  BCF    0A.3
08CD:  CALL   22B
08CE:  BSF    0A.3
....................       current_servo_position = right_position - (Athrottle-Athrottle_Min)*4; 
08CF:  MOVLW  3C
08D0:  SUBWF  4C,W
08D1:  MOVWF  53
08D2:  MOVF   4D,W
08D3:  MOVWF  54
08D4:  MOVLW  01
08D5:  BTFSS  03.0
08D6:  MOVLW  02
08D7:  SUBWF  54,F
08D8:  RLF    53,W
08D9:  MOVWF  22
08DA:  RLF    54,W
08DB:  MOVWF  23
08DC:  RLF    22,F
08DD:  RLF    23,F
08DE:  MOVLW  FC
08DF:  ANDWF  22,F
08E0:  MOVF   22,W
08E1:  SUBLW  F8
08E2:  MOVWF  41
08E3:  MOVLW  11
08E4:  MOVWF  42
08E5:  MOVF   23,W
08E6:  BTFSS  03.0
08E7:  INCFSZ 23,W
08E8:  SUBWF  42,F
....................       #ifdef DEBUG 
....................             printf("State: Weak Hybrid %ld\n",vSpeed);   
....................          //#else 
....................            // delay_ms(250); 
....................          #endif 
....................       if ((Athrottle>Athrottle_3quarter)&&(Acaps>A_CAPS_MIN)){ 
08E9:  MOVF   4D,W
08EA:  SUBLW  01
08EB:  BTFSC  03.0
08EC:  GOTO   10F
08ED:  XORLW  FF
08EE:  BTFSS  03.2
08EF:  GOTO   0F4
08F0:  MOVF   4C,W
08F1:  SUBLW  08
08F2:  BTFSC  03.0
08F3:  GOTO   10F
08F4:  MOVF   4F,W
08F5:  SUBLW  00
08F6:  BTFSC  03.0
08F7:  GOTO   10F
08F8:  XORLW  FF
08F9:  BTFSS  03.2
08FA:  GOTO   0FF
08FB:  MOVF   4E,W
08FC:  SUBLW  90
08FD:  BTFSC  03.0
08FE:  GOTO   10F
....................          //CURRENTLY_CHARGING=1; 
....................  
....................          output_low(Electric_Controller_Switch); 
08FF:  BSF    03.5
0900:  BCF    06.0
0901:  BCF    03.5
0902:  BCF    06.0
....................          write_dac(2000); 
0903:  MOVLW  07
0904:  MOVWF  58
0905:  MOVLW  D0
0906:  MOVWF  57
0907:  BCF    0A.3
0908:  CALL   0E0
0909:  BSF    0A.3
....................          output_low(brake_pin); 
090A:  BSF    03.5
090B:  BCF    06.4
090C:  BCF    03.5
090D:  BCF    06.4
....................          //set electric motor to drive 
....................          #ifdef DEBUG 
....................             printf("drivex \n");   
....................          //#else 
....................           //  delay_ms(250); 
....................          #endif 
....................           
....................           
....................       }else if ((Acaps<A_CAPS_MAX)&&(vSpeed>V_SPEED_REGEN_MIN)){ 
090E:  GOTO   139
090F:  MOVF   4F,W
0910:  SUBLW  02
0911:  BTFSS  03.0
0912:  GOTO   133
0913:  BTFSS  03.2
0914:  GOTO   119
0915:  MOVF   4E,W
0916:  SUBLW  D4
0917:  BTFSS  03.0
0918:  GOTO   133
0919:  MOVF   47,F
091A:  BTFSS  03.2
091B:  GOTO   120
091C:  MOVF   46,W
091D:  SUBLW  FA
091E:  BTFSC  03.0
091F:  GOTO   133
....................          // set electric motor to charge 
....................          #ifdef DEBUG 
....................             printf("breakingy \n");   
....................          //#else 
....................            // delay_ms(250); 
....................          #endif 
....................          if (CURRENTLY_CHARGING==1){ 
0920:  BTFSS  43.2
0921:  GOTO   122
....................         //        trickBreaking(); 
....................          } 
....................          CURRENTLY_CHARGING=0; 
0922:  BCF    43.2
....................           
....................          output_high(Electric_Controller_Switch); 
0923:  BSF    03.5
0924:  BCF    06.0
0925:  BCF    03.5
0926:  BSF    06.0
....................          write_dac(1200+ELEC_CONTROLLER_OFFSET); 
0927:  MOVLW  08
0928:  MOVWF  58
0929:  MOVLW  34
092A:  MOVWF  57
092B:  BCF    0A.3
092C:  CALL   0E0
092D:  BSF    0A.3
....................          output_high(brake_pin); 
092E:  BSF    03.5
092F:  BCF    06.4
0930:  BCF    03.5
0931:  BSF    06.4
....................       }else { 
0932:  GOTO   139
....................          //set electric motor to zero 
....................          #ifdef DEBUG 
....................             printf("turn off motor \n");   
....................          //#else 
....................            // delay_ms(250); 
....................          #endif 
....................          CURRENTLY_CHARGING=1; 
0933:  BSF    43.2
....................          write_dac(0); 
0934:  CLRF   58
0935:  CLRF   57
0936:  BCF    0A.3
0937:  CALL   0E0
0938:  BSF    0A.3
....................       } 
....................       }else{ 
0939:  GOTO   2D1
....................       delay_ms(1000); 
093A:  MOVLW  04
093B:  MOVWF  53
093C:  MOVLW  FA
093D:  MOVWF  54
093E:  BCF    0A.3
093F:  CALL   22B
0940:  BSF    0A.3
0941:  DECFSZ 53,F
0942:  GOTO   13C
....................       if (Athrottle<Athrottle_Min){ 
0943:  MOVF   4D,W
0944:  SUBLW  01
0945:  BTFSS  03.0
0946:  GOTO   151
0947:  BTFSS  03.2
0948:  GOTO   14D
0949:  MOVF   4C,W
094A:  SUBLW  3B
094B:  BTFSS  03.0
094C:  GOTO   151
....................          Athrottle=Athrottle_Min; 
094D:  MOVLW  01
094E:  MOVWF  4D
094F:  MOVLW  3C
0950:  MOVWF  4C
....................       } 
....................       //SET THE STATE 
....................       if (Acaps> (A_CAPS_MAX +10)){ 
0951:  MOVF   4F,W
0952:  SUBLW  01
0953:  BTFSC  03.0
0954:  GOTO   169
0955:  XORLW  FF
0956:  BTFSS  03.2
0957:  GOTO   15C
0958:  MOVF   4E,W
0959:  SUBLW  DF
095A:  BTFSC  03.0
095B:  GOTO   169
....................          //FREAK OUT 
....................          //printf("State: Freak Out \n"); 
....................         output_low(Electric_Controller_Switch); 
095C:  BSF    03.5
095D:  BCF    06.0
095E:  BCF    03.5
095F:  BCF    06.0
....................          #ifdef DEBUG 
....................             printf("State: FREAK OUT \n");   
....................          //#else 
....................            // delay_ms(250); 
....................          #endif 
....................          write_dac(0); 
0960:  CLRF   58
0961:  CLRF   57
0962:  BCF    0A.3
0963:  CALL   0E0
0964:  BSF    0A.3
....................          //ICE_ON = FALSE; 
....................          ICEthrottle = 0; 
0965:  CLRF   4B
0966:  CLRF   4A
....................          //output_high(Contactor_Switch); 
....................          CHARGING_STATE =EVERYTHING_OFF; 
0967:  CLRF   52
....................         //return; 
....................         //break; 
....................       } 
....................       else if (Athrottle<(Athrottle_Min+5)){ 
0968:  GOTO   1C4
0969:  MOVF   4D,W
096A:  SUBLW  01
096B:  BTFSS  03.0
096C:  GOTO   176
096D:  BTFSS  03.2
096E:  GOTO   173
096F:  MOVF   4C,W
0970:  SUBLW  40
0971:  BTFSS  03.0
0972:  GOTO   176
....................          CHARGING_STATE = USER_INPUT_OFF; 
0973:  MOVLW  06
0974:  MOVWF  52
....................          #ifdef DEBUG 
....................             printf("State: Throttle Off \n");   
....................          //#else 
....................            // delay_ms(250); 
....................          #endif 
....................           
....................          } 
....................       else if (ICE_ON&&(vSpeed<V_SPEED_REGEN_MIN)){ 
0975:  GOTO   1C4
0976:  BTFSS  43.1
0977:  GOTO   182
0978:  MOVF   47,F
0979:  BTFSS  03.2
097A:  GOTO   182
097B:  MOVF   46,W
097C:  SUBLW  F9
097D:  BTFSS  03.0
097E:  GOTO   182
....................          #ifdef DEBUG 
....................             printf("State: Speed To Low %ld \n",vSpeed);   
....................          //#else 
....................            // delay_ms(250); 
....................          #endif 
....................          CHARGING_STATE=SPEED_TO_LOW_ICE_DIRECT; 
097F:  MOVLW  01
0980:  MOVWF  52
....................       } 
....................       else if (checkRunnaway(& pidData)){// INSUFFICIENT_BRAKING_RUNNAWAY_ERROR){ 
0981:  GOTO   1C4
0982:  MOVLW  2F
0983:  MOVWF  53
0984:  BCF    0A.3
0985:  GOTO   23E
0986:  BSF    0A.3
0987:  MOVF   21,F
0988:  BTFSC  03.2
0989:  GOTO   18E
....................          #ifdef DEBUG 
....................             printf("State: RUNNAWAY \n");   
....................          //#else 
....................            // delay_ms(250); 
....................          #endif 
....................          ICE_ON=TRUE; 
098A:  BSF    43.1
....................          CHARGING_STATE=INSUFFICIENT_BRAKING_RUNAWAY; 
098B:  MOVLW  05
098C:  MOVWF  52
....................       } 
....................       else if ((Acaps > A_CAPS_MAX)&&(CHARGING_STATE==CHARGING_ALLOWED||CHARGING_STATE==CHARGING_AND_DISCHARING_ALLOWED)){ 
098D:  GOTO   1C4
098E:  MOVF   4F,W
098F:  SUBLW  01
0990:  BTFSC  03.0
0991:  GOTO   1A5
0992:  XORLW  FF
0993:  BTFSS  03.2
0994:  GOTO   199
0995:  MOVF   4E,W
0996:  SUBLW  D5
0997:  BTFSC  03.0
0998:  GOTO   1A5
0999:  MOVF   52,W
099A:  SUBLW  02
099B:  BTFSC  03.2
099C:  GOTO   1A1
099D:  MOVF   52,W
099E:  SUBLW  04
099F:  BTFSS  03.2
09A0:  GOTO   1A5
....................          //Stop Charging they are full 
....................           
....................          #ifdef DEBUG 
....................             printf("State: Caps Full \n");   
....................          //#else 
....................            // delay_ms(250); 
....................          #endif 
....................           
....................         ICE_ON=FALSE; 
09A1:  BCF    43.1
....................         CHARGING_STATE=DISCHARGING_ALLOWED; 
09A2:  MOVLW  03
09A3:  MOVWF  52
....................       } 
....................       else if ((Acaps < A_CAPS_MIN)&& CHARGING_STATE!=CHARGING_ALLOWED){ 
09A4:  GOTO   1C4
09A5:  MOVF   4F,W
09A6:  SUBLW  01
09A7:  BTFSS  03.0
09A8:  GOTO   1B7
09A9:  BTFSS  03.2
09AA:  GOTO   1AF
09AB:  MOVF   4E,W
09AC:  SUBLW  8F
09AD:  BTFSS  03.0
09AE:  GOTO   1B7
09AF:  MOVF   52,W
09B0:  SUBLW  02
09B1:  BTFSC  03.2
09B2:  GOTO   1B7
....................          //Stop running electric, the caps are almost empty 
....................          
....................         #ifdef DEBUG 
....................             printf("State: Caps Empty \n");   
....................          //#else 
....................            // delay_ms(250); 
....................          #endif 
....................  
....................         ICE_ON=TRUE; 
09B3:  BSF    43.1
....................         CHARGING_STATE=CHARGING_ALLOWED; 
09B4:  MOVLW  02
09B5:  MOVWF  52
....................       } 
....................      else if (A_CAPS_MID_LOW < Acaps < A_CAPS_MID_HIGH){ 
09B6:  GOTO   1C4
09B7:  MOVF   4F,W
09B8:  SUBLW  00
09B9:  BTFSC  03.0
09BA:  GOTO   1C1
09BB:  XORLW  FF
09BC:  BTFSS  03.2
09BD:  GOTO   1C2
09BE:  MOVF   4E,W
09BF:  SUBLW  F4
09C0:  BTFSC  03.0
09C1:  MOVLW  00
....................         #ifdef DEBUG 
....................             printf("State: Normal \n");   
....................          //#else 
....................            // delay_ms(250); 
....................          #endif 
....................          CHARGING_STATE=CHARGING_AND_DISCHARING_ALLOWED; 
09C2:  MOVLW  04
09C3:  MOVWF  52
....................      } 
....................       
....................       
.................... //PID CONTROLLER 
....................       //Servo to mirror Athrottle ->  
....................       //current_servo_position=right_position-(Athrottle-Athrottle_Min)*Athrottle_servo_factor;//(Athrottle/Athrottle_Full)*servo_difference;//(vSpeed/65536.0)*(2500); 
....................       ////printf("Analog Cap %d Analog Throttle %Lu\n",(int) Acaps,Athrottle); 
....................       //current_servo_position =right_position-vSpeed+200; 
....................       ////printf("Speed %lu \n",speeder); 
....................       //SET OUTPUTS  
....................       //The writing of the ICEThrottle happens in interupts and all that is 
....................       //required is updating ICEthrottle 
....................        
....................       returnedValue = pid_Controller((Athrottle-AThrottle_Min),vSpeed,& pidData); 
09C4:  MOVLW  3C
09C5:  SUBWF  4C,W
09C6:  MOVWF  53
09C7:  MOVF   4D,W
09C8:  MOVWF  54
09C9:  MOVLW  01
09CA:  BTFSS  03.0
09CB:  MOVLW  02
09CC:  SUBWF  54,F
09CD:  MOVF   54,W
09CE:  MOVWF  56
09CF:  MOVF   53,W
09D0:  MOVWF  55
09D1:  MOVF   47,W
09D2:  MOVWF  58
09D3:  MOVF   46,W
09D4:  MOVWF  57
09D5:  MOVLW  2F
09D6:  MOVWF  59
09D7:  BCF    0A.3
09D8:  GOTO   257
09D9:  BSF    0A.3
09DA:  MOVF   22,W
09DB:  MOVWF  51
09DC:  MOVF   21,W
09DD:  MOVWF  50
....................       ELECthrottle = ELECthrottle+returnedValue; 
09DE:  MOVF   50,W
09DF:  ADDWF  48,F
09E0:  MOVF   51,W
09E1:  BTFSC  03.0
09E2:  INCFSZ 51,W
09E3:  ADDWF  49,F
....................       //printf("Throttle %ld and electhrottle %ld \n",Athrottle,ELECthrottle); 
....................        
....................       
....................       if (ELECthrottle>2500){ 
09E4:  BTFSC  49.7
09E5:  GOTO   1F6
09E6:  MOVF   49,W
09E7:  SUBLW  08
09E8:  BTFSC  03.0
09E9:  GOTO   1F6
09EA:  XORLW  FF
09EB:  BTFSS  03.2
09EC:  GOTO   1F1
09ED:  MOVF   48,W
09EE:  SUBLW  C4
09EF:  BTFSC  03.0
09F0:  GOTO   1F6
....................          ELECthrottle=2500; 
09F1:  MOVLW  09
09F2:  MOVWF  49
09F3:  MOVLW  C4
09F4:  MOVWF  48
....................       } 
....................       else if (ELECthrottle<-1000){ 
09F5:  GOTO   206
09F6:  BTFSS  49.7
09F7:  GOTO   206
09F8:  MOVF   49,W
09F9:  SUBLW  FC
09FA:  BTFSS  03.0
09FB:  GOTO   206
09FC:  BTFSS  03.2
09FD:  GOTO   202
09FE:  MOVF   48,W
09FF:  SUBLW  17
0A00:  BTFSS  03.0
0A01:  GOTO   206
....................          ELECthrottle = -1000; 
0A02:  MOVLW  FC
0A03:  MOVWF  49
0A04:  MOVLW  18
0A05:  MOVWF  48
....................       } 
....................        
....................        
....................       //SET OUTPUTS 
....................       if (CHARGING_STATE==EVERYTHING_OFF||CHARGING_STATE==USER_INPUT_OFF){ 
0A06:  MOVF   52,F
0A07:  BTFSC  03.2
0A08:  GOTO   20D
0A09:  MOVF   52,W
0A0A:  SUBLW  06
0A0B:  BTFSS  03.2
0A0C:  GOTO   21A
....................          ICEthrottle = 0; 
0A0D:  CLRF   4B
0A0E:  CLRF   4A
....................          ICE_ON = FALSE; 
0A0F:  BCF    43.1
....................          current_servo_position =right_position; 
0A10:  MOVLW  11
0A11:  MOVWF  42
0A12:  MOVLW  F8
0A13:  MOVWF  41
....................          write_dac(0); 
0A14:  CLRF   58
0A15:  CLRF   57
0A16:  BCF    0A.3
0A17:  CALL   0E0
0A18:  BSF    0A.3
....................       } 
....................       else if (CHARGING_STATE==SPEED_TO_LOW_ICE_DIRECT || CHARGING_STATE==INSUFFICIENT_BRAKING_RUNAWAY){ 
0A19:  GOTO   2D1
0A1A:  DECFSZ 52,W
0A1B:  GOTO   21D
0A1C:  GOTO   221
0A1D:  MOVF   52,W
0A1E:  SUBLW  05
0A1F:  BTFSS  03.2
0A20:  GOTO   251
....................          if (ELECthrottle>0){ 
0A21:  BTFSC  49.7
0A22:  GOTO   246
0A23:  MOVF   49,F
0A24:  BTFSS  03.2
0A25:  GOTO   22A
0A26:  MOVF   48,W
0A27:  SUBLW  00
0A28:  BTFSC  03.0
0A29:  GOTO   246
....................             current_servo_position =right_position- (3*ELECthrottle); 
0A2A:  CLRF   73
0A2B:  MOVLW  03
0A2C:  MOVWF  72
0A2D:  MOVF   49,W
0A2E:  MOVWF  75
0A2F:  MOVF   48,W
0A30:  MOVWF  74
0A31:  BCF    0A.3
0A32:  CALL   242
0A33:  BSF    0A.3
0A34:  MOVF   22,W
0A35:  MOVWF  23
0A36:  MOVF   21,W
0A37:  SUBLW  F8
0A38:  MOVWF  20
0A39:  MOVF   22,W
0A3A:  BTFSS  03.0
0A3B:  INCFSZ 22,W
0A3C:  GOTO   23F
0A3D:  MOVLW  11
0A3E:  GOTO   240
0A3F:  SUBLW  11
0A40:  MOVWF  23
0A41:  MOVF   20,W
0A42:  MOVWF  41
0A43:  MOVF   23,W
0A44:  MOVWF  42
....................          } 
....................          else{ 
0A45:  GOTO   24A
....................             current_servo_position =right_position; 
0A46:  MOVLW  11
0A47:  MOVWF  42
0A48:  MOVLW  F8
0A49:  MOVWF  41
....................          } 
....................          ICE_ON = TRUE; 
0A4A:  BSF    43.1
....................          write_dac(0); 
0A4B:  CLRF   58
0A4C:  CLRF   57
0A4D:  BCF    0A.3
0A4E:  CALL   0E0
0A4F:  BSF    0A.3
....................       } 
....................       else{ 
0A50:  GOTO   2D1
....................       if (ELECthrottle<0){ 
0A51:  BTFSS  49.7
0A52:  GOTO   28E
....................         if (CHARGING_STATE==CHARGING_ALLOWED || CHARGING_STATE ==CHARGING_AND_DISCHARING_ALLOWED){ 
0A53:  MOVF   52,W
0A54:  SUBLW  02
0A55:  BTFSC  03.2
0A56:  GOTO   25B
0A57:  MOVF   52,W
0A58:  SUBLW  04
0A59:  BTFSS  03.2
0A5A:  GOTO   288
....................              if (CURRENTLY_CHARGING==1){ 
0A5B:  BTFSS  43.2
0A5C:  GOTO   25D
....................                 //trickBreaking(); 
....................              } 
....................              //ELECthrottle = 300; 
....................              CURRENTLY_CHARGING=0; 
0A5D:  BCF    43.2
....................              output_high(Electric_Controller_Switch); 
0A5E:  BSF    03.5
0A5F:  BCF    06.0
0A60:  BCF    03.5
0A61:  BSF    06.0
....................              //printf("BREAKING \n"); 
....................              write_dac((abs(ELECthrottle)+ELEC_CONTROLLER_OFFSET)); 
0A62:  MOVF   49,W
0A63:  MOVWF  23
0A64:  MOVF   48,W
0A65:  BTFSS  49.7
0A66:  GOTO   270
0A67:  MOVF   48,W
0A68:  SUBLW  00
0A69:  MOVWF  20
0A6A:  CLRF   23
0A6B:  MOVF   49,W
0A6C:  BTFSS  03.0
0A6D:  INCFSZ 49,W
0A6E:  SUBWF  23,F
0A6F:  MOVF   20,W
0A70:  MOVWF  53
0A71:  MOVF   23,W
0A72:  MOVWF  54
0A73:  MOVLW  84
0A74:  ADDWF  53,W
0A75:  MOVWF  55
0A76:  MOVF   54,W
0A77:  MOVWF  56
0A78:  MOVLW  03
0A79:  BTFSC  03.0
0A7A:  MOVLW  04
0A7B:  ADDWF  56,F
0A7C:  MOVF   56,W
0A7D:  MOVWF  58
0A7E:  MOVF   55,W
0A7F:  MOVWF  57
0A80:  BCF    0A.3
0A81:  CALL   0E0
0A82:  BSF    0A.3
....................              output_high(brake_pin); 
0A83:  BSF    03.5
0A84:  BCF    06.4
0A85:  BCF    03.5
0A86:  BSF    06.4
....................               
....................         } 
....................         else{ 
0A87:  GOTO   28D
....................            //Decrease ICE throttle 
....................            write_dac(0); 
0A88:  CLRF   58
0A89:  CLRF   57
0A8A:  BCF    0A.3
0A8B:  CALL   0E0
0A8C:  BSF    0A.3
....................        
....................         } 
....................       } 
....................       else { 
0A8D:  GOTO   2C6
....................         if (CHARGING_STATE==DISCHARGING_ALLOWED || CHARGING_STATE ==CHARGING_AND_DISCHARING_ALLOWED){ 
0A8E:  MOVF   52,W
0A8F:  SUBLW  03
0A90:  BTFSC  03.2
0A91:  GOTO   296
0A92:  MOVF   52,W
0A93:  SUBLW  04
0A94:  BTFSS  03.2
0A95:  GOTO   2C1
....................              CURRENTLY_CHARGING=1; 
0A96:  BSF    43.2
....................               
....................              output_low(Electric_Controller_Switch); 
0A97:  BSF    03.5
0A98:  BCF    06.0
0A99:  BCF    03.5
0A9A:  BCF    06.0
....................              //printf("ACCELERATING \n"); 
....................              write_dac((abs(ELECthrottle)+ELEC_CONTROLLER_OFFSET)); 
0A9B:  MOVF   49,W
0A9C:  MOVWF  23
0A9D:  MOVF   48,W
0A9E:  BTFSS  49.7
0A9F:  GOTO   2A9
0AA0:  MOVF   48,W
0AA1:  SUBLW  00
0AA2:  MOVWF  20
0AA3:  CLRF   23
0AA4:  MOVF   49,W
0AA5:  BTFSS  03.0
0AA6:  INCFSZ 49,W
0AA7:  SUBWF  23,F
0AA8:  MOVF   20,W
0AA9:  MOVWF  53
0AAA:  MOVF   23,W
0AAB:  MOVWF  54
0AAC:  MOVLW  84
0AAD:  ADDWF  53,W
0AAE:  MOVWF  55
0AAF:  MOVF   54,W
0AB0:  MOVWF  56
0AB1:  MOVLW  03
0AB2:  BTFSC  03.0
0AB3:  MOVLW  04
0AB4:  ADDWF  56,F
0AB5:  MOVF   56,W
0AB6:  MOVWF  58
0AB7:  MOVF   55,W
0AB8:  MOVWF  57
0AB9:  BCF    0A.3
0ABA:  CALL   0E0
0ABB:  BSF    0A.3
....................              output_low(brake_pin); 
0ABC:  BSF    03.5
0ABD:  BCF    06.4
0ABE:  BCF    03.5
0ABF:  BCF    06.4
....................         } 
....................         else{ 
0AC0:  GOTO   2C6
....................            //Increase ICE throttle 
....................            write_dac(0); 
0AC1:  CLRF   58
0AC2:  CLRF   57
0AC3:  BCF    0A.3
0AC4:  CALL   0E0
0AC5:  BSF    0A.3
....................        
....................         } 
....................           
....................       } 
....................       if (ICE_ON){ 
0AC6:  BTFSS  43.1
0AC7:  GOTO   2CD
....................          //printf("ICE NORMAL \n"); 
....................          current_servo_position = left_position +500; 
0AC8:  MOVLW  0B
0AC9:  MOVWF  42
0ACA:  MOVLW  B8
0ACB:  MOVWF  41
....................          //current_servo_position = right_position - (Athrottle-Athrottle_Min)*4; 
....................        
....................       } 
....................       else{ 
0ACC:  GOTO   2D1
....................          current_servo_position =right_position; 
0ACD:  MOVLW  11
0ACE:  MOVWF  42
0ACF:  MOVLW  F8
0AD0:  MOVWF  41
....................          //printf("ICE OFF \n"); 
....................       } 
....................       } 
....................             
....................    } 
....................    } 
0AD1:  GOTO   09F
....................  
.................... } 
....................  
.................... #endif 
....................  
.................... boolean checkRunnaway(struct PID_DATA *pid) 
.................... { 
0AD2:  SLEEP
.................... //return (pid->sumError > INSUFFICIENT_BRAKING_RUNNAWAY_ERROR); 
.................... return FALSE; 
*
023E:  MOVLW  00
023F:  MOVWF  21
.................... } 
0240:  BSF    0A.3
0241:  GOTO   186 (RETURN)
....................  
.................... /*! \brief Initialisation of PID controller parameters. 
....................  * 
....................  *  Initialise the variables used by the PID algorithm. 
....................  * 
....................  *  \param p_factor  Proportional term. 
....................  *  \param i_factor  Integral term. 
....................  *  \param d_factor  Derivate term. 
....................  *  \param pid  Struct with PID status. 
....................  */ 
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid) 
.................... // Set up PID controller parameters 
.................... { 
....................   // Start values for PID controller 
....................   pid->sumError = 0; 
*
013C:  MOVLW  02
013D:  ADDWF  59,W
013E:  MOVWF  04
013F:  INCF   04,F
0140:  INCF   04,F
0141:  INCF   04,F
0142:  CLRF   00
0143:  DECF   04,F
0144:  CLRF   00
0145:  DECF   04,F
0146:  CLRF   00
0147:  DECF   04,F
0148:  CLRF   00
....................   pid->lastProcessValue = 0; 
0149:  MOVF   59,W
014A:  MOVWF  04
014B:  INCF   04,F
014C:  CLRF   00
014D:  DECF   04,F
014E:  CLRF   00
....................   // Tuning constants for PID loop 
....................   pid->P_Factor = p_factor; 
014F:  MOVLW  06
0150:  ADDWF  59,W
0151:  MOVWF  04
0152:  INCF   04,F
0153:  MOVF   54,W
0154:  MOVWF  00
0155:  DECF   04,F
0156:  MOVF   53,W
0157:  MOVWF  00
....................   pid->I_Factor = i_factor; 
0158:  MOVLW  08
0159:  ADDWF  59,W
015A:  MOVWF  04
015B:  INCF   04,F
015C:  MOVF   56,W
015D:  MOVWF  00
015E:  DECF   04,F
015F:  MOVF   55,W
0160:  MOVWF  00
....................   pid->D_Factor = d_factor; 
0161:  MOVLW  0A
0162:  ADDWF  59,W
0163:  MOVWF  04
0164:  INCF   04,F
0165:  MOVF   58,W
0166:  MOVWF  00
0167:  DECF   04,F
0168:  MOVF   57,W
0169:  MOVWF  00
....................   // Limits to avoid overflow 
....................   pid->maxError = MAX_INT / (pid->P_Factor + 1); 
016A:  MOVLW  0C
016B:  ADDWF  59,W
016C:  MOVWF  5A
016D:  MOVLW  06
016E:  ADDWF  59,W
016F:  MOVWF  04
0170:  INCF   04,F
0171:  MOVF   00,W
0172:  MOVWF  5C
0173:  DECF   04,F
0174:  MOVF   00,W
0175:  MOVWF  5B
0176:  MOVLW  01
0177:  ADDWF  5B,W
0178:  MOVWF  21
0179:  MOVF   5C,W
017A:  MOVWF  23
017B:  BTFSC  03.0
017C:  INCF   23,F
017D:  MOVF   21,W
017E:  MOVWF  5D
017F:  MOVF   23,W
0180:  MOVWF  5E
0181:  MOVLW  7F
0182:  MOVWF  60
0183:  MOVLW  FF
0184:  MOVWF  5F
0185:  MOVF   5E,W
0186:  MOVWF  62
0187:  MOVF   5D,W
0188:  MOVWF  61
*
01AD:  MOVF   5A,W
01AE:  MOVWF  04
01AF:  INCF   04,F
01B0:  MOVF   22,W
01B1:  MOVWF  00
01B2:  DECF   04,F
01B3:  MOVF   21,W
01B4:  MOVWF  00
....................   ////printf("Max %ld factor %ld and pid %ld",MAX_INT,pid->I_Factor,pid->maxError); 
....................   pid->maxSumError = MAX_I_TERM / (pid->I_Factor + 1); 
01B5:  MOVLW  0E
01B6:  ADDWF  59,W
01B7:  MOVWF  5A
01B8:  MOVLW  08
01B9:  ADDWF  59,W
01BA:  MOVWF  04
01BB:  INCF   04,F
01BC:  MOVF   00,W
01BD:  MOVWF  5C
01BE:  DECF   04,F
01BF:  MOVF   00,W
01C0:  MOVWF  5B
01C1:  MOVLW  01
01C2:  ADDWF  5B,W
01C3:  MOVWF  21
01C4:  MOVF   5C,W
01C5:  MOVWF  23
01C6:  BTFSC  03.0
01C7:  INCF   23,F
01C8:  MOVF   21,W
01C9:  MOVWF  5D
01CA:  MOVF   23,W
01CB:  MOVWF  5E
01CC:  MOVF   04,W
01CD:  MOVWF  5F
01CE:  MOVLW  3F
01CF:  MOVWF  63
01D0:  MOVLW  FF
01D1:  MOVWF  62
01D2:  MOVWF  61
01D3:  MOVWF  60
01D4:  CLRF   67
01D5:  CLRF   66
01D6:  MOVF   5E,W
01D7:  MOVWF  65
01D8:  MOVF   5D,W
01D9:  MOVWF  64
*
021A:  MOVF   5F,W
021B:  MOVWF  04
021C:  MOVF   5A,W
021D:  MOVWF  04
021E:  MOVF   20,W
021F:  MOVWF  00
0220:  INCF   04,F
0221:  MOVF   21,W
0222:  MOVWF  00
0223:  INCF   04,F
0224:  MOVF   22,W
0225:  MOVWF  00
0226:  INCF   04,F
0227:  MOVF   23,W
0228:  MOVWF  00
.................... } 
0229:  BSF    0A.3
022A:  GOTO   084 (RETURN)
....................  
....................  
.................... /*! \brief PID control algorithm. 
....................  * 
....................  *  Calculates output from setpoint, process value and PID status. 
....................  * 
....................  *  \param setPoint  Desired value. 
....................  *  \param processValue  Measured value. 
....................  *  \param pid_st  PID status struct. 
....................  */ 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st) 
.................... { 
....................   signed int16 error, p_term, d_term; 
....................   signed int32 i_term, ret, temp; 
....................     processValue=processValue/4; 
*
0257:  RRF    58,F
0258:  RRF    57,F
0259:  RRF    58,F
025A:  RRF    57,F
025B:  MOVLW  3F
025C:  ANDWF  58,F
....................   ////printf("input %ld speed %ld ",setPoint,processValue); 
....................   error = setPoint - processValue; 
025D:  MOVF   57,W
025E:  SUBWF  55,W
025F:  MOVWF  20
0260:  MOVF   56,W
0261:  MOVWF  23
0262:  MOVF   58,W
0263:  BTFSS  03.0
0264:  INCFSZ 58,W
0265:  SUBWF  23,F
0266:  MOVF   20,W
0267:  MOVWF  5A
0268:  MOVF   23,W
0269:  MOVWF  5B
....................    
....................   // Calculate Pterm and limit error overflow 
....................    
....................   if (error > (signed int16) pid_st->maxError){ 
026A:  MOVLW  0C
026B:  ADDWF  59,W
026C:  MOVWF  04
026D:  INCF   04,F
026E:  MOVF   00,W
026F:  MOVWF  23
0270:  DECF   04,F
0271:  MOVF   00,W
0272:  MOVWF  21
0273:  BTFSS  23.7
0274:  GOTO   278
0275:  BTFSS  5B.7
0276:  GOTO   284
0277:  GOTO   27A
0278:  BTFSC  5B.7
0279:  GOTO   289
027A:  MOVF   23,W
027B:  SUBWF  5B,W
027C:  BTFSS  03.0
027D:  GOTO   289
027E:  BTFSS  03.2
027F:  GOTO   284
0280:  MOVF   5A,W
0281:  SUBWF  21,W
0282:  BTFSC  03.0
0283:  GOTO   289
....................     p_term = MAX_INT; 
0284:  MOVLW  7F
0285:  MOVWF  5D
0286:  MOVLW  FF
0287:  MOVWF  5C
....................     ////printf("p greater error %ld a %ld p %ld",error,pid_st->maxError,p_term); 
....................  
....................   } 
....................   else if (error < (signed int16) -pid_st->maxError){ 
0288:  GOTO   3BA
0289:  MOVLW  0C
028A:  ADDWF  59,W
028B:  MOVWF  04
028C:  INCF   04,F
028D:  MOVF   00,W
028E:  MOVWF  23
028F:  DECF   04,F
0290:  MOVF   00,W
0291:  SUBLW  00
0292:  MOVWF  20
0293:  MOVF   23,W
0294:  BTFSS  03.0
0295:  INCFSZ 23,W
0296:  GOTO   299
0297:  MOVLW  00
0298:  GOTO   29A
0299:  SUBLW  00
029A:  MOVWF  23
029B:  MOVF   20,W
029C:  MOVWF  21
029D:  BTFSS  5B.7
029E:  GOTO   2A2
029F:  BTFSS  23.7
02A0:  GOTO   2AE
02A1:  GOTO   2A4
02A2:  BTFSC  23.7
02A3:  GOTO   2B3
02A4:  MOVF   5B,W
02A5:  SUBWF  23,W
02A6:  BTFSS  03.0
02A7:  GOTO   2B3
02A8:  BTFSS  03.2
02A9:  GOTO   2AE
02AA:  MOVF   21,W
02AB:  SUBWF  5A,W
02AC:  BTFSC  03.0
02AD:  GOTO   2B3
....................     p_term = -MAX_INT; 
02AE:  MOVLW  80
02AF:  MOVWF  5D
02B0:  MOVLW  01
02B1:  MOVWF  5C
....................     ////printf("p less error %ld a %ld p %ld",error,-pid_st->maxError,p_term); 
....................  
....................   } 
....................   else{ 
02B2:  GOTO   3BA
....................     p_term = (signed int16) (pid_st->P_Factor * (float) error); 
02B3:  MOVLW  06
02B4:  ADDWF  59,W
02B5:  MOVWF  04
02B6:  INCF   04,F
02B7:  MOVF   00,W
02B8:  MOVWF  6D
02B9:  DECF   04,F
02BA:  MOVF   00,W
02BB:  MOVWF  6C
02BC:  MOVF   5B,W
02BD:  MOVWF  6F
02BE:  MOVF   5A,W
02BF:  MOVWF  6E
*
02E4:  MOVF   20,W
02E5:  MOVWF  6E
02E6:  MOVF   21,W
02E7:  MOVWF  6F
02E8:  MOVF   22,W
02E9:  MOVWF  70
02EA:  MOVF   23,W
02EB:  MOVWF  71
02EC:  MOVF   6D,W
02ED:  MOVWF  73
02EE:  MOVF   6C,W
02EF:  MOVWF  72
*
030C:  MOVF   23,W
030D:  MOVWF  75
030E:  MOVF   22,W
030F:  MOVWF  74
0310:  MOVF   21,W
0311:  MOVWF  73
0312:  MOVF   20,W
0313:  MOVWF  72
0314:  MOVF   71,W
0315:  MOVWF  79
0316:  MOVF   70,W
0317:  MOVWF  78
0318:  MOVF   6F,W
0319:  MOVWF  77
031A:  MOVF   6E,W
031B:  MOVWF  76
*
0390:  MOVF   23,W
0391:  MOVWF  75
0392:  MOVF   22,W
0393:  MOVWF  74
0394:  MOVF   21,W
0395:  MOVWF  73
0396:  MOVF   20,W
0397:  MOVWF  72
*
03B6:  MOVF   22,W
03B7:  MOVWF  5D
03B8:  MOVF   21,W
03B9:  MOVWF  5C
....................     ////printf("error %ld a %ld p %ld",error,pid_st->maxError,p_term); 
....................   } 
....................    
....................   // Calculate Iterm and limit integral runaway 
....................   temp = pid_st->sumError + error; 
03BA:  MOVLW  02
03BB:  ADDWF  59,W
03BC:  MOVWF  04
03BD:  MOVF   00,W
03BE:  MOVWF  6C
03BF:  INCF   04,F
03C0:  MOVF   00,W
03C1:  MOVWF  6D
03C2:  INCF   04,F
03C3:  MOVF   00,W
03C4:  MOVWF  6E
03C5:  INCF   04,F
03C6:  MOVF   00,W
03C7:  MOVWF  6F
03C8:  MOVF   5A,W
03C9:  MOVWF  20
03CA:  MOVF   5B,W
03CB:  MOVWF  21
03CC:  CLRF   22
03CD:  CLRF   23
03CE:  BTFSS  5B.7
03CF:  GOTO   3D2
03D0:  DECF   22,F
03D1:  DECF   23,F
03D2:  MOVF   20,W
03D3:  ADDWF  6C,W
03D4:  MOVWF  68
03D5:  MOVF   6D,W
03D6:  MOVWF  69
03D7:  MOVF   21,W
03D8:  BTFSC  03.0
03D9:  INCFSZ 21,W
03DA:  ADDWF  69,F
03DB:  MOVF   6E,W
03DC:  MOVWF  6A
03DD:  MOVF   22,W
03DE:  BTFSC  03.0
03DF:  INCFSZ 22,W
03E0:  ADDWF  6A,F
03E1:  MOVF   6F,W
03E2:  MOVWF  6B
03E3:  MOVF   23,W
03E4:  BTFSC  03.0
03E5:  INCFSZ 23,W
03E6:  ADDWF  6B,F
....................   if(temp > (signed int32)pid_st->maxSumError){ 
03E7:  MOVLW  0E
03E8:  ADDWF  59,W
03E9:  MOVWF  04
03EA:  MOVF   00,W
03EB:  MOVWF  20
03EC:  INCF   04,F
03ED:  MOVF   00,W
03EE:  MOVWF  21
03EF:  INCF   04,F
03F0:  MOVF   00,W
03F1:  MOVWF  22
03F2:  INCF   04,F
03F3:  MOVF   00,W
03F4:  MOVWF  23
03F5:  BTFSS  23.7
03F6:  GOTO   3FA
03F7:  BTFSS  6B.7
03F8:  GOTO   412
03F9:  GOTO   3FC
03FA:  BTFSC  6B.7
03FB:  GOTO   437
03FC:  MOVF   23,W
03FD:  SUBWF  6B,W
03FE:  BTFSS  03.0
03FF:  GOTO   437
0400:  BTFSS  03.2
0401:  GOTO   412
0402:  MOVF   22,W
0403:  SUBWF  6A,W
0404:  BTFSS  03.0
0405:  GOTO   437
0406:  BTFSS  03.2
0407:  GOTO   412
0408:  MOVF   21,W
0409:  SUBWF  69,W
040A:  BTFSS  03.0
040B:  GOTO   437
040C:  BTFSS  03.2
040D:  GOTO   412
040E:  MOVF   68,W
040F:  SUBWF  20,W
0410:  BTFSC  03.0
0411:  GOTO   437
....................     i_term = MAX_I_TERM; 
0412:  MOVLW  3F
0413:  MOVWF  63
0414:  MOVLW  FF
0415:  MOVWF  62
0416:  MOVWF  61
0417:  MOVWF  60
....................     pid_st->sumError = pid_st->maxSumError; 
0418:  MOVLW  02
0419:  ADDWF  59,W
041A:  MOVWF  6C
041B:  MOVLW  0E
041C:  ADDWF  59,W
041D:  MOVWF  04
041E:  MOVF   00,W
041F:  MOVWF  20
0420:  INCF   04,F
0421:  MOVF   00,W
0422:  MOVWF  21
0423:  INCF   04,F
0424:  MOVF   00,W
0425:  MOVWF  22
0426:  INCF   04,F
0427:  MOVF   00,W
0428:  MOVWF  23
0429:  MOVF   6C,W
042A:  MOVWF  04
042B:  MOVF   20,W
042C:  MOVWF  00
042D:  INCF   04,F
042E:  MOVF   21,W
042F:  MOVWF  00
0430:  INCF   04,F
0431:  MOVF   22,W
0432:  MOVWF  00
0433:  INCF   04,F
0434:  MOVF   23,W
0435:  MOVWF  00
....................     ////printf("\n greater temp %ld a %ld sum %ld",temp,pid_st->maxSumError,pid_st->sumError); 
....................  
....................  } 
....................   else if(temp < (signed int32)-pid_st->maxSumError){ 
0436:  GOTO   54B
0437:  MOVLW  0E
0438:  ADDWF  59,W
0439:  MOVWF  04
043A:  MOVF   00,W
043B:  MOVWF  20
043C:  INCF   04,F
043D:  MOVF   00,W
043E:  MOVWF  21
043F:  INCF   04,F
0440:  MOVF   00,W
0441:  MOVWF  22
0442:  INCF   04,F
0443:  MOVF   00,W
0444:  MOVWF  23
0445:  MOVLW  FD
0446:  ADDWF  04,F
0447:  MOVF   20,W
0448:  SUBLW  00
0449:  MOVWF  20
044A:  MOVF   21,W
044B:  BTFSS  03.0
044C:  INCFSZ 21,W
044D:  GOTO   450
044E:  MOVLW  00
044F:  GOTO   451
0450:  SUBLW  00
0451:  MOVWF  21
0452:  MOVF   22,W
0453:  BTFSS  03.0
0454:  INCFSZ 22,W
0455:  GOTO   458
0456:  MOVLW  00
0457:  GOTO   459
0458:  SUBLW  00
0459:  MOVWF  22
045A:  MOVF   23,W
045B:  BTFSS  03.0
045C:  INCFSZ 23,W
045D:  GOTO   460
045E:  MOVLW  00
045F:  GOTO   461
0460:  SUBLW  00
0461:  MOVWF  23
0462:  BTFSS  6B.7
0463:  GOTO   467
0464:  BTFSS  23.7
0465:  GOTO   47F
0466:  GOTO   469
0467:  BTFSC  23.7
0468:  GOTO   4C2
0469:  MOVF   6B,W
046A:  SUBWF  23,W
046B:  BTFSS  03.0
046C:  GOTO   4C2
046D:  BTFSS  03.2
046E:  GOTO   47F
046F:  MOVF   6A,W
0470:  SUBWF  22,W
0471:  BTFSS  03.0
0472:  GOTO   4C2
0473:  BTFSS  03.2
0474:  GOTO   47F
0475:  MOVF   69,W
0476:  SUBWF  21,W
0477:  BTFSS  03.0
0478:  GOTO   4C2
0479:  BTFSS  03.2
047A:  GOTO   47F
047B:  MOVF   20,W
047C:  SUBWF  68,W
047D:  BTFSC  03.0
047E:  GOTO   4C2
....................     i_term = -MAX_I_TERM; 
047F:  MOVLW  C0
0480:  MOVWF  63
0481:  CLRF   62
0482:  CLRF   61
0483:  MOVLW  01
0484:  MOVWF  60
....................     pid_st->sumError = -pid_st->maxSumError; 
0485:  MOVLW  02
0486:  ADDWF  59,W
0487:  MOVWF  6C
0488:  MOVLW  0E
0489:  ADDWF  59,W
048A:  MOVWF  04
048B:  MOVF   00,W
048C:  MOVWF  20
048D:  INCF   04,F
048E:  MOVF   00,W
048F:  MOVWF  21
0490:  INCF   04,F
0491:  MOVF   00,W
0492:  MOVWF  22
0493:  INCF   04,F
0494:  MOVF   00,W
0495:  MOVWF  23
0496:  MOVLW  FD
0497:  ADDWF  04,F
0498:  MOVF   20,W
0499:  SUBLW  00
049A:  MOVWF  20
049B:  MOVF   21,W
049C:  BTFSS  03.0
049D:  INCFSZ 21,W
049E:  GOTO   4A1
049F:  MOVLW  00
04A0:  GOTO   4A2
04A1:  SUBLW  00
04A2:  MOVWF  21
04A3:  MOVF   22,W
04A4:  BTFSS  03.0
04A5:  INCFSZ 22,W
04A6:  GOTO   4A9
04A7:  MOVLW  00
04A8:  GOTO   4AA
04A9:  SUBLW  00
04AA:  MOVWF  22
04AB:  MOVF   23,W
04AC:  BTFSS  03.0
04AD:  INCFSZ 23,W
04AE:  GOTO   4B1
04AF:  MOVLW  00
04B0:  GOTO   4B2
04B1:  SUBLW  00
04B2:  MOVWF  23
04B3:  MOVWF  70
04B4:  MOVF   6C,W
04B5:  MOVWF  04
04B6:  MOVF   20,W
04B7:  MOVWF  00
04B8:  INCF   04,F
04B9:  MOVF   21,W
04BA:  MOVWF  00
04BB:  INCF   04,F
04BC:  MOVF   22,W
04BD:  MOVWF  00
04BE:  INCF   04,F
04BF:  MOVF   70,W
04C0:  MOVWF  00
....................     ////printf("\n less temp %ld a %ld sum %ld",temp,pid_st->maxSumError,pid_st->sumError); 
....................  
....................   } 
....................   else{ 
04C1:  GOTO   54B
....................     pid_st->sumError = temp; 
04C2:  MOVLW  02
04C3:  ADDWF  59,W
04C4:  MOVWF  04
04C5:  MOVF   68,W
04C6:  MOVWF  00
04C7:  INCF   04,F
04C8:  MOVF   69,W
04C9:  MOVWF  00
04CA:  INCF   04,F
04CB:  MOVF   6A,W
04CC:  MOVWF  00
04CD:  INCF   04,F
04CE:  MOVF   6B,W
04CF:  MOVWF  00
....................     i_term = pid_st->I_Factor * pid_st->sumError; 
04D0:  MOVLW  08
04D1:  ADDWF  59,W
04D2:  MOVWF  04
04D3:  INCF   04,F
04D4:  MOVF   00,W
04D5:  MOVWF  6D
04D6:  DECF   04,F
04D7:  MOVF   00,W
04D8:  MOVWF  6C
04D9:  MOVLW  02
04DA:  ADDWF  59,W
04DB:  MOVWF  04
04DC:  MOVF   00,W
04DD:  MOVWF  20
04DE:  INCF   04,F
04DF:  MOVF   00,W
04E0:  MOVWF  21
04E1:  INCF   04,F
04E2:  MOVF   00,W
04E3:  MOVWF  22
04E4:  INCF   04,F
04E5:  MOVF   00,W
04E6:  MOVWF  23
04E7:  MOVLW  FD
04E8:  ADDWF  04,F
04E9:  MOVF   23,W
04EA:  MOVWF  71
04EB:  MOVF   22,W
04EC:  MOVWF  70
04ED:  MOVF   21,W
04EE:  MOVWF  6F
04EF:  MOVF   20,W
04F0:  MOVWF  6E
04F1:  MOVF   04,W
04F2:  MOVWF  72
04F3:  CLRF   76
04F4:  CLRF   75
04F5:  MOVF   6D,W
04F6:  MOVWF  74
04F7:  MOVF   6C,W
04F8:  MOVWF  73
04F9:  MOVF   71,W
04FA:  MOVWF  7A
04FB:  MOVF   70,W
04FC:  MOVWF  79
04FD:  MOVF   6F,W
04FE:  MOVWF  78
04FF:  MOVF   6E,W
0500:  MOVWF  77
*
0540:  BCF    03.5
0541:  MOVF   72,W
0542:  MOVWF  04
0543:  MOVF   23,W
0544:  MOVWF  63
0545:  MOVF   22,W
0546:  MOVWF  62
0547:  MOVF   21,W
0548:  MOVWF  61
0549:  MOVF   20,W
054A:  MOVWF  60
....................     ////printf("\n eror temp %ld i_term %ld sum %ld error %ld ",temp,i_term,pid_st->sumError,error); 
....................  
....................   } 
....................  
....................   // Calculate Dterm 
....................   d_term = pid_st->D_Factor * (pid_st->lastProcessValue - processValue); 
054B:  MOVLW  0A
054C:  ADDWF  59,W
054D:  MOVWF  04
054E:  INCF   04,F
054F:  MOVF   00,W
0550:  MOVWF  6D
0551:  DECF   04,F
0552:  MOVF   00,W
0553:  MOVWF  6C
0554:  MOVF   59,W
0555:  MOVWF  04
0556:  INCF   04,F
0557:  MOVF   00,W
0558:  MOVWF  6F
0559:  DECF   04,F
055A:  MOVF   00,W
055B:  MOVWF  6E
055C:  MOVF   57,W
055D:  SUBWF  6E,W
055E:  MOVWF  20
055F:  MOVF   6F,W
0560:  MOVWF  23
0561:  MOVF   58,W
0562:  BTFSS  03.0
0563:  INCFSZ 58,W
0564:  SUBWF  23,F
0565:  MOVF   20,W
0566:  MOVWF  70
0567:  MOVF   23,W
0568:  MOVWF  71
0569:  MOVF   6D,W
056A:  MOVWF  73
056B:  MOVF   6C,W
056C:  MOVWF  72
056D:  MOVF   23,W
056E:  MOVWF  75
056F:  MOVF   20,W
0570:  MOVWF  74
0571:  CALL   242
0572:  MOVF   21,W
0573:  MOVWF  5E
0574:  MOVF   22,W
0575:  MOVWF  5F
.................... ////printf("\n p_term %ld d_term %ld i_term %ld",p_term,d_term,i_term); 
....................   pid_st->lastProcessValue = processValue; 
0576:  MOVF   59,W
0577:  MOVWF  04
0578:  INCF   04,F
0579:  MOVF   58,W
057A:  MOVWF  00
057B:  DECF   04,F
057C:  MOVF   57,W
057D:  MOVWF  00
....................  
....................   //ret = (p_term + i_term + d_term) / SCALING_FACTOR; 
....................    ret = (p_term+d_term+(signed int16)i_term) / SCALING_FACTOR; 
057E:  MOVF   5E,W
057F:  ADDWF  5C,W
0580:  MOVWF  6C
0581:  MOVF   5D,W
0582:  MOVWF  6D
0583:  MOVF   5F,W
0584:  BTFSC  03.0
0585:  INCFSZ 5F,W
0586:  ADDWF  6D,F
0587:  MOVF   60,W
0588:  ADDWF  6C,W
0589:  MOVWF  6E
058A:  MOVF   6D,W
058B:  MOVWF  6F
058C:  MOVF   61,W
058D:  BTFSC  03.0
058E:  INCFSZ 61,W
058F:  ADDWF  6F,F
0590:  MOVF   6F,W
0591:  MOVWF  71
0592:  MOVF   6E,W
0593:  MOVWF  70
0594:  CLRF   73
0595:  MOVLW  80
0596:  MOVWF  72
*
05D4:  MOVF   22,W
05D5:  MOVWF  23
05D6:  MOVF   21,W
05D7:  MOVWF  20
05D8:  MOVF   22,W
05D9:  MOVWF  21
05DA:  CLRF   22
05DB:  CLRF   23
05DC:  BTFSS  21.7
05DD:  GOTO   5E0
05DE:  DECF   22,F
05DF:  DECF   23,F
05E0:  MOVF   23,W
05E1:  MOVWF  67
05E2:  MOVF   22,W
05E3:  MOVWF  66
05E4:  MOVF   21,W
05E5:  MOVWF  65
05E6:  MOVF   20,W
05E7:  MOVWF  64
....................   if(ret > MAX_INT){ 
05E8:  BTFSC  67.7
05E9:  GOTO   5FB
05EA:  MOVF   67,F
05EB:  BTFSS  03.2
05EC:  GOTO   5F4
05ED:  MOVF   66,F
05EE:  BTFSS  03.2
05EF:  GOTO   5F4
05F0:  MOVF   65,W
05F1:  SUBLW  7F
05F2:  BTFSC  03.0
05F3:  GOTO   5FB
....................     ret = MAX_INT; 
05F4:  CLRF   67
05F5:  CLRF   66
05F6:  MOVLW  7F
05F7:  MOVWF  65
05F8:  MOVLW  FF
05F9:  MOVWF  64
....................   } 
....................   else if(ret < -MAX_INT){ 
05FA:  GOTO   61A
05FB:  BTFSS  67.7
05FC:  GOTO   61A
05FD:  MOVF   67,W
05FE:  SUBLW  FF
05FF:  BTFSS  03.0
0600:  GOTO   61A
0601:  BTFSS  03.2
0602:  GOTO   613
0603:  MOVF   66,W
0604:  SUBLW  FF
0605:  BTFSS  03.0
0606:  GOTO   61A
0607:  BTFSS  03.2
0608:  GOTO   613
0609:  MOVF   65,W
060A:  SUBLW  80
060B:  BTFSS  03.0
060C:  GOTO   61A
060D:  BTFSS  03.2
060E:  GOTO   613
060F:  MOVF   64,W
0610:  SUBLW  00
0611:  BTFSS  03.0
0612:  GOTO   61A
....................     ret = -MAX_INT; 
0613:  MOVLW  FF
0614:  MOVWF  67
0615:  MOVWF  66
0616:  MOVLW  80
0617:  MOVWF  65
0618:  MOVLW  01
0619:  MOVWF  64
....................   } 
....................  
....................   return((signed int16)ret); 
061A:  MOVF   64,W
061B:  MOVWF  21
061C:  MOVF   65,W
061D:  MOVWF  22
.................... } 
061E:  BSF    0A.3
061F:  GOTO   1D9 (RETURN)
....................  
.................... /*! \brief Resets the integrator. 
....................  * 
....................  *  Calling this function will reset the integrator in the PID regulator. 
....................  */ 
.................... void pid_Reset_Integrator(pidData_t *pid_st) 
.................... { 
....................   pid_st->sumError = 0; 
.................... } 
....................  

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
