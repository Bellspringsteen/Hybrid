CCS PCM C Compiler, Version 4.084, 46530               08-Jul-04 00:21

               Filename: HondaHybrid.lst

               ROM used: 543 words (14%)
                         Largest free fragment is 1788
               RAM used: 52 (29%) at main() level
                         68 (38%) worst case
               Stack:    3 worst case (2 in main + 1 for interrupts)

*
0000:  NOP
0001:  MOVLW  00
0002:  MOVWF  0A
0003:  GOTO   1B9
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  26
0008:  MOVF   7F,W
0009:  MOVWF  25
000A:  MOVF   0A,W
000B:  MOVWF  2D
000C:  CLRF   0A
000D:  SWAPF  25,F
000E:  MOVF   04,W
000F:  MOVWF  27
0010:  MOVF   20,W
0011:  MOVWF  28
0012:  MOVF   21,W
0013:  MOVWF  29
0014:  MOVF   22,W
0015:  MOVWF  2A
0016:  MOVF   23,W
0017:  MOVWF  2B
0018:  MOVF   24,W
0019:  MOVWF  2C
001A:  BCF    03.7
001B:  BCF    03.5
001C:  MOVLW  8C
001D:  MOVWF  04
001E:  BTFSS  00.0
001F:  GOTO   022
0020:  BTFSC  0C.0
0021:  GOTO   03F
0022:  MOVLW  8D
0023:  MOVWF  04
0024:  BTFSS  00.0
0025:  GOTO   028
0026:  BTFSC  0D.0
0027:  GOTO   041
0028:  BTFSS  0B.5
0029:  GOTO   02C
002A:  BTFSC  0B.2
002B:  GOTO   043
002C:  MOVF   27,W
002D:  MOVWF  04
002E:  MOVF   28,W
002F:  MOVWF  20
0030:  MOVF   29,W
0031:  MOVWF  21
0032:  MOVF   2A,W
0033:  MOVWF  22
0034:  MOVF   2B,W
0035:  MOVWF  23
0036:  MOVF   2C,W
0037:  MOVWF  24
0038:  MOVF   2D,W
0039:  MOVWF  0A
003A:  SWAPF  26,W
003B:  MOVWF  03
003C:  SWAPF  7F,F
003D:  SWAPF  7F,W
003E:  RETFIE
003F:  BCF    0A.3
0040:  GOTO   067
0041:  BCF    0A.3
0042:  GOTO   0AF
0043:  BCF    0A.3
0044:  GOTO   059
.................... #define DEBUG 
.................... #define TESt 
.................... #include "HondaHybrid.h" 
.................... #include <16F873A.h> 
.................... //////// Standard Header file for the PIC16F873A device //////////////// 
.................... #device PIC16F873A 
.................... #list 
....................  
....................  
.................... #ifdef DEBUG 
....................    #device ICD=TRUE 
.................... #endif 
....................  
.................... #device adc=10 
.................... #use delay(clock=20000000) 
.................... #ifdef DEBUG 
....................    #use rs232 (DEBUGGER) 
*
00E4:  BSF    03.5
00E5:  BCF    06.3
00E6:  BCF    03.5
00E7:  BCF    06.3
00E8:  MOVLW  08
00E9:  MOVWF  21
00EA:  GOTO   0EB
00EB:  NOP
00EC:  BSF    21.7
00ED:  GOTO   0FC
00EE:  BCF    21.7
00EF:  RRF    60,F
00F0:  BTFSC  03.0
00F1:  BSF    06.3
00F2:  BTFSS  03.0
00F3:  BCF    06.3
00F4:  BSF    21.6
00F5:  GOTO   0FC
00F6:  BCF    21.6
00F7:  DECFSZ 21,F
00F8:  GOTO   0EF
00F9:  GOTO   0FA
00FA:  NOP
00FB:  BSF    06.3
00FC:  MOVLW  02
00FD:  MOVWF  20
00FE:  CLRF   04
00FF:  DECFSZ 04,F
0100:  GOTO   0FF
0101:  DECFSZ 20,F
0102:  GOTO   0FE
0103:  MOVLW  AD
0104:  MOVWF  04
0105:  DECFSZ 04,F
0106:  GOTO   105
0107:  GOTO   108
0108:  NOP
0109:  BTFSC  21.7
010A:  GOTO   0EE
010B:  BTFSC  21.6
010C:  GOTO   0F6
010D:  RETLW  00
.................... #endif 
.................... #fuses HS,PUT,NOWDT 
.................... #include <mcp4921.c> 
.................... //////////////// Driver for MCP4921 D/A Converter /////////////////////// 
.................... ////                                                                 //// 
.................... ////  init_dac()    Call this before using a MCP4921 DAC             //// 
.................... ////                                                                 //// 
.................... ////  write_dac( long int )   Writes command and 12 bit resolution   //// 
.................... ////                          to the MCP4921 which converts it to a  //// 
.................... ////                          voltage                                //// 
.................... ////                          0-4095 input represents 0-vref V out.  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SELECT 
....................  
.................... #define DAC_CS     PIN_C4 
.................... #define DAC_CLK    PIN_C3 
.................... #define DAC_DI     PIN_C5 
.................... #define DAC_LDAC   PIN_B5 
....................  
.................... #endif 
....................  
.................... void init_dac() 
.................... { 
....................    output_high(DAC_CS); 
*
00CC:  BCF    2E.4
00CD:  MOVF   2E,W
00CE:  BSF    03.5
00CF:  MOVWF  07
00D0:  BCF    03.5
00D1:  BSF    07.4
....................    output_high(DAC_LDAC); 
00D2:  BSF    03.5
00D3:  BCF    06.5
00D4:  BCF    03.5
00D5:  BSF    06.5
....................    output_high(DAC_CLK); 
00D6:  BCF    2E.3
00D7:  MOVF   2E,W
00D8:  BSF    03.5
00D9:  MOVWF  07
00DA:  BCF    03.5
00DB:  BSF    07.3
....................    output_high(DAC_DI); 
00DC:  BCF    2E.5
00DD:  MOVF   2E,W
00DE:  BSF    03.5
00DF:  MOVWF  07
00E0:  BCF    03.5
00E1:  BSF    07.5
.................... } 
00E2:  BCF    0A.3
00E3:  GOTO   203 (RETURN)
....................  
.................... void write_dac(int16 data) { 
....................    BYTE cmd[3]; 
....................    BYTE i; 
....................  
....................    cmd[0]=data; 
....................    cmd[1]=(data>>8); 
....................    cmd[2]=0x03;                            
....................     
....................    output_high(DAC_LDAC); 
....................    output_low(DAC_CLK); 
....................    output_low(DAC_CS); 
....................  
....................    for(i=0; i<=23; ++i) 
....................    { 
....................       if(i<4 || (i>7 && i<12)) 
....................          shift_left(cmd,3,0); 
....................       else 
....................       { 
....................          output_bit(DAC_DI, shift_left(cmd,3,0)); 
....................  
....................          output_high(DAC_CLK); 
....................          output_low(DAC_CLK); 
....................       } 
....................    } 
....................    output_high(DAC_CS); 
....................  
....................    output_low(DAC_LDAC); 
....................    delay_us(10); 
....................     
....................    output_HIGH(DAC_LDAC); 
.................... } 
....................  
....................  
....................  
.................... #include "pid.h" 
.................... /*This file has been prepared for Doxygen automatic documentation generation.*/ 
.................... /*! \file ********************************************************************* 
....................  * 
....................  * \brief Header file for pid.c. 
....................  * 
....................  * - File:               pid.h 
....................  * - Compiler:           IAR EWAAVR 4.11A 
....................  * - Supported devices:  All AVR devices can be used. 
....................  * - AppNote:            AVR221 - Discrete PID controller 
....................  * 
....................  * \author               Atmel Corporation: http://www.atmel.com \n 
....................  *                       Support email: avr@atmel.com 
....................  * 
....................  * $Name$ 
....................  * $Revision: 456 $ 
....................  * $RCSfile$ 
....................  * $Date: 2006-02-16 12:46:13 +0100 (to, 16 feb 2006) $ 
....................  *****************************************************************************/ 
....................  
.................... #ifndef PID_H 
.................... #define PID_H 
....................  
.................... //#include "stdint.h" 
.................... #define INT16_MAX 32767 
.................... #define INT32_MAX 2147483647 
.................... #define SCALING_FACTOR  128 
....................  
.................... /*! \brief PID Status 
....................  * 
....................  * Setpoints and data used by the PID control algorithm 
....................  */ 
.................... typedef struct PID_DATA{ 
....................   //! Last process value, used to find derivative of process value. 
....................   int16 lastProcessValue; 
....................   //! Summation of errors, used for integrate calculations 
....................   int32 sumError; 
....................   //! The Proportional tuning constant, multiplied with SCALING_FACTOR 
....................   int16 P_Factor; 
....................   //! The Integral tuning constant, multiplied with SCALING_FACTOR 
....................   int16 I_Factor; 
....................   //! The Derivative tuning constant, multiplied with SCALING_FACTOR 
....................   int16 D_Factor; 
....................   //! Maximum allowed error, avoid overflow 
....................   int16 maxError; 
....................   //! Maximum allowed sumerror, avoid overflow 
....................   int32 maxSumError; 
.................... } pidData_t; 
....................  
.................... /*! \brief Maximum values 
....................  * 
....................  * Needed to avoid sign/overflow problems 
....................  */ 
.................... // Maximum value of variables 
.................... #define MAX_INT         INT16_MAX 
.................... #define MAX_LONG        INT32_MAX 
.................... #define MAX_I_TERM      (MAX_LONG / 2) 
....................  
.................... // Boolean values 
.................... //#define FALSE           0 
.................... //#define TRUE            1 
....................  
.................... boolean checkRunnaway(struct PID_DATA *pid); 
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid); 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st); 
.................... void pid_Reset_Integrator(pidData_t *pid_st); 
....................  
.................... #endif 
....................  
.................... /* 
.................... This is the main controller for the super capacitor hybrid scooter a.k.a RED 
.................... B2 close contactor 
.................... CONTROL BOX INPUTS 
.................... Athrottle- A0 - analog input representing the users input for speed, 10 bit 
.................... Vspeed - CCp2-a 16 bit representation of the speed of the vehicle 
.................... Acaps- A1 - analog input representing the current voltage of the supercapacitors, 10 bit 
.................... There are 18 Supercaps with a maximum voltage of 2.7 (2.85 is breakdown) volts for a total of 48.6 V 
.................... The circuit has a 10/110 voltage divider into the ADC. So minimum voltage of 18 Volts is 335 and 48 Volts is 893. Measured 38.2V equal to 726 
....................  
.................... CONTROL BOX OUTPUT 
.................... ICEthrottle- B1 - a 16 bit number sent to the internal combustion engine(ICE) throttle  
.................... ELECthrottle-  - a 16 bit number sent as analog value representing the demanded electric power 
....................  
.................... SPECIFICS OF I/O 
....................  
.................... Athrottle - the electric throttle is a 3 wire unit with a 5 volt,ground, and analog out 
....................    representing how far throttle is turned. Pin AN0 is the input. 
....................     
.................... Vspeed - There is a encoder in the rear wheel/electric motor that is used by the electric 
....................    power controller. Tapping in to this this Main Controller receives a 5 Volt square wave 
....................    with 42 pulses. There are two options for measuring speed. The first is to measure the  
....................    length of the pulses. The second is to measure the rate of pulses. This controller currently 
....................    uses the rate method. The int_ccp2 interupt is called on each falling edge and stores the  
....................    Vspeed value as the max number of 16bit (65535-timer0_since_last_reset).  
....................     
....................    The RED scooter has a circumpherence of 16.3*2*pi = 102.4 
....................    X m/h * 63360 inch/mile * 1/3600 h/sec * 1/(102.4 inch/rev) = .171875* X 
....................    Examples 50 mph is 8.9 ms 1 overflow of timer0 
....................    Example 5 mph is 89 ms or 13 time overflow 
....................     
....................    #int_timer0 increments the counter number_of_overflows each time it overflows 
....................    On int ccp2 we multiply number_of_overflows * 256 + timer0 to get timer0_since_last_reset 
....................     
.................... Acaps - the analog voltage which is the 5volt representation of the voltage in the caps which 
....................    have a value of between 0-48v. The voltages are factored so that the voltage on AN1 goes 
....................    from 0 - 4.8 volts (TODO check this factor, think its 1/11 not 1/10) 
....................     
.................... ICEthrottle -  #int_timer1 is set to make sure the period follows the required below 
....................    The period for the servo is .020 seconds which is 50,000 operations 
....................    The leftmost position of the server is .001 seconds which is 2,500 
....................    The rightmost position of the server is .002 seconds which is 5,000 
....................     
....................    The output pin is pin_B1.-> 
....................  
.................... ELECthrottle 
....................    The electric power controller takes an analog voltage as input. The output voltage 
....................    is set by the DAC. The pins used are C3,C4,C5. if CHARGING_STATE is true then  
....................     
.................... ALGORITHM 
....................    The algorithm is basically a PID controller. In broad terms we are trying to set the 
....................    ICEthrottle and ICEelectric to maximize the use of electric and accelerate to meet the 
....................    requirements set by the rider with the Athrottle signal. When the demanded power is  
....................    less than the power output possible by the ICE and the caps are in the CHARGING_STATE  
....................    then the ICE is turned up to the max and the ELECthrottle is set to regen to 
....................    charge the capacitors.If CHARGING_STATE is false then the caps are supplying the drivig power 
....................    and the ICE is set to "off", the caps supply the power. Unless the user requested supply 
....................    is enough to require both power sources. 
....................     
....................    If CHARGING_STATE is true. Then pin_b2 is set as high which will close the brake number 
....................    for the electric power controller.  
....................     
....................    If CHARGING_STATE is false then the pin_b2 is set low which opens brake. 
....................     
....................     
....................  
....................  
.................... The encoder has 42 on and offs per rotation, i.e. 21 steps 
....................  
.................... Number of operations per second is CLOCK/4/Timer Divisions 
.................... Number of operations per second is 20,000,000/4/128 = 39062.5  
.................... Each operation takes 1/39062.5 = .256 micro (x10^-6) seconds 
.................... Seconds to Overflow timer0 8bit timer = .256x10^-6 * 256 = 6.55ms 
....................  
....................  
....................  
.................... */ 
.................... #define servo_pin PIN_B1  //Setting servo out pin to be hardware pin b1 
.................... #define brake_pin PIN_B4 
.................... #define ADC_DELAY delay_us(20) 
.................... #define Acaps_pin PIN_A1 
.................... #define Acaps_channel 1 
.................... #define Athrottle_pin PIN_A0  //Voltage goes from 1.5 (306)to 4.1(836) 
.................... #define Athrottle_Min 316 
.................... #define Athrottle_Max 860 
.................... #define Athrottle_Full Athrottle_Max-Athrottle_Min 
.................... #define Athrottle_channel 0 
.................... #define Electric_Controller_Switch PIN_B0 
.................... #define Contactor_Switch PIN_B2 
.................... #define A_CAPS_MAX 725//893 
.................... #define A_CAPS_MIN 400//335 
.................... #define A_CAPS_MID_LOW (A_CAPS_MIN + 100) //This is the low end of the middle ACaps range. The range in which discharge and charge are allowed.  
.................... #define A_CAPS_MID_HIGH (A_CAPS_MAX - 100) //This is the low end of the middle ACaps range. The range in which discharge and charge are allowed.  
.................... #define V_SPEED_REGEN_MIN 50 //Why is there a minimum speed? Because below this no regenerative action is possible with electric motor 
.................... #define INSUFFICIENT_BRAKING_RUNNAWAY_ERROR 50000 
....................  
.................... //PID Values 
.................... #define K_P 1.50 
.................... #define K_I 0.00 
.................... #define K_D 0.20 
....................  
.................... struct PID_DATA pidData; 
.................... #define TIME_INTERVAL 157 //TODO replace 
....................  
.................... #define left_position 2500//4450 
.................... #define right_position 4600 
.................... #define servo_difference  right_position-left_position 
.................... #define servo_difference_div 5200 
.................... #define ELEC_CONTROLLER_OFFSET 900 
.................... //const float Athrottle_servo_factor = ((float) servo_difference)/((float) Athrottle_FULL); 
.................... #define servo_period   65356-50000 
.................... unsigned int16 current_servo_position=right_position; 
*
01CA:  MOVLW  F8
01CB:  MOVWF  41
01CC:  MOVLW  11
01CD:  MOVWF  42
.................... int1 SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0; 
01CE:  BCF    43.0
....................  
.................... unsigned int16 number_of_timer0_interupts_since_reset =0; 
01CF:  CLRF   44
01D0:  CLRF   45
.................... unsigned int16 vSpeed= 0; 
01D1:  CLRF   46
01D2:  CLRF   47
.................... signed int16 ELECthrottle = 0; 
01D3:  CLRF   48
01D4:  CLRF   49
.................... unsigned int16 ICEthrottle = 0; 
01D5:  CLRF   4A
01D6:  CLRF   4B
.................... unsigned int16 Athrottle = 0; 
01D7:  CLRF   4C
01D8:  CLRF   4D
.................... unsigned int16 Acaps = 0; 
01D9:  CLRF   4E
01DA:  CLRF   4F
.................... int1 ICE_ON = 0; 
01DB:  BCF    43.1
.................... int1 CURRENTLY_CHARGING = 0; 
01DC:  BCF    43.2
.................... int1 RUNNAWAY_CHECK = 0; 
01DD:  BCF    43.3
.................... signed int16 returnedValue =0;  
01DE:  CLRF   50
01DF:  CLRF   51
....................  
.................... enum{  
....................    EVERYTHING_OFF, 
....................    SPEED_TO_LOW_ICE_DIRECT, 
....................    CHARGING_ALLOWED,  
....................    DISCHARGING_ALLOWED,  
....................    CHARGING_AND_DISCHARING_ALLOWED, 
....................    INSUFFICIENT_BRAKING_RUNAWAY, 
....................    USER_INPUT_OFF 
.................... } CHARGING_STATE;  
....................  
.................... /* 
.................... The #int_timer0 interupt is triggered on each timer0 8bit interupt 
.................... the function simply increments a overflow counter to be used by the ccp2 
.................... interupt to calculate speed 
.................... NUMBER OF OPERATIONS =  
.................... */ 
.................... #int_timer0 
.................... void timer0_isr(){ 
....................     
....................       number_of_timer0_interupts_since_reset=number_of_timer0_interupts_since_reset+256; 
*
0059:  MOVLW  01
005A:  ADDWF  45,F
....................       //current_servo_position=current_servo_position+1; 
....................        
....................     
....................    if (number_of_timer0_interupts_since_reset>=1024){ 
005B:  MOVF   45,W
005C:  SUBLW  03
005D:  BTFSC  03.0
005E:  GOTO   064
....................       vSpeed = 0; 
005F:  CLRF   47
0060:  CLRF   46
....................       number_of_timer0_interupts_since_reset=1024; 
0061:  MOVLW  04
0062:  MOVWF  45
0063:  CLRF   44
....................        
....................        
....................    } 
.................... } 
....................  
.................... /* 
.................... #int_timer1 is used by the ICEservo throttle to regulate the timing pulses. The  
.................... timer is setup for a pulsetrain of 20ms period. This is done as follows, 
....................  
.................... Period is 1/(CLOCK/4opsperclock)*(startingPostionOfClock) = 20 ms 
.................... for this setup 1/(20000000/4)*(50000) = 20 ms 
....................  
.................... The timer1 starts at 0 and counts up. So we set the beggining of the clock at 
.................... servo_period which is 65356-50000 so that the total time is 20ms. 
.................... */ 
0064:  BCF    0B.2
0065:  BCF    0A.3
0066:  GOTO   02C
.................... #int_timer1 
.................... void isr() 
.................... { 
....................  
.................... //Make sure that the position is within the left and right positions of the servo 
....................    if (current_servo_position<left_position){ 
0067:  MOVF   42,W
0068:  SUBLW  09
0069:  BTFSS  03.0
006A:  GOTO   076
006B:  BTFSS  03.2
006C:  GOTO   071
006D:  MOVF   41,W
006E:  SUBLW  C3
006F:  BTFSS  03.0
0070:  GOTO   076
....................       current_servo_position = left_position; 
0071:  MOVLW  09
0072:  MOVWF  42
0073:  MOVLW  C4
0074:  MOVWF  41
....................    } 
....................    else if (current_servo_position > right_position){ 
0075:  GOTO   085
0076:  MOVF   42,W
0077:  SUBLW  10
0078:  BTFSC  03.0
0079:  GOTO   085
007A:  XORLW  FF
007B:  BTFSS  03.2
007C:  GOTO   081
007D:  MOVF   41,W
007E:  SUBLW  F8
007F:  BTFSC  03.0
0080:  GOTO   085
....................       current_servo_position = right_position; 
0081:  MOVLW  11
0082:  MOVWF  42
0083:  MOVLW  F8
0084:  MOVWF  41
....................    } 
.................... //printf("Current servo position %ld",current_servo_position); 
....................    if(SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER) 
0085:  BTFSS  43.0
0086:  GOTO   09A
....................       {  
....................          output_high(servo_pin);        //Set the servo control pin to high  
0087:  BSF    03.5
0088:  BCF    06.1
0089:  BCF    03.5
008A:  BSF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0;  
008B:  BCF    43.0
....................          set_timer1(65356-current_servo_position); //Set timer for the position high pulse 
008C:  MOVF   41,W
008D:  SUBLW  4C
008E:  MOVWF  61
008F:  MOVLW  FF
0090:  MOVWF  62
0091:  MOVF   42,W
0092:  BTFSS  03.0
0093:  INCFSZ 42,W
0094:  SUBWF  62,F
0095:  MOVF   62,W
0096:  MOVWF  0F
0097:  MOVF   61,W
0098:  MOVWF  0E
....................       }  
....................    else  
0099:  GOTO   0AC
....................       {  
....................          output_low(servo_pin);                      // Set the servo control pin to low   
009A:  BSF    03.5
009B:  BCF    06.1
009C:  BCF    03.5
009D:  BCF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 1;  
009E:  BSF    43.0
....................          set_timer1(servo_period+current_servo_position);          //Set timer for the low position the length is the difference between  
009F:  MOVLW  FC
00A0:  ADDWF  41,W
00A1:  MOVWF  61
00A2:  MOVF   42,W
00A3:  MOVWF  62
00A4:  MOVLW  3B
00A5:  BTFSC  03.0
00A6:  MOVLW  3C
00A7:  ADDWF  62,F
00A8:  MOVF   62,W
00A9:  MOVWF  0F
00AA:  MOVF   61,W
00AB:  MOVWF  0E
....................                                                      //the total int16 lenght - high pulse length 
....................       }   
....................  
.................... } 
....................  
....................  
.................... /* 
.................... #int_ccp2 is called on the falling edge of the encoder pulse. We calculate the time 
.................... between pulses.  
.................... TODO will have to put some kind of smoothing mechanism 
.................... */ 
00AC:  BCF    0C.0
00AD:  BCF    0A.3
00AE:  GOTO   02C
.................... #int_ccp2 
.................... void isr2() 
.................... { 
.................... if (number_of_timer0_interupts_since_reset>10){ 
00AF:  MOVF   45,F
00B0:  BTFSS  03.2
00B1:  GOTO   0B6
00B2:  MOVF   44,W
00B3:  SUBLW  0A
00B4:  BTFSC  03.0
00B5:  GOTO   0C9
.................... vSpeed  = 1280 - (number_of_timer0_interupts_since_reset+get_timer0()); 
00B6:  MOVF   01,W
00B7:  ADDWF  44,W
00B8:  MOVWF  21
00B9:  MOVF   45,W
00BA:  MOVWF  23
00BB:  BTFSC  03.0
00BC:  INCF   23,F
00BD:  MOVF   21,W
00BE:  SUBLW  00
00BF:  MOVWF  46
00C0:  MOVLW  05
00C1:  MOVWF  47
00C2:  MOVF   23,W
00C3:  BTFSS  03.0
00C4:  INCFSZ 23,W
00C5:  SUBWF  47,F
.................... //vSpeed  = -(get_timer0()); 
.................... set_timer0(0); 
00C6:  CLRF   01
.................... number_of_timer0_interupts_since_reset = 0; 
00C7:  CLRF   45
00C8:  CLRF   44
.................... } 
.................... } 
....................  
00C9:  BCF    0D.0
00CA:  BCF    0A.3
00CB:  GOTO   02C
.................... void trickBreaking(){ 
.................... write_dac((unsigned int16) 400+ELEC_CONTROLLER_OFFSET); 
.................... delay_ms(500);       
.................... } 
....................  
.................... void printfLogf(char string){ 
....................    #ifdef DEBUG 
....................       printf("IN PrintfLog"); 
....................       printf("%c",string); 
....................    #else 
....................       delay_ms(250); 
....................    #endif 
.................... } 
....................  
.................... #ifdef TEST 
....................  
.................... /* 
.................... TEST SUITE 
.................... */ 
....................  
.................... void createHeartbeat(){ 
....................   //This creates a heartbeat on pin B1 
....................   while (1){ 
....................            output_high(servo_pin);        //Set the servo control pin to high 
....................            delay_ms(1000); 
....................            output_low(servo_pin); 
....................            delay_ms(1000); 
....................     } 
.................... } 
....................  
.................... void wiperAnalogVoltage(){ 
....................   
....................  //signed int16 test =0; 
....................  unsigned int16 wiperValue = 0; 
....................     while (1){ 
.................... printf("Wiper Value is now %ld",wiperValue); 
....................    
....................   if (wiperValue>(4095)){ 
....................      wiperValue = 0; 
....................     printf("Wiper Value is now %ld",wiperValue); 
....................   } 
....................   wiperValue=wiperValue+10; 
....................   write_dac(wiperValue); 
....................   delay_ms(10); 
....................     } 
.................... } 
....................  
.................... void heartbeatElectricControllerPower(){ 
....................     while (1){ 
....................  
....................   output_high(Contactor_Switch);        //Set the servo control pin to high 
....................            delay_ms(1000); 
....................            output_low(Contactor_Switch); 
....................            delay_ms(1000); 
....................     } 
.................... } 
....................  
.................... void wiperServo(){ 
....................     unsigned int32 wiperValue = 0; 
*
010E:  CLRF   53
010F:  CLRF   54
0110:  CLRF   55
0111:  CLRF   56
....................   current_servo_position = left_position; 
0112:  MOVLW  09
0113:  MOVWF  42
0114:  MOVLW  C4
0115:  MOVWF  41
....................     while (1){ 
....................   printf("Servo Value %ld",current_servo_position); 
0116:  CLRF   57
0117:  MOVF   57,W
0118:  CALL   045
0119:  INCF   57,F
011A:  MOVWF  20
011B:  MOVF   20,W
011C:  MOVWF  60
011D:  CALL   0E4
011E:  MOVLW  0C
011F:  SUBWF  57,W
0120:  BTFSS  03.2
0121:  GOTO   117
0122:  MOVLW  10
0123:  MOVWF  04
0124:  MOVF   42,W
0125:  MOVWF  59
0126:  MOVF   41,W
0127:  MOVWF  58
....................   if ((current_servo_position+10)>right_position){ 
*
019C:  MOVLW  0A
019D:  ADDWF  41,W
019E:  MOVWF  57
019F:  MOVF   42,W
01A0:  MOVWF  58
01A1:  BTFSC  03.0
01A2:  INCF   58,F
01A3:  MOVF   58,W
01A4:  SUBLW  10
01A5:  BTFSC  03.0
01A6:  GOTO   1B2
01A7:  XORLW  FF
01A8:  BTFSS  03.2
01A9:  GOTO   1AE
01AA:  MOVF   57,W
01AB:  SUBLW  F8
01AC:  BTFSC  03.0
01AD:  GOTO   1B2
....................     current_servo_position = left_position;//servo_difference; 
01AE:  MOVLW  09
01AF:  MOVWF  42
01B0:  MOVLW  C4
01B1:  MOVWF  41
....................   } 
....................   current_servo_position =current_servo_position+10; 
01B2:  MOVLW  0A
01B3:  ADDWF  41,F
01B4:  BTFSC  03.0
01B5:  INCF   42,F
....................   //delay_ms(1); 
....................     } 
01B6:  GOTO   116
.................... } 
01B7:  BCF    0A.3
01B8:  GOTO   21D (RETURN)
....................  
.................... void printAnalogThrottleInput(){ 
....................     set_adc_channel(Athrottle_channel); 
....................       ADC_DELAY; 
....................       Athrottle = read_adc(); 
....................   printf("Analog Throttle is %ld",Athrottle ); 
.................... } 
....................  
.................... void main() 
.................... { 
01B9:  CLRF   04
01BA:  MOVLW  1F
01BB:  ANDWF  03,F
01BC:  BSF    03.5
01BD:  BCF    06.3
01BE:  BCF    03.5
01BF:  BSF    06.3
01C0:  BSF    03.5
01C1:  BSF    1F.0
01C2:  BSF    1F.1
01C3:  BSF    1F.2
01C4:  BCF    1F.3
01C5:  MOVLW  07
01C6:  MOVWF  1C
....................  
....................    setup_adc_ports(NO_ANALOGS); 
*
01E0:  BSF    03.5
01E1:  BSF    1F.0
01E2:  BSF    1F.1
01E3:  BSF    1F.2
01E4:  BCF    1F.3
....................    setup_adc(ADC_OFF); 
01E5:  BCF    03.5
01E6:  BCF    1F.0
....................    setup_spi(FALSE); 
01E7:  CLRF   14
....................  
....................    setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
01E8:  BSF    03.5
01E9:  MOVF   01,W
01EA:  ANDLW  C0
01EB:  IORLW  00
01EC:  MOVWF  01
01ED:  CLRWDT
....................    setup_timer_1(T1_DISABLED); 
01EE:  BCF    03.5
01EF:  CLRF   10
....................    setup_timer_2(T2_DISABLED,0,1); 
01F0:  MOVLW  00
01F1:  MOVWF  21
01F2:  MOVWF  12
01F3:  MOVLW  00
01F4:  BSF    03.5
01F5:  MOVWF  12
....................    setup_port_a(ALL_ANALOG); 
01F6:  BCF    1F.0
01F7:  BCF    1F.1
01F8:  BCF    1F.2
01F9:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
01FA:  BCF    1F.6
01FB:  BCF    03.5
01FC:  BSF    1F.6
01FD:  BSF    1F.7
01FE:  BSF    03.5
01FF:  BSF    1F.7
0200:  BCF    03.5
0201:  BSF    1F.0
....................  
....................    init_dac(); 
0202:  GOTO   0CC
....................  
....................    setup_timer_1(T1_DIV_BY_2| T1_INTERNAL); 
0203:  MOVLW  95
0204:  MOVWF  10
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_128); 
0205:  BSF    03.5
0206:  MOVF   01,W
0207:  ANDLW  C0
0208:  IORLW  06
0209:  MOVWF  01
....................    setup_ccp2(CCP_CAPTURE_RE);    // Configure CCP2 to capture fall 
020A:  BCF    03.5
020B:  BSF    2E.1
020C:  MOVF   2E,W
020D:  BSF    03.5
020E:  MOVWF  07
020F:  BCF    03.5
0210:  CLRF   1D
0211:  MOVLW  05
0212:  MOVWF  1D
....................    enable_interrupts(INT_CCP2);   // Setup interrupt on falling edge 
0213:  BSF    03.5
0214:  BSF    0D.0
....................    enable_interrupts(INT_TIMER0); 
0215:  BCF    03.5
0216:  BSF    0B.5
....................    enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
0217:  BSF    03.5
0218:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
0219:  MOVLW  C0
021A:  BCF    03.5
021B:  IORWF  0B,F
....................  
....................    while(TRUE) { 
....................         //Test Breaking Analog Voltage. Should produce analog voltage  on pin 13 as well as drive pin 12 LOW 
....................         //output_high(brake_pin); 
....................         //output_high(Electric_Controller_Switch); 
....................         //wiperAnalogVoltage(); 
....................  
....................         //Test Accelerating Analog Voltage. Should produce analog voltage on pin 15 and let pin 12 float. 
....................         //output_low(brake_pin); 
....................         //output_low(Electric_Controller_Switch); 
....................         //wiperAnalogVoltage(); 
....................          
....................         //Test Short Circuit from Pin 11 to pin 8 with 1 second heartbeat. This tests V+ Controller. Also pin 9 should be heartbeating between 0 and 12V 
....................         //heartbeatElectricControllerPower(); 
....................          //printf("test loop"); 
....................         //Test Wiper of Servo 
....................         wiperServo(); 
021C:  GOTO   10E
....................         //current_servo_position = right_position; 
....................        //printAnalogThrottleInput(); 
....................         
....................        //Test Electric Controller Out 
....................        //output_high(Contactor_Switch); 
....................        //output_high(Contactor_Switch2); 
....................  
....................    } 
021D:  GOTO   21C
....................  
....................  
.................... } 
....................  
....................  
....................  
.................... #else 
.................... void main() 
.................... {   
....................     
....................    setup_adc_ports(NO_ANALOGS); 
....................    setup_adc(ADC_OFF); 
....................    setup_spi(FALSE); 
....................     
....................    setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
....................    setup_timer_1(T1_DISABLED); 
....................    setup_timer_2(T2_DISABLED,0,1); 
....................    setup_port_a(ALL_ANALOG); 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
....................     
....................    init_dac(); 
....................   
....................    setup_timer_1(T1_DIV_BY_2| T1_INTERNAL);  
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_128); 
....................    setup_ccp2(CCP_CAPTURE_RE);    // Configure CCP2 to capture fall 
....................    enable_interrupts(INT_CCP2);   // Setup interrupt on falling edge 
....................    enable_interrupts(INT_TIMER0); 
....................    enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
....................    enable_interrupts(GLOBAL); 
....................     
....................    CHARGING_STATE = EVERYTHING_OFF; 
....................    output_low(Electric_Controller_Switch); 
....................    write_dac(0); 
....................    ICE_ON=TRUE; 
....................    output_high(Contactor_Switch); 
....................    output_low(brake_pin); 
....................    pid_Init(K_P*SCALING_FACTOR,K_I*SCALING_FACTOR,K_D*SCALING_FACTOR, & pidData); 
....................    delay_ms(3000); 
....................    current_servo_position =left_position-500; 
....................    delay_ms(20000); 
....................    current_servo_position =right_position; 
....................    //write_dac(1000); 
....................    //delay_ms(10000); 
....................    //output_high(Contactor_Switch); 
....................    //output_high(brake_pin); 
....................    //output_high(Electric_Controller_Switch); 
....................    while(TRUE) { 
....................        
....................       //GET INPUTS 
....................       //Vspeedhappens in interrupts 
....................       set_adc_channel(Acaps_channel); 
....................       ADC_DELAY; 
....................       Acaps = read_adc(); 
....................        
....................       set_adc_channel(Athrottle_channel); 
....................       ADC_DELAY; 
....................       Athrottle = read_adc(); 
....................       if (Athrottle<Athrottle_Min){ 
....................          Athrottle=Athrottle_Min; 
....................       } 
....................       //SET THE STATE 
....................       if (Acaps> (A_CAPS_MAX +10)){ 
....................          //FREAK OUT 
....................          //printf("State: Freak Out \n"); 
....................          output_low(Electric_Controller_Switch); 
....................          write_dac(0); 
....................          //ICE_ON = FALSE; 
....................          ICEthrottle = 0; 
....................          //output_high(Contactor_Switch); 
....................          CHARGING_STATE =EVERYTHING_OFF; 
....................         //return; 
....................         //break; 
....................       } 
....................       else if (Athrottle<(Athrottle_Min+5)){ 
....................          CHARGING_STATE = USER_INPUT_OFF; 
....................          #ifdef DEBUG 
....................             printf("State: Throttle Off \n");   
....................          #else 
....................             delay_ms(250); 
....................          #endif 
....................           
....................          } 
....................       else if (ICE_ON&&(vSpeed<V_SPEED_REGEN_MIN)){ 
....................          #ifdef DEBUG 
....................             printf("State: Speed To Low %ld \n",vSpeed);   
....................          #else 
....................             delay_ms(250); 
....................          #endif 
....................          CHARGING_STATE=SPEED_TO_LOW_ICE_DIRECT; 
....................       } 
....................       else if (checkRunnaway(& pidData)){// INSUFFICIENT_BRAKING_RUNNAWAY_ERROR){ 
....................          #ifdef DEBUG 
....................             printf("State: RUNNAWAY \n");   
....................          #else 
....................             delay_ms(250); 
....................          #endif 
....................          ICE_ON=TRUE; 
....................          CHARGING_STATE=INSUFFICIENT_BRAKING_RUNAWAY; 
....................       } 
....................       else if ((Acaps > A_CAPS_MAX)&&(CHARGING_STATE==CHARGING_ALLOWED||CHARGING_STATE==CHARGING_AND_DISCHARING_ALLOWED)){ 
....................          //Stop Charging they are full 
....................           
....................          #ifdef DEBUG 
....................             printf("State: Caps Full \n");   
....................          #else 
....................             delay_ms(250); 
....................          #endif 
....................           
....................         ICE_ON=FALSE; 
....................         CHARGING_STATE=DISCHARGING_ALLOWED; 
....................       } 
....................       else if ((Acaps < A_CAPS_MIN)&& CHARGING_STATE!=CHARGING_ALLOWED){ 
....................          //Stop running electric, the caps are almost empty 
....................          
....................         #ifdef DEBUG 
....................             printf("State: Caps Empty \n");   
....................          #else 
....................             delay_ms(250); 
....................          #endif 
....................  
....................         ICE_ON=TRUE; 
....................         CHARGING_STATE=CHARGING_ALLOWED; 
....................       } 
....................      else if (A_CAPS_MID_LOW < Acaps < A_CAPS_MID_HIGH){ 
....................         #ifdef DEBUG 
....................             printf("State: Normal \n");   
....................          #else 
....................             delay_ms(250); 
....................          #endif 
....................          CHARGING_STATE=CHARGING_AND_DISCHARING_ALLOWED; 
....................      } 
....................       
....................       
.................... //PID CONTROLLER 
....................       //Servo to mirror Athrottle ->  
....................       //current_servo_position=right_position-(Athrottle-Athrottle_Min)*Athrottle_servo_factor;//(Athrottle/Athrottle_Full)*servo_difference;//(vSpeed/65536.0)*(2500); 
....................       ////printf("Analog Cap %d Analog Throttle %Lu\n",(int) Acaps,Athrottle); 
....................       //current_servo_position =right_position-vSpeed+200; 
....................       ////printf("Speed %lu \n",speeder); 
....................       //SET OUTPUTS  
....................       //The writing of the ICEThrottle happens in interupts and all that is 
....................       //required is updating ICEthrottle 
....................        
....................       returnedValue = pid_Controller((Athrottle-AThrottle_Min),vSpeed,& pidData); 
....................       ELECthrottle = ELECthrottle+returnedValue; 
....................       //printf("Throttle %ld and electhrottle %ld \n",Athrottle,ELECthrottle); 
....................        
....................       
....................       if (ELECthrottle>2500){ 
....................          ELECthrottle=2500; 
....................       } 
....................       else if (ELECthrottle<-2500){ 
....................          ELECthrottle = -2500; 
....................       } 
....................        
....................        
....................       //SET OUTPUTS 
....................       if (CHARGING_STATE==EVERYTHING_OFF||CHARGING_STATE==USER_INPUT_OFF){ 
....................          ICEthrottle = 0; 
....................          ICE_ON = FALSE; 
....................          current_servo_position =right_position; 
....................          write_dac(0); 
....................       } 
....................       else if (CHARGING_STATE==SPEED_TO_LOW_ICE_DIRECT || CHARGING_STATE==INSUFFICIENT_BRAKING_RUNAWAY){ 
....................          if (ELECthrottle>0){ 
....................             current_servo_position =right_position- (3*ELECthrottle); 
....................          } 
....................          else{ 
....................             current_servo_position =right_position; 
....................          } 
....................          ICE_ON = TRUE; 
....................          write_dac(0); 
....................       } 
....................       else{ 
....................       if (ELECthrottle<0){ 
....................         if (CHARGING_STATE==CHARGING_ALLOWED || CHARGING_STATE ==CHARGING_AND_DISCHARING_ALLOWED){ 
....................              if (CURRENTLY_CHARGING==1){ 
....................                 trickBreaking(); 
....................              } 
....................              //ELECthrottle = 300; 
....................              CURRENTLY_CHARGING=0; 
....................              output_high(brake_pin); 
....................              output_high(Electric_Controller_Switch); 
....................              //printf("BREAKING \n"); 
....................              write_dac((abs(ELECthrottle)+ELEC_CONTROLLER_OFFSET)); 
....................         } 
....................         else{ 
....................            //Decrease ICE throttle 
....................            write_dac(0); 
....................        
....................         } 
....................       } 
....................       else { 
....................         if (CHARGING_STATE==DISCHARGING_ALLOWED || CHARGING_STATE ==CHARGING_AND_DISCHARING_ALLOWED){ 
....................              CURRENTLY_CHARGING=1; 
....................              output_low(brake_pin); 
....................              output_low(Electric_Controller_Switch); 
....................              //printf("ACCELERATING \n"); 
....................              write_dac((abs(ELECthrottle)+ELEC_CONTROLLER_OFFSET)); 
....................         } 
....................         else{ 
....................            //Increase ICE throttle 
....................            write_dac(0); 
....................        
....................         } 
....................           
....................       } 
....................       if (ICE_ON){ 
....................          //printf("ICE NORMAL \n"); 
....................          current_servo_position = left_position +500; 
....................       } 
....................       else{ 
....................          current_servo_position =right_position; 
....................          //printf("ICE OFF \n"); 
....................       } 
....................       } 
....................             
....................    } 
....................     
....................  
.................... } 
....................  
.................... #endif 
....................  
.................... boolean checkRunnaway(struct PID_DATA *pid) 
.................... { 
021E:  GOTO   21E
.................... //return (pid->sumError > INSUFFICIENT_BRAKING_RUNNAWAY_ERROR); 
.................... return FALSE; 
.................... } 
....................  
.................... /*! \brief Initialisation of PID controller parameters. 
....................  * 
....................  *  Initialise the variables used by the PID algorithm. 
....................  * 
....................  *  \param p_factor  Proportional term. 
....................  *  \param i_factor  Integral term. 
....................  *  \param d_factor  Derivate term. 
....................  *  \param pid  Struct with PID status. 
....................  */ 
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid) 
.................... // Set up PID controller parameters 
.................... { 
....................   // Start values for PID controller 
....................   pid->sumError = 0; 
....................   pid->lastProcessValue = 0; 
....................   // Tuning constants for PID loop 
....................   pid->P_Factor = p_factor; 
....................   pid->I_Factor = i_factor; 
....................   pid->D_Factor = d_factor; 
....................   // Limits to avoid overflow 
....................   pid->maxError = MAX_INT / (pid->P_Factor + 1); 
....................   ////printf("Max %ld factor %ld and pid %ld",MAX_INT,pid->I_Factor,pid->maxError); 
....................   pid->maxSumError = MAX_I_TERM / (pid->I_Factor + 1); 
.................... } 
....................  
....................  
.................... /*! \brief PID control algorithm. 
....................  * 
....................  *  Calculates output from setpoint, process value and PID status. 
....................  * 
....................  *  \param setPoint  Desired value. 
....................  *  \param processValue  Measured value. 
....................  *  \param pid_st  PID status struct. 
....................  */ 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st) 
.................... { 
....................   signed int16 error, p_term, d_term; 
....................   signed int32 i_term, ret, temp; 
....................     processValue=processValue/4; 
....................   ////printf("input %ld speed %ld ",setPoint,processValue); 
....................   error = setPoint - processValue; 
....................    
....................   // Calculate Pterm and limit error overflow 
....................    
....................   if (error > (signed int16) pid_st->maxError){ 
....................     p_term = MAX_INT; 
....................     ////printf("p greater error %ld a %ld p %ld",error,pid_st->maxError,p_term); 
....................  
....................   } 
....................   else if (error < (signed int16) -pid_st->maxError){ 
....................     p_term = -MAX_INT; 
....................     ////printf("p less error %ld a %ld p %ld",error,-pid_st->maxError,p_term); 
....................  
....................   } 
....................   else{ 
....................     p_term = (signed int16) (pid_st->P_Factor * (float) error); 
....................     ////printf("error %ld a %ld p %ld",error,pid_st->maxError,p_term); 
....................   } 
....................    
....................   // Calculate Iterm and limit integral runaway 
....................   temp = pid_st->sumError + error; 
....................   if(temp > (signed int32)pid_st->maxSumError){ 
....................     i_term = MAX_I_TERM; 
....................     pid_st->sumError = pid_st->maxSumError; 
....................     ////printf("\n greater temp %ld a %ld sum %ld",temp,pid_st->maxSumError,pid_st->sumError); 
....................  
....................  } 
....................   else if(temp < (signed int32)-pid_st->maxSumError){ 
....................     i_term = -MAX_I_TERM; 
....................     pid_st->sumError = -pid_st->maxSumError; 
....................     ////printf("\n less temp %ld a %ld sum %ld",temp,pid_st->maxSumError,pid_st->sumError); 
....................  
....................   } 
....................   else{ 
....................     pid_st->sumError = temp; 
....................     i_term = pid_st->I_Factor * pid_st->sumError; 
....................     ////printf("\n eror temp %ld i_term %ld sum %ld error %ld ",temp,i_term,pid_st->sumError,error); 
....................  
....................   } 
....................  
....................   // Calculate Dterm 
....................   d_term = pid_st->D_Factor * (pid_st->lastProcessValue - processValue); 
.................... ////printf("\n p_term %ld d_term %ld i_term %ld",p_term,d_term,i_term); 
....................   pid_st->lastProcessValue = processValue; 
....................  
....................   //ret = (p_term + i_term + d_term) / SCALING_FACTOR; 
....................    ret = (p_term+d_term+(signed int16)i_term) / SCALING_FACTOR; 
....................   if(ret > MAX_INT){ 
....................     ret = MAX_INT; 
....................   } 
....................   else if(ret < -MAX_INT){ 
....................     ret = -MAX_INT; 
....................   } 
....................  
....................   return((signed int16)ret); 
.................... } 
....................  
.................... /*! \brief Resets the integrator. 
....................  * 
....................  *  Calling this function will reset the integrator in the PID regulator. 
....................  */ 
.................... void pid_Reset_Integrator(pidData_t *pid_st) 
.................... { 
....................   pid_st->sumError = 0; 
.................... } 
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 373A   HS NOWDT NOPUT DEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
