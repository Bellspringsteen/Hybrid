<<<<<<< HEAD
CCS PCM C Compiler, Version 4.084, 46530               16-Feb-13 15:18

               Filename: HondaHybrid.lst

               ROM used: 1418 words (37%)
                         Largest free fragment is 1788
               RAM used: 61 (34%) at main() level
                         97 (54%) worst case
               Stack:    4 worst case (3 in main + 1 for interrupts)
=======
CCS PCM C Compiler, Version 4.084, 46530               05-Jan-13 14:24

               Filename: HondaHybrid.lst

               ROM used: 2025 words (53%)
                         Largest free fragment is 1788
               RAM used: 63 (35%) at main() level
                         102 (57%) worst case
               Stack:    3 worst case (2 in main + 1 for interrupts)
>>>>>>> c3b8e56ca4afb031060d4e36e288e08742690935

*
0000:  NOP
0001:  MOVLW  00
0002:  MOVWF  0A
<<<<<<< HEAD
0003:  GOTO   44B
=======
0003:  GOTO   6A6
>>>>>>> c3b8e56ca4afb031060d4e36e288e08742690935
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  26
0008:  MOVF   7F,W
0009:  MOVWF  25
000A:  MOVF   0A,W
000B:  MOVWF  2D
000C:  CLRF   0A
000D:  SWAPF  25,F
000E:  MOVF   04,W
000F:  MOVWF  27
0010:  MOVF   20,W
0011:  MOVWF  28
0012:  MOVF   21,W
0013:  MOVWF  29
0014:  MOVF   22,W
0015:  MOVWF  2A
0016:  MOVF   23,W
0017:  MOVWF  2B
0018:  MOVF   24,W
0019:  MOVWF  2C
001A:  BCF    03.7
001B:  BCF    03.5
001C:  MOVLW  8C
001D:  MOVWF  04
001E:  BTFSS  00.0
001F:  GOTO   022
0020:  BTFSC  0C.0
0021:  GOTO   03F
0022:  MOVLW  8D
0023:  MOVWF  04
0024:  BTFSS  00.0
0025:  GOTO   028
0026:  BTFSC  0D.0
0027:  GOTO   041
0028:  BTFSS  0B.5
0029:  GOTO   02C
002A:  BTFSC  0B.2
002B:  GOTO   043
002C:  MOVF   27,W
002D:  MOVWF  04
002E:  MOVF   28,W
002F:  MOVWF  20
0030:  MOVF   29,W
0031:  MOVWF  21
0032:  MOVF   2A,W
0033:  MOVWF  22
0034:  MOVF   2B,W
0035:  MOVWF  23
0036:  MOVF   2C,W
0037:  MOVWF  24
0038:  MOVF   2D,W
0039:  MOVWF  0A
003A:  SWAPF  26,W
003B:  MOVWF  03
003C:  SWAPF  7F,F
003D:  SWAPF  7F,W
003E:  RETFIE
003F:  BCF    0A.3
0040:  GOTO   07D
0041:  BCF    0A.3
<<<<<<< HEAD
0042:  GOTO   0D5
=======
0042:  GOTO   0AB
>>>>>>> c3b8e56ca4afb031060d4e36e288e08742690935
0043:  BCF    0A.3
0044:  GOTO   06E
.................... #include "HondaHybrid.h" 
.................... #include <16F873A.h> 
.................... //////// Standard Header file for the PIC16F873A device //////////////// 
.................... #device PIC16F873A 
.................... #list 
....................  
....................  
.................... //#include <16F737.h> 
.................... #device ICD=TRUE 
.................... #device adc=10 
.................... //#device adc=8 
.................... #use delay(clock=20000000) 
*
<<<<<<< HEAD
024C:  MOVLW  59
024D:  MOVWF  04
024E:  MOVF   00,W
024F:  BTFSC  03.2
0250:  GOTO   25E
0251:  MOVLW  06
0252:  MOVWF  21
0253:  CLRF   20
0254:  DECFSZ 20,F
0255:  GOTO   254
0256:  DECFSZ 21,F
0257:  GOTO   253
0258:  MOVLW  7B
0259:  MOVWF  20
025A:  DECFSZ 20,F
025B:  GOTO   25A
025C:  DECFSZ 00,F
025D:  GOTO   251
025E:  BCF    0A.3
025F:  GOTO   4D5 (RETURN)
=======
0222:  MOVLW  57
0223:  MOVWF  04
0224:  MOVF   00,W
0225:  BTFSC  03.2
0226:  GOTO   234
0227:  MOVLW  06
0228:  MOVWF  21
0229:  CLRF   20
022A:  DECFSZ 20,F
022B:  GOTO   22A
022C:  DECFSZ 21,F
022D:  GOTO   229
022E:  MOVLW  7B
022F:  MOVWF  20
0230:  DECFSZ 20,F
0231:  GOTO   230
0232:  DECFSZ 00,F
0233:  GOTO   227
0234:  BCF    0A.3
0235:  GOTO   72C (RETURN)
>>>>>>> c3b8e56ca4afb031060d4e36e288e08742690935
.................... #fuses HS,PUT,NOWDT 
.................... #use rs232 (DEBUGGER) 
0260:  BSF    03.5
0261:  BCF    06.3
0262:  BCF    03.5
0263:  BCF    06.3
0264:  MOVLW  08
0265:  MOVWF  21
0266:  GOTO   267
0267:  NOP
0268:  BSF    21.7
0269:  GOTO   278
026A:  BCF    21.7
026B:  RRF    7D,F
026C:  BTFSC  03.0
026D:  BSF    06.3
026E:  BTFSS  03.0
026F:  BCF    06.3
0270:  BSF    21.6
0271:  GOTO   278
0272:  BCF    21.6
0273:  DECFSZ 21,F
0274:  GOTO   26B
0275:  GOTO   276
0276:  NOP
0277:  BSF    06.3
0278:  MOVLW  02
0279:  MOVWF  20
027A:  CLRF   04
027B:  DECFSZ 04,F
027C:  GOTO   27B
027D:  DECFSZ 20,F
027E:  GOTO   27A
027F:  MOVLW  AD
0280:  MOVWF  04
0281:  DECFSZ 04,F
0282:  GOTO   281
0283:  GOTO   284
0284:  NOP
0285:  BTFSC  21.7
0286:  GOTO   26A
0287:  BTFSC  21.6
0288:  GOTO   272
0289:  RETLW  00
.................... #include <mcp4921.c> 
.................... //////////////// Driver for MCP4921 D/A Converter /////////////////////// 
.................... ////                                                                 //// 
.................... ////  init_dac()    Call this before using a MCP4921 DAC             //// 
.................... ////                                                                 //// 
.................... ////  write_dac( long int )   Writes command and 12 bit resolution   //// 
.................... ////                          to the MCP4921 which converts it to a  //// 
.................... ////                          voltage                                //// 
.................... ////                          0-4095 input represents 0-vref V out.  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SELECT 
....................  
.................... #define DAC_CS     PIN_C4 
.................... #define DAC_CLK    PIN_C3 
.................... #define DAC_DI     PIN_C5 
.................... #define DAC_LDAC   PIN_B4 
....................  
.................... #endif 
....................  
.................... void init_dac() 
.................... { 
....................    output_high(DAC_CS); 
*
<<<<<<< HEAD
00E9:  BCF    2E.4
00EA:  MOVF   2E,W
00EB:  BSF    03.5
00EC:  MOVWF  07
00ED:  BCF    03.5
00EE:  BSF    07.4
....................    output_high(DAC_LDAC); 
00EF:  BSF    03.5
00F0:  BCF    06.5
00F1:  BCF    03.5
00F2:  BSF    06.5
....................    output_high(DAC_CLK); 
00F3:  BCF    2E.3
00F4:  MOVF   2E,W
00F5:  BSF    03.5
00F6:  MOVWF  07
00F7:  BCF    03.5
00F8:  BSF    07.3
....................    output_high(DAC_DI); 
00F9:  BCF    2E.5
00FA:  MOVF   2E,W
00FB:  BSF    03.5
00FC:  MOVWF  07
00FD:  BCF    03.5
00FE:  BSF    07.5
.................... } 
00FF:  BCF    0A.3
0100:  GOTO   49E (RETURN)
=======
00BF:  BCF    2E.4
00C0:  MOVF   2E,W
00C1:  BSF    03.5
00C2:  MOVWF  07
00C3:  BCF    03.5
00C4:  BSF    07.4
....................    output_high(DAC_LDAC); 
00C5:  BSF    03.5
00C6:  BCF    06.4
00C7:  BCF    03.5
00C8:  BSF    06.4
....................    output_high(DAC_CLK); 
00C9:  BCF    2E.3
00CA:  MOVF   2E,W
00CB:  BSF    03.5
00CC:  MOVWF  07
00CD:  BCF    03.5
00CE:  BSF    07.3
....................    output_high(DAC_DI); 
00CF:  BCF    2E.5
00D0:  MOVF   2E,W
00D1:  BSF    03.5
00D2:  MOVWF  07
00D3:  BCF    03.5
00D4:  BSF    07.5
.................... } 
00D5:  BCF    0A.3
00D6:  GOTO   6F5 (RETURN)
>>>>>>> c3b8e56ca4afb031060d4e36e288e08742690935
....................  
.................... void write_dac(int16 data) { 
....................    BYTE cmd[3]; 
....................    BYTE i; 
....................  
....................    cmd[0]=data; 
<<<<<<< HEAD
0101:  MOVF   58,W
0102:  MOVWF  5A
....................    cmd[1]=(data>>8); 
0103:  MOVF   59,W
0104:  MOVWF  5B
....................    cmd[2]=0x03;                            
0105:  MOVLW  03
0106:  MOVWF  5C
....................     
....................    output_high(DAC_LDAC); 
0107:  BSF    03.5
0108:  BCF    06.5
0109:  BCF    03.5
010A:  BSF    06.5
....................    output_low(DAC_CLK); 
010B:  BCF    2E.3
010C:  MOVF   2E,W
010D:  BSF    03.5
010E:  MOVWF  07
010F:  BCF    03.5
0110:  BCF    07.3
....................    output_low(DAC_CS); 
0111:  BCF    2E.4
0112:  MOVF   2E,W
0113:  BSF    03.5
0114:  MOVWF  07
0115:  BCF    03.5
0116:  BCF    07.4
....................  
....................    for(i=0; i<=23; ++i) 
0117:  CLRF   5D
0118:  MOVF   5D,W
0119:  SUBLW  17
011A:  BTFSS  03.0
011B:  GOTO   149
....................    { 
....................       if(i<4 || (i>7 && i<12)) 
011C:  MOVF   5D,W
011D:  SUBLW  03
011E:  BTFSC  03.0
011F:  GOTO   128
0120:  MOVF   5D,W
0121:  SUBLW  07
0122:  BTFSC  03.0
0123:  GOTO   12D
0124:  MOVF   5D,W
0125:  SUBLW  0B
0126:  BTFSS  03.0
0127:  GOTO   12D
....................          shift_left(cmd,3,0); 
0128:  BCF    03.0
0129:  RLF    5A,F
012A:  RLF    5B,F
012B:  RLF    5C,F
....................       else 
012C:  GOTO   147
....................       { 
....................          output_bit(DAC_DI, shift_left(cmd,3,0)); 
012D:  BCF    03.0
012E:  RLF    5A,F
012F:  RLF    5B,F
0130:  RLF    5C,F
0131:  BTFSC  03.0
0132:  GOTO   135
0133:  BCF    07.5
0134:  GOTO   136
0135:  BSF    07.5
0136:  BCF    2E.5
0137:  MOVF   2E,W
0138:  BSF    03.5
0139:  MOVWF  07
....................  
....................          output_high(DAC_CLK); 
013A:  BCF    03.5
013B:  BCF    2E.3
013C:  MOVF   2E,W
013D:  BSF    03.5
013E:  MOVWF  07
013F:  BCF    03.5
0140:  BSF    07.3
....................          output_low(DAC_CLK); 
0141:  BCF    2E.3
0142:  MOVF   2E,W
0143:  BSF    03.5
0144:  MOVWF  07
0145:  BCF    03.5
0146:  BCF    07.3
....................       } 
....................    } 
0147:  INCF   5D,F
0148:  GOTO   118
....................    output_high(DAC_CS); 
0149:  BCF    2E.4
014A:  MOVF   2E,W
014B:  BSF    03.5
014C:  MOVWF  07
014D:  BCF    03.5
014E:  BSF    07.4
....................  
....................    output_low(DAC_LDAC); 
014F:  BSF    03.5
0150:  BCF    06.5
0151:  BCF    03.5
0152:  BCF    06.5
....................    delay_us(10); 
0153:  MOVLW  10
0154:  MOVWF  20
0155:  DECFSZ 20,F
0156:  GOTO   155
0157:  NOP
....................     
....................    output_HIGH(DAC_LDAC); 
0158:  BSF    03.5
0159:  BCF    06.5
015A:  BCF    03.5
015B:  BSF    06.5
.................... } 
015C:  RETLW  00
=======
00D7:  MOVF   5E,W
00D8:  MOVWF  60
....................    cmd[1]=(data>>8); 
00D9:  MOVF   5F,W
00DA:  MOVWF  61
....................    cmd[2]=0x03;                            
00DB:  MOVLW  03
00DC:  MOVWF  62
....................     
....................    output_high(DAC_LDAC); 
00DD:  BSF    03.5
00DE:  BCF    06.4
00DF:  BCF    03.5
00E0:  BSF    06.4
....................    output_low(DAC_CLK); 
00E1:  BCF    2E.3
00E2:  MOVF   2E,W
00E3:  BSF    03.5
00E4:  MOVWF  07
00E5:  BCF    03.5
00E6:  BCF    07.3
....................    output_low(DAC_CS); 
00E7:  BCF    2E.4
00E8:  MOVF   2E,W
00E9:  BSF    03.5
00EA:  MOVWF  07
00EB:  BCF    03.5
00EC:  BCF    07.4
....................  
....................    for(i=0; i<=23; ++i) 
00ED:  CLRF   63
00EE:  MOVF   63,W
00EF:  SUBLW  17
00F0:  BTFSS  03.0
00F1:  GOTO   11F
....................    { 
....................       if(i<4 || (i>7 && i<12)) 
00F2:  MOVF   63,W
00F3:  SUBLW  03
00F4:  BTFSC  03.0
00F5:  GOTO   0FE
00F6:  MOVF   63,W
00F7:  SUBLW  07
00F8:  BTFSC  03.0
00F9:  GOTO   103
00FA:  MOVF   63,W
00FB:  SUBLW  0B
00FC:  BTFSS  03.0
00FD:  GOTO   103
....................          shift_left(cmd,3,0); 
00FE:  BCF    03.0
00FF:  RLF    60,F
0100:  RLF    61,F
0101:  RLF    62,F
....................       else 
0102:  GOTO   11D
....................       { 
....................          output_bit(DAC_DI, shift_left(cmd,3,0)); 
0103:  BCF    03.0
0104:  RLF    60,F
0105:  RLF    61,F
0106:  RLF    62,F
0107:  BTFSC  03.0
0108:  GOTO   10B
0109:  BCF    07.5
010A:  GOTO   10C
010B:  BSF    07.5
010C:  BCF    2E.5
010D:  MOVF   2E,W
010E:  BSF    03.5
010F:  MOVWF  07
....................  
....................          output_high(DAC_CLK); 
0110:  BCF    03.5
0111:  BCF    2E.3
0112:  MOVF   2E,W
0113:  BSF    03.5
0114:  MOVWF  07
0115:  BCF    03.5
0116:  BSF    07.3
....................          output_low(DAC_CLK); 
0117:  BCF    2E.3
0118:  MOVF   2E,W
0119:  BSF    03.5
011A:  MOVWF  07
011B:  BCF    03.5
011C:  BCF    07.3
....................       } 
....................    } 
011D:  INCF   63,F
011E:  GOTO   0EE
....................    output_high(DAC_CS); 
011F:  BCF    2E.4
0120:  MOVF   2E,W
0121:  BSF    03.5
0122:  MOVWF  07
0123:  BCF    03.5
0124:  BSF    07.4
....................  
....................    output_low(DAC_LDAC); 
0125:  BSF    03.5
0126:  BCF    06.4
0127:  BCF    03.5
0128:  BCF    06.4
....................    delay_us(10); 
0129:  MOVLW  10
012A:  MOVWF  20
012B:  DECFSZ 20,F
012C:  GOTO   12B
012D:  NOP
....................     
....................    output_HIGH(DAC_LDAC); 
012E:  BSF    03.5
012F:  BCF    06.4
0130:  BCF    03.5
0131:  BSF    06.4
.................... } 
0132:  RETLW  00
>>>>>>> c3b8e56ca4afb031060d4e36e288e08742690935
....................  
....................  
....................  
.................... #include "pid.h" 
.................... /*This file has been prepared for Doxygen automatic documentation generation.*/ 
.................... /*! \file ********************************************************************* 
....................  * 
....................  * \brief Header file for pid.c. 
....................  * 
....................  * - File:               pid.h 
....................  * - Compiler:           IAR EWAAVR 4.11A 
....................  * - Supported devices:  All AVR devices can be used. 
....................  * - AppNote:            AVR221 - Discrete PID controller 
....................  * 
....................  * \author               Atmel Corporation: http://www.atmel.com \n 
....................  *                       Support email: avr@atmel.com 
....................  * 
....................  * $Name$ 
....................  * $Revision: 456 $ 
....................  * $RCSfile$ 
....................  * $Date: 2006-02-16 12:46:13 +0100 (to, 16 feb 2006) $ 
....................  *****************************************************************************/ 
....................  
.................... #ifndef PID_H 
.................... #define PID_H 
....................  
.................... //#include "stdint.h" 
.................... #define INT16_MAX 32767 
.................... #define INT32_MAX 2147483647 
.................... #define SCALING_FACTOR  128 
....................  
.................... /*! \brief PID Status 
....................  * 
....................  * Setpoints and data used by the PID control algorithm 
....................  */ 
.................... typedef struct PID_DATA{ 
....................   //! Last process value, used to find derivative of process value. 
....................   int16 lastProcessValue; 
....................   //! Summation of errors, used for integrate calculations 
....................   int32 sumError; 
....................   //! The Proportional tuning constant, multiplied with SCALING_FACTOR 
....................   int16 P_Factor; 
....................   //! The Integral tuning constant, multiplied with SCALING_FACTOR 
....................   int16 I_Factor; 
....................   //! The Derivative tuning constant, multiplied with SCALING_FACTOR 
....................   int16 D_Factor; 
....................   //! Maximum allowed error, avoid overflow 
....................   int16 maxError; 
....................   //! Maximum allowed sumerror, avoid overflow 
....................   int32 maxSumError; 
.................... } pidData_t; 
....................  
.................... /*! \brief Maximum values 
....................  * 
....................  * Needed to avoid sign/overflow problems 
....................  */ 
.................... // Maximum value of variables 
.................... #define MAX_INT         INT16_MAX 
.................... #define MAX_LONG        INT32_MAX 
.................... #define MAX_I_TERM      (MAX_LONG / 2) 
....................  
.................... // Boolean values 
.................... //#define FALSE           0 
.................... //#define TRUE            1 
....................  
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid); 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st); 
.................... void pid_Reset_Integrator(pidData_t *pid_st); 
....................  
.................... #endif 
....................  
.................... /* 
.................... This is the main controller for the super capacitor hybrid scooter a.k.a RED 
.................... B2 close contactor 
.................... CONTROL BOX INPUTS 
.................... Athrottle- A0 - analog input representing the users input for speed, 10 bit 
.................... Vspeed - CCp2-a 16 bit representation of the speed of the vehicle 
.................... Acaps- A1 - analog input representing the current voltage of the supercapacitors, 10 bit 
....................  
.................... CONTROL BOX OUTPUT 
.................... ICEthrottle- B1 - a 16 bit number sent to the internal combustion engine(ICE) throttle  
.................... ELECthrottle-  - a 16 bit number sent as analog value representing the demanded electric power 
....................  
.................... SPECIFICS OF I/O 
....................  
.................... Athrottle - the electric throttle is a 3 wire unit with a 5 volt,ground, and analog out 
....................    representing how far throttle is turned. Pin AN0 is the input. 
....................     
.................... Vspeed - There is a encoder in the rear wheel/electric motor that is used by the electric 
....................    power controller. Tapping in to this this Main Controller receives a 5 Volt square wave 
....................    with 42 pulses. There are two options for measuring speed. The first is to measure the  
....................    length of the pulses. The second is to measure the rate of pulses. This controller currently 
....................    uses the rate method. The int_ccp2 interupt is called on each falling edge and stores the  
....................    Vspeed value as the max number of 16bit (65535-timer0_since_last_reset).  
....................     
....................    The RED scooter has a circumpherence of 16.3*2*pi = 102.4 
....................    X m/h * 63360 inch/mile * 1/3600 h/sec * 1/(102.4 inch/rev) = .171875* X 
....................    Examples 50 mph is 8.9 ms 1 overflow of timer0 
....................    Example 5 mph is 89 ms or 13 time overflow 
....................     
....................    #int_timer0 increments the counter number_of_overflows each time it overflows 
....................    On int ccp2 we multiply number_of_overflows * 256 + timer0 to get timer0_since_last_reset 
....................     
.................... Acaps - the analog voltage which is the 5volt representation of the voltage in the caps which 
....................    have a value of between 0-48v. The voltages are factored so that the voltage on AN1 goes 
....................    from 0 - 4.8 volts (TODO check this factor, think its 1/11 not 1/10) 
....................     
.................... ICEthrottle -  #int_timer1 is set to make sure the period follows the required below 
....................    The period for the servo is .020 seconds which is 50,000 operations 
....................    The leftmost position of the server is .001 seconds which is 2,500 
....................    The rightmost position of the server is .002 seconds which is 5,000 
....................     
....................    The output pin is pin_B1.-> 
....................  
.................... ELECthrottle 
....................    The electric power controller takes an analog voltage as input. The output voltage 
....................    is set by the DAC. The pins used are C3,C4,C5. if CHARGING_STATE is true then  
....................     
.................... ALGORITHM 
....................    The algorithm is basically a PID controller. In broad terms we are trying to set the 
....................    ICEthrottle and ICEelectric to maximize the use of electric and accelerate to meet the 
....................    requirements set by the rider with the Athrottle signal. When the demanded power is  
....................    less than the power output possible by the ICE and the caps are in the CHARGING_STATE  
....................    then the ICE is turned up to the max and the ELECthrottle is set to regen to 
....................    charge the capacitors.If CHARGING_STATE is false then the caps are supplying the drivig power 
....................    and the ICE is set to "off", the caps supply the power. Unless the user requested supply 
....................    is enough to require both power sources. 
....................     
....................    If CHARGING_STATE is true. Then pin_b2 is set as high which will close the brake number 
....................    for the electric power controller.  
....................     
....................    If CHARGING_STATE is false then the pin_b2 is set low which opens brake. 
....................     
....................     
....................  
....................  
.................... The encoder has 42 on and offs per rotation, i.e. 21 steps 
....................  
.................... Number of operations per second is CLOCK/4/Timer Divisions 
.................... Number of operations per second is 20,000,000/4/128 = 39062.5  
.................... Each operation takes 1/39062.5 = .256 micro (x10^-6) seconds 
.................... Seconds to Overflow timer0 8bit timer = .256x10^-6 * 256 = 6.55ms 
....................  
....................  
....................  
.................... */ 
.................... #define servo_pin PIN_B1  //Setting servo out pin to be hardware pin b1 
.................... #define brake_pin PIN_B4 
.................... #define ADC_DELAY delay_us(20) 
.................... #define Acaps_pin PIN_A1 
.................... #define Acaps_channel 1 
.................... #define Athrottle_pin PIN_A0  //Voltage goes from 1.5 (306)to 4.1(836) 
.................... #define Athrottle_Min 306 
.................... #define Athrottle_Max 860 
.................... #define Athrottle_Full Athrottle_Max-Athrottle_Min 
.................... #define Athrottle_channel 0 
.................... #define Electric_Controller_Switch PIN_B0 
.................... #define Contactor_Switch PIN_B2 
....................  
.................... //PID Values 
.................... #define K_P 1.00 
.................... #define K_I 0.00 
.................... #define K_D 0.00 
....................  
.................... int1 pid_Timer = 0; 
*
<<<<<<< HEAD
045C:  BCF    2F.0
=======
06B7:  BCF    2F.0
>>>>>>> c3b8e56ca4afb031060d4e36e288e08742690935
.................... struct PID_DATA pidData; 
.................... #define TIME_INTERVAL 157 //TODO replace 
....................  
.................... #define left_position 3950 
.................... #define right_position 4800 
.................... #define servo_difference  right_position-left_position 
.................... const float Athrottle_servo_factor = ((float) servo_difference)/((float) Athrottle_FULL); 
.................... #define servo_period   65356-50000 
.................... unsigned int16 current_servo_position=right_position; 
<<<<<<< HEAD
045D:  MOVLW  C0
045E:  MOVWF  42
045F:  MOVLW  12
0460:  MOVWF  43
.................... int1 SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0; 
0461:  BCF    2F.1
.................... int1 test_boolean = 0; 
0462:  BCF    2F.2
....................  
.................... int1 test_switch = 0; 
0463:  BCF    2F.3
.................... unsigned int16 test_counter = 0; 
0464:  CLRF   44
0465:  CLRF   45
....................  
.................... unsigned int16 number_of_timer0_interupts_since_reset =0; 
0466:  CLRF   46
0467:  CLRF   47
.................... unsigned int16 timer0_since_last_reset= 0; 
0468:  CLRF   48
0469:  CLRF   49
.................... unsigned int16 vSpeed= 0; 
046A:  CLRF   4A
046B:  CLRF   4B
.................... unsigned int16 ELECthrottle = 900; 
046C:  MOVLW  84
046D:  MOVWF  4C
046E:  MOVLW  03
046F:  MOVWF  4D
.................... unsigned int16 ICEthrottle = 0; 
0470:  CLRF   4E
0471:  CLRF   4F
.................... unsigned int16 Athrottle = 0; 
0472:  CLRF   50
0473:  CLRF   51
.................... unsigned int16 Acaps = 0; 
0474:  CLRF   52
0475:  CLRF   53
.................... int1 CURRENTLY_CHARGING = 0; 
0476:  BCF    2F.4
.................... signed int16 returnedValue =0; 
0477:  CLRF   54
0478:  CLRF   55
.................... int16 speeder = 0;  
0479:  CLRF   56
047A:  CLRF   57
=======
06B8:  MOVLW  C0
06B9:  MOVWF  42
06BA:  MOVLW  12
06BB:  MOVWF  43
.................... int1 SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0; 
06BC:  BCF    2F.1
.................... int1 test_boolean = 0; 
06BD:  BCF    2F.2
....................  
.................... int1 test_switch = 0; 
06BE:  BCF    2F.3
.................... unsigned int16 test_counter = 0; 
06BF:  CLRF   44
06C0:  CLRF   45
.................... int16 returnedValue = 0; 
06C1:  CLRF   46
06C2:  CLRF   47
....................  
.................... unsigned int16 number_of_timer0_interupts_since_reset =0; 
06C3:  CLRF   48
06C4:  CLRF   49
.................... unsigned int16 timer0_since_last_reset= 0; 
06C5:  CLRF   4A
06C6:  CLRF   4B
.................... unsigned int16 vSpeed= 0; 
06C7:  CLRF   4C
06C8:  CLRF   4D
.................... unsigned int16 ELECthrottle = 0; 
06C9:  CLRF   4E
06CA:  CLRF   4F
.................... unsigned int16 ICEthrottle = 0; 
06CB:  CLRF   50
06CC:  CLRF   51
.................... unsigned int16 Athrottle = 0; 
06CD:  CLRF   52
06CE:  CLRF   53
.................... unsigned int16 Acaps = 0; 
06CF:  CLRF   54
06D0:  CLRF   55
.................... int1 CURRENTLY_CHARGING = 0; 
06D1:  BCF    2F.4
....................  
>>>>>>> c3b8e56ca4afb031060d4e36e288e08742690935
.................... /* 
.................... The #int_timer0 interupt is triggered on each timer0 8bit interupt 
.................... the function simply increments a overflow counter to be used by the ccp2 
.................... interupt to calculate speed 
.................... NUMBER OF OPERATIONS =  
.................... */ 
.................... #int_timer0 
.................... void timer0_isr(){ 
....................     
....................       number_of_timer0_interupts_since_reset=number_of_timer0_interupts_since_reset+256; 
*
<<<<<<< HEAD
006E:  MOVLW  01
006F:  ADDWF  47,F
=======
0045:  MOVLW  01
0046:  ADDWF  49,F
>>>>>>> c3b8e56ca4afb031060d4e36e288e08742690935
....................       //current_servo_position=current_servo_position+1; 
....................        
....................     
....................    if (number_of_timer0_interupts_since_reset>=1024){ 
<<<<<<< HEAD
0070:  MOVF   47,W
0071:  SUBLW  03
0072:  BTFSC  03.0
0073:  GOTO   07A
....................       vSpeed = 1280; 
0074:  MOVLW  05
0075:  MOVWF  4B
0076:  CLRF   4A
....................       number_of_timer0_interupts_since_reset=1024; 
0077:  MOVLW  04
0078:  MOVWF  47
0079:  CLRF   46
=======
0047:  MOVF   49,W
0048:  SUBLW  03
0049:  BTFSC  03.0
004A:  GOTO   050
....................       vSpeed = 1024; 
004B:  MOVLW  04
004C:  MOVWF  4D
004D:  CLRF   4C
....................       number_of_timer0_interupts_since_reset=1024; 
004E:  MOVWF  49
004F:  CLRF   48
>>>>>>> c3b8e56ca4afb031060d4e36e288e08742690935
....................        
....................        
....................    } 
.................... } 
....................  
.................... /* 
.................... #int_timer1 is used by the ICEservo throttle to regulate the timing pulses. The  
.................... timer is setup for a pulsetrain of 20ms period. This is done as follows, 
....................  
.................... Period is 1/(CLOCK/4opsperclock)*(startingPostionOfClock) = 20 ms 
.................... for this setup 1/(20000000/4)*(50000) = 20 ms 
....................  
.................... The timer1 starts at 0 and counts up. So we set the beggining of the clock at 
.................... servo_period which is 65356-50000 so that the total time is 20ms. 
.................... */ 
007A:  BCF    0B.2
007B:  BCF    0A.3
007C:  GOTO   02C
.................... #int_timer1 
.................... void isr() 
.................... { 
....................  
.................... //Make sure that the position is within the left and right positions of the servo 
....................    if (current_servo_position<left_position){ 
007D:  MOVF   43,W
007E:  SUBLW  0F
007F:  BTFSS  03.0
0080:  GOTO   08C
0081:  BTFSS  03.2
0082:  GOTO   087
0083:  MOVF   42,W
0084:  SUBLW  6D
0085:  BTFSS  03.0
0086:  GOTO   08C
....................       current_servo_position = left_position; 
0087:  MOVLW  0F
0088:  MOVWF  43
0089:  MOVLW  6E
008A:  MOVWF  42
....................    } 
....................    else if (current_servo_position > right_position){ 
008B:  GOTO   09B
008C:  MOVF   43,W
008D:  SUBLW  11
008E:  BTFSC  03.0
008F:  GOTO   09B
0090:  XORLW  FF
0091:  BTFSS  03.2
0092:  GOTO   097
0093:  MOVF   42,W
0094:  SUBLW  C0
0095:  BTFSC  03.0
0096:  GOTO   09B
....................       current_servo_position = right_position; 
0097:  MOVLW  12
0098:  MOVWF  43
0099:  MOVLW  C0
009A:  MOVWF  42
....................    } 
....................  
....................    if(SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER) 
<<<<<<< HEAD
009B:  BTFSS  2F.1
009C:  GOTO   0BA
=======
0071:  BTFSS  2F.1
0072:  GOTO   090
>>>>>>> c3b8e56ca4afb031060d4e36e288e08742690935
....................       {  
....................          output_high(servo_pin);        //Set the servo control pin to high  
009D:  BSF    03.5
009E:  BCF    06.1
009F:  BCF    03.5
00A0:  BSF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0;  
00A1:  BCF    2F.1
....................          set_timer1(65356-current_servo_position); //Set timer for the position high pulse 
<<<<<<< HEAD
00A2:  MOVF   42,W
00A3:  SUBLW  4C
00A4:  BSF    03.5
00A5:  MOVWF  20
00A6:  MOVLW  FF
00A7:  MOVWF  21
00A8:  BCF    03.5
00A9:  MOVF   43,W
00AA:  BTFSS  03.0
00AB:  INCFSZ 43,W
00AC:  GOTO   0AE
00AD:  GOTO   0B1
00AE:  BSF    03.5
00AF:  SUBWF  21,F
00B0:  BCF    03.5
00B1:  BSF    03.5
00B2:  MOVF   21,W
00B3:  BCF    03.5
00B4:  MOVWF  0F
00B5:  BSF    03.5
00B6:  MOVF   20,W
00B7:  BCF    03.5
00B8:  MOVWF  0E
....................       }  
....................    else  
00B9:  GOTO   0D2
....................       {  
....................          output_low(servo_pin);                      // Set the servo control pin to low   
00BA:  BSF    03.5
00BB:  BCF    06.1
00BC:  BCF    03.5
00BD:  BCF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 1;  
00BE:  BSF    2F.1
....................          set_timer1(servo_period+current_servo_position);          //Set timer for the low position the length is the difference between  
00BF:  MOVLW  FC
00C0:  ADDWF  42,W
00C1:  BSF    03.5
00C2:  MOVWF  20
00C3:  BCF    03.5
00C4:  MOVF   43,W
00C5:  BSF    03.5
00C6:  MOVWF  21
00C7:  MOVLW  3B
00C8:  BTFSC  03.0
00C9:  MOVLW  3C
00CA:  ADDWF  21,F
00CB:  MOVF   21,W
00CC:  BCF    03.5
00CD:  MOVWF  0F
00CE:  BSF    03.5
00CF:  MOVF   20,W
00D0:  BCF    03.5
00D1:  MOVWF  0E
=======
0078:  MOVF   42,W
0079:  SUBLW  4C
007A:  BSF    03.5
007B:  MOVWF  25
007C:  MOVLW  FF
007D:  MOVWF  26
007E:  BCF    03.5
007F:  MOVF   43,W
0080:  BTFSS  03.0
0081:  INCFSZ 43,W
0082:  GOTO   084
0083:  GOTO   087
0084:  BSF    03.5
0085:  SUBWF  26,F
0086:  BCF    03.5
0087:  BSF    03.5
0088:  MOVF   26,W
0089:  BCF    03.5
008A:  MOVWF  0F
008B:  BSF    03.5
008C:  MOVF   25,W
008D:  BCF    03.5
008E:  MOVWF  0E
....................       }  
....................    else  
008F:  GOTO   0A8
....................       {  
....................          output_low(servo_pin);                      // Set the servo control pin to low   
0090:  BSF    03.5
0091:  BCF    06.1
0092:  BCF    03.5
0093:  BCF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 1;  
0094:  BSF    2F.1
....................          set_timer1(servo_period+current_servo_position);          //Set timer for the low position the length is the difference between  
0095:  MOVLW  FC
0096:  ADDWF  42,W
0097:  BSF    03.5
0098:  MOVWF  25
0099:  BCF    03.5
009A:  MOVF   43,W
009B:  BSF    03.5
009C:  MOVWF  26
009D:  MOVLW  3B
009E:  BTFSC  03.0
009F:  MOVLW  3C
00A0:  ADDWF  26,F
00A1:  MOVF   26,W
00A2:  BCF    03.5
00A3:  MOVWF  0F
00A4:  BSF    03.5
00A5:  MOVF   25,W
00A6:  BCF    03.5
00A7:  MOVWF  0E
>>>>>>> c3b8e56ca4afb031060d4e36e288e08742690935
....................                                                      //the total int16 lenght - high pulse length 
....................       }   
.................... } 
....................  
....................  
.................... /* 
.................... #int_ccp2 is called on the falling edge of the encoder pulse. We calculate the time 
.................... between pulses.  
.................... TODO will have to put some kind of smoothing mechanism 
.................... */ 
<<<<<<< HEAD
00D2:  BCF    0C.0
00D3:  BCF    0A.3
00D4:  GOTO   02C
=======
00A8:  BCF    0C.0
00A9:  BCF    0A.3
00AA:  GOTO   02C
>>>>>>> c3b8e56ca4afb031060d4e36e288e08742690935
.................... #int_ccp2 
.................... void isr2() 
.................... { 
.................... if (number_of_timer0_interupts_since_reset>10){ 
<<<<<<< HEAD
00D5:  MOVF   47,F
00D6:  BTFSS  03.2
00D7:  GOTO   0DC
00D8:  MOVF   46,W
00D9:  SUBLW  0A
00DA:  BTFSC  03.0
00DB:  GOTO   0E6
.................... vSpeed  = (number_of_timer0_interupts_since_reset+get_timer0()); 
00DC:  MOVF   01,W
00DD:  ADDWF  46,W
00DE:  MOVWF  4A
00DF:  MOVF   47,W
00E0:  MOVWF  4B
00E1:  BTFSC  03.0
00E2:  INCF   4B,F
.................... //vSpeed  = -(get_timer0()); 
.................... set_timer0(0); 
00E3:  CLRF   01
.................... number_of_timer0_interupts_since_reset = 0; 
00E4:  CLRF   47
00E5:  CLRF   46
=======
00AB:  MOVF   49,F
00AC:  BTFSS  03.2
00AD:  GOTO   0B2
00AE:  MOVF   48,W
00AF:  SUBLW  0A
00B0:  BTFSC  03.0
00B1:  GOTO   0BC
.................... vSpeed  = (number_of_timer0_interupts_since_reset+get_timer0()); 
00B2:  MOVF   01,W
00B3:  ADDWF  48,W
00B4:  MOVWF  4C
00B5:  MOVF   49,W
00B6:  MOVWF  4D
00B7:  BTFSC  03.0
00B8:  INCF   4D,F
.................... //vSpeed  = -(get_timer0()); 
.................... set_timer0(0); 
00B9:  CLRF   01
.................... number_of_timer0_interupts_since_reset = 0; 
00BA:  CLRF   49
00BB:  CLRF   48
>>>>>>> c3b8e56ca4afb031060d4e36e288e08742690935
.................... } 
.................... } 
....................  
....................  
....................  
....................  
<<<<<<< HEAD
00E6:  BCF    0D.0
00E7:  BCF    0A.3
00E8:  GOTO   02C
.................... void main() 
.................... {   
*
044B:  CLRF   04
044C:  MOVLW  1F
044D:  ANDWF  03,F
044E:  BSF    03.5
044F:  BCF    06.3
0450:  BCF    03.5
0451:  BSF    06.3
0452:  BSF    03.5
0453:  BSF    1F.0
0454:  BSF    1F.1
0455:  BSF    1F.2
0456:  BCF    1F.3
0457:  MOVLW  07
0458:  MOVWF  1C
....................     
....................    setup_adc_ports(NO_ANALOGS); 
*
047B:  BSF    03.5
047C:  BSF    1F.0
047D:  BSF    1F.1
047E:  BSF    1F.2
047F:  BCF    1F.3
....................    setup_adc(ADC_OFF); 
0480:  BCF    03.5
0481:  BCF    1F.0
....................    setup_spi(FALSE); 
0482:  CLRF   14
....................     
....................    setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
0483:  BSF    03.5
0484:  MOVF   01,W
0485:  ANDLW  C0
0486:  IORLW  00
0487:  MOVWF  01
0488:  CLRWDT
....................    setup_timer_1(T1_DISABLED); 
0489:  BCF    03.5
048A:  CLRF   10
....................    setup_timer_2(T2_DISABLED,0,1); 
048B:  MOVLW  00
048C:  MOVWF  21
048D:  MOVWF  12
048E:  MOVLW  00
048F:  BSF    03.5
0490:  MOVWF  12
....................    setup_port_a(ALL_ANALOG); 
0491:  BCF    1F.0
0492:  BCF    1F.1
0493:  BCF    1F.2
0494:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
0495:  BCF    1F.6
0496:  BCF    03.5
0497:  BSF    1F.6
0498:  BSF    1F.7
0499:  BSF    03.5
049A:  BSF    1F.7
049B:  BCF    03.5
049C:  BSF    1F.0
....................     
....................    init_dac(); 
049D:  GOTO   0E9
....................   
....................    setup_timer_1(T1_DIV_BY_2| T1_INTERNAL);  
049E:  MOVLW  95
049F:  MOVWF  10
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_128); 
04A0:  BSF    03.5
04A1:  MOVF   01,W
04A2:  ANDLW  C0
04A3:  IORLW  06
04A4:  MOVWF  01
....................    setup_ccp2(CCP_CAPTURE_RE);    // Configure CCP2 to capture fall 
04A5:  BCF    03.5
04A6:  BSF    2E.1
04A7:  MOVF   2E,W
04A8:  BSF    03.5
04A9:  MOVWF  07
04AA:  BCF    03.5
04AB:  CLRF   1D
04AC:  MOVLW  05
04AD:  MOVWF  1D
....................    enable_interrupts(INT_CCP2);   // Setup interrupt on falling edge 
04AE:  BSF    03.5
04AF:  BSF    0D.0
....................    enable_interrupts(INT_TIMER0); 
04B0:  BCF    03.5
04B1:  BSF    0B.5
....................    enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
04B2:  BSF    03.5
04B3:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
04B4:  MOVLW  C0
04B5:  BCF    03.5
04B6:  IORWF  0B,F
....................    output_low(Electric_Controller_Switch); 
04B7:  BSF    03.5
04B8:  BCF    06.0
04B9:  BCF    03.5
04BA:  BCF    06.0
....................    write_dac(0); 
04BB:  CLRF   59
04BC:  CLRF   58
04BD:  CALL   101
....................    output_high(Contactor_Switch); 
04BE:  BSF    03.5
04BF:  BCF    06.2
04C0:  BCF    03.5
04C1:  BSF    06.2
....................    output_low(brake_pin); 
04C2:  BSF    03.5
04C3:  BCF    06.4
04C4:  BCF    03.5
04C5:  BCF    06.4
....................    pid_Init(K_P * SCALING_FACTOR,K_I*SCALING_FACTOR,K_D*SCALING_FACTOR, & pidData); 
04C6:  CLRF   59
04C7:  MOVLW  80
04C8:  MOVWF  58
04C9:  CLRF   5B
04CA:  CLRF   5A
04CB:  CLRF   5D
04CC:  CLRF   5C
04CD:  MOVLW  30
04CE:  MOVWF  5E
04CF:  GOTO   15D
....................     
....................    delay_ms(3000); 
04D0:  MOVLW  0C
04D1:  MOVWF  58
04D2:  MOVLW  FA
04D3:  MOVWF  59
04D4:  GOTO   24C
04D5:  DECFSZ 58,F
04D6:  GOTO   4D2
=======
00BC:  BCF    0D.0
00BD:  BCF    0A.3
00BE:  GOTO   02C
.................... void main() 
.................... {   
*
06A6:  CLRF   04
06A7:  MOVLW  1F
06A8:  ANDWF  03,F
06A9:  BSF    03.5
06AA:  BCF    06.3
06AB:  BCF    03.5
06AC:  BSF    06.3
06AD:  BSF    03.5
06AE:  BSF    1F.0
06AF:  BSF    1F.1
06B0:  BSF    1F.2
06B1:  BCF    1F.3
06B2:  MOVLW  07
06B3:  MOVWF  1C
....................     
....................    setup_adc_ports(NO_ANALOGS); 
*
06D2:  BSF    03.5
06D3:  BSF    1F.0
06D4:  BSF    1F.1
06D5:  BSF    1F.2
06D6:  BCF    1F.3
....................    setup_adc(ADC_OFF); 
06D7:  BCF    03.5
06D8:  BCF    1F.0
....................    setup_spi(FALSE); 
06D9:  CLRF   14
....................     
....................    setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
06DA:  BSF    03.5
06DB:  MOVF   01,W
06DC:  ANDLW  C0
06DD:  IORLW  00
06DE:  MOVWF  01
06DF:  CLRWDT
....................    setup_timer_1(T1_DISABLED); 
06E0:  BCF    03.5
06E1:  CLRF   10
....................    setup_timer_2(T2_DISABLED,0,1); 
06E2:  MOVLW  00
06E3:  MOVWF  21
06E4:  MOVWF  12
06E5:  MOVLW  00
06E6:  BSF    03.5
06E7:  MOVWF  12
....................    setup_port_a(ALL_ANALOG); 
06E8:  BCF    1F.0
06E9:  BCF    1F.1
06EA:  BCF    1F.2
06EB:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
06EC:  BCF    1F.6
06ED:  BCF    03.5
06EE:  BSF    1F.6
06EF:  BSF    1F.7
06F0:  BSF    03.5
06F1:  BSF    1F.7
06F2:  BCF    03.5
06F3:  BSF    1F.0
....................     
....................    init_dac(); 
06F4:  GOTO   0BF
....................   
....................    setup_timer_1(T1_DIV_BY_2| T1_INTERNAL);  
06F5:  MOVLW  95
06F6:  MOVWF  10
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_128); 
06F7:  BSF    03.5
06F8:  MOVF   01,W
06F9:  ANDLW  C0
06FA:  IORLW  06
06FB:  MOVWF  01
....................    setup_ccp2(CCP_CAPTURE_RE);    // Configure CCP2 to capture fall 
06FC:  BCF    03.5
06FD:  BSF    2E.1
06FE:  MOVF   2E,W
06FF:  BSF    03.5
0700:  MOVWF  07
0701:  BCF    03.5
0702:  CLRF   1D
0703:  MOVLW  05
0704:  MOVWF  1D
....................    enable_interrupts(INT_CCP2);   // Setup interrupt on falling edge 
0705:  BSF    03.5
0706:  BSF    0D.0
....................    enable_interrupts(INT_TIMER0); 
0707:  BCF    03.5
0708:  BSF    0B.5
....................    enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
0709:  BSF    03.5
070A:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
070B:  MOVLW  C0
070C:  BCF    03.5
070D:  IORWF  0B,F
....................    output_low(Electric_Controller_Switch); 
070E:  BSF    03.5
070F:  BCF    06.0
0710:  BCF    03.5
0711:  BCF    06.0
....................    write_dac(0); 
0712:  CLRF   5F
0713:  CLRF   5E
0714:  CALL   0D7
....................    output_high(Contactor_Switch); 
0715:  BSF    03.5
0716:  BCF    06.2
0717:  BCF    03.5
0718:  BSF    06.2
....................    output_low(brake_pin); 
0719:  BSF    03.5
071A:  BCF    06.4
071B:  BCF    03.5
071C:  BCF    06.4
....................    pid_Init(K_P * SCALING_FACTOR,K_I*SCALING_FACTOR,K_D*SCALING_FACTOR, & pidData); 
071D:  CLRF   57
071E:  MOVLW  80
071F:  MOVWF  56
0720:  CLRF   59
0721:  MOVWF  58
0722:  CLRF   5B
0723:  CLRF   5A
0724:  MOVLW  30
0725:  MOVWF  5C
0726:  GOTO   133
....................     
....................    delay_ms(3000); 
0727:  MOVLW  0C
0728:  MOVWF  56
0729:  MOVLW  FA
072A:  MOVWF  57
072B:  GOTO   222
072C:  DECFSZ 56,F
072D:  GOTO   729
>>>>>>> c3b8e56ca4afb031060d4e36e288e08742690935
....................    //write_dac(1000); 
....................    //delay_ms(10000); 
....................    //output_high(Contactor_Switch); 
....................    //output_high(brake_pin); 
....................    //output_high(Electric_Controller_Switch); 
....................    while(TRUE) { 
....................  
....................       //GET INPUTS 
....................       //Vspeedhappens in interrupts 
....................        
....................       set_adc_channel(Acaps_channel); 
<<<<<<< HEAD
04D7:  MOVLW  08
04D8:  MOVWF  21
04D9:  MOVF   1F,W
04DA:  ANDLW  C7
04DB:  IORWF  21,W
04DC:  MOVWF  1F
....................       ADC_DELAY; 
04DD:  MOVLW  21
04DE:  MOVWF  20
04DF:  DECFSZ 20,F
04E0:  GOTO   4DF
....................       Acaps = read_adc(); 
04E1:  BSF    1F.2
04E2:  BTFSC  1F.2
04E3:  GOTO   4E2
04E4:  BSF    03.5
04E5:  MOVF   1E,W
04E6:  BCF    03.5
04E7:  MOVWF  52
04E8:  MOVF   1E,W
04E9:  MOVWF  53
....................        
....................       set_adc_channel(Athrottle_channel); 
04EA:  MOVLW  00
04EB:  MOVWF  21
04EC:  MOVF   1F,W
04ED:  ANDLW  C7
04EE:  IORWF  21,W
04EF:  MOVWF  1F
....................       ADC_DELAY; 
04F0:  MOVLW  21
04F1:  MOVWF  20
04F2:  DECFSZ 20,F
04F3:  GOTO   4F2
....................       Athrottle = read_adc(); 
04F4:  BSF    1F.2
04F5:  BTFSC  1F.2
04F6:  GOTO   4F5
04F7:  BSF    03.5
04F8:  MOVF   1E,W
04F9:  BCF    03.5
04FA:  MOVWF  50
04FB:  MOVF   1E,W
04FC:  MOVWF  51
=======
072E:  MOVLW  08
072F:  MOVWF  21
0730:  MOVF   1F,W
0731:  ANDLW  C7
0732:  IORWF  21,W
0733:  MOVWF  1F
....................       ADC_DELAY; 
0734:  MOVLW  21
0735:  MOVWF  20
0736:  DECFSZ 20,F
0737:  GOTO   736
....................       Acaps = read_adc(); 
0738:  BSF    1F.2
0739:  BTFSC  1F.2
073A:  GOTO   739
073B:  BSF    03.5
073C:  MOVF   1E,W
073D:  BCF    03.5
073E:  MOVWF  54
073F:  MOVF   1E,W
0740:  MOVWF  55
....................        
....................       set_adc_channel(Athrottle_channel); 
0741:  MOVLW  00
0742:  MOVWF  21
0743:  MOVF   1F,W
0744:  ANDLW  C7
0745:  IORWF  21,W
0746:  MOVWF  1F
....................       ADC_DELAY; 
0747:  MOVLW  21
0748:  MOVWF  20
0749:  DECFSZ 20,F
074A:  GOTO   749
....................       Athrottle = read_adc(); 
074B:  BSF    1F.2
074C:  BTFSC  1F.2
074D:  GOTO   74C
074E:  BSF    03.5
074F:  MOVF   1E,W
0750:  BCF    03.5
0751:  MOVWF  52
0752:  MOVF   1E,W
0753:  MOVWF  53
>>>>>>> c3b8e56ca4afb031060d4e36e288e08742690935
....................  
....................       //CONTROL BOX 
....................  
....................        
....................       //current_servo_position=left_position+((Athrottle-Athrottle_Min)/Athrottle_Full)*servo_difference;//(vSpeed/65536.0)*(2500); 
....................       if (Athrottle<Athrottle_Min){ 
<<<<<<< HEAD
04FD:  MOVF   51,W
04FE:  SUBLW  01
04FF:  BTFSS  03.0
0500:  GOTO   50B
0501:  BTFSS  03.2
0502:  GOTO   507
0503:  MOVF   50,W
0504:  SUBLW  31
0505:  BTFSS  03.0
0506:  GOTO   50B
....................          Athrottle=Athrottle_Min; 
0507:  MOVLW  01
0508:  MOVWF  51
0509:  MOVLW  32
050A:  MOVWF  50
=======
0754:  MOVF   53,W
0755:  SUBLW  01
0756:  BTFSS  03.0
0757:  GOTO   762
0758:  BTFSS  03.2
0759:  GOTO   75E
075A:  MOVF   52,W
075B:  SUBLW  31
075C:  BTFSS  03.0
075D:  GOTO   762
....................          Athrottle=Athrottle_Min; 
075E:  MOVLW  01
075F:  MOVWF  53
0760:  MOVLW  32
0761:  MOVWF  52
>>>>>>> c3b8e56ca4afb031060d4e36e288e08742690935
....................       } 
....................       //current_servo_position=right_position-(Athrottle-Athrottle_Min)*Athrottle_servo_factor;//(Athrottle/Athrottle_Full)*servo_difference;//(vSpeed/65536.0)*(2500); 
....................       //printf("Analog Cap %d Analog Throttle %d\n",(int) Acaps, (int) Athrottle); 
....................       current_servo_position =right_position-vSpeed+200; 
<<<<<<< HEAD
050B:  MOVF   4A,W
050C:  SUBLW  C0
050D:  MOVWF  58
050E:  MOVLW  12
050F:  MOVWF  59
0510:  MOVF   4B,W
0511:  BTFSS  03.0
0512:  INCFSZ 4B,W
0513:  SUBWF  59,F
0514:  MOVLW  C8
0515:  ADDWF  58,W
0516:  MOVWF  42
0517:  MOVF   59,W
0518:  MOVWF  43
0519:  BTFSC  03.0
051A:  INCF   43,F
....................       speeder = vSpeed; 
051B:  MOVF   4B,W
051C:  MOVWF  57
051D:  MOVF   4A,W
051E:  MOVWF  56
....................       printf("Speed %lu \n",speeder); 
051F:  CLRF   58
0520:  MOVF   58,W
0521:  CALL   045
0522:  INCF   58,F
0523:  MOVWF  20
0524:  MOVWF  7D
0525:  CALL   260
0526:  MOVLW  06
0527:  SUBWF  58,W
0528:  BTFSS  03.2
0529:  GOTO   520
052A:  MOVLW  10
052B:  MOVWF  04
052C:  MOVF   57,W
052D:  MOVWF  5A
052E:  MOVF   56,W
052F:  MOVWF  59
0530:  CALL   28A
0531:  MOVLW  20
0532:  MOVWF  7D
0533:  CALL   260
0534:  MOVLW  0A
0535:  MOVWF  7D
0536:  CALL   260
....................       //SET OUTPUTS  
....................       //The writing of the ICEThrottle happens in interupts and all that is 
....................       //required is updating ICEthrottle 
....................       //printf("speed before %ld \n",vSpeed); 
....................       returnedValue = pid_Controller((Athrottle-AThrottle_Min),(1280-speeder),& pidData); 
0537:  MOVLW  32
0538:  SUBWF  50,W
0539:  MOVWF  58
053A:  MOVF   51,W
053B:  MOVWF  59
053C:  MOVLW  01
053D:  BTFSS  03.0
053E:  MOVLW  02
053F:  SUBWF  59,F
0540:  MOVF   56,W
0541:  SUBLW  00
0542:  MOVWF  5A
0543:  MOVLW  05
0544:  MOVWF  5B
0545:  MOVF   57,W
0546:  BTFSS  03.0
0547:  INCFSZ 57,W
0548:  SUBWF  5B,F
0549:  MOVF   59,W
054A:  MOVWF  5D
054B:  MOVF   58,W
054C:  MOVWF  5C
054D:  MOVF   5B,W
054E:  MOVWF  5F
054F:  MOVF   5A,W
0550:  MOVWF  5E
0551:  MOVLW  30
0552:  MOVWF  60
0553:  GOTO   357
0554:  MOVF   22,W
0555:  MOVWF  55
0556:  MOVF   21,W
0557:  MOVWF  54
....................       if (ELECthrottle+returnedValue<0){ 
0558:  MOVF   54,W
0559:  ADDWF  4C,W
055A:  MOVWF  58
055B:  MOVF   4D,W
055C:  MOVWF  59
055D:  MOVF   55,W
055E:  BTFSC  03.0
055F:  INCFSZ 55,W
0560:  ADDWF  59,F
0561:  BTFSS  59.7
0562:  GOTO   566
....................          ELECthrottle=0; 
0563:  CLRF   4D
0564:  CLRF   4C
....................       } 
....................       else { 
0565:  GOTO   573
....................       ELECthrottle = ELECthrottle+returnedValue; 
0566:  MOVF   54,W
0567:  ADDWF  4C,W
0568:  MOVWF  21
0569:  MOVF   4D,W
056A:  MOVWF  23
056B:  MOVF   55,W
056C:  BTFSC  03.0
056D:  INCFSZ 55,W
056E:  ADDWF  23,F
056F:  MOVF   21,W
0570:  MOVWF  4C
0571:  MOVF   23,W
0572:  MOVWF  4D
....................       } 
....................       printf("r %lu\n",((unsigned int16) returnedValue)); 
0573:  MOVLW  72
0574:  MOVWF  7D
0575:  CALL   260
0576:  MOVLW  20
0577:  MOVWF  7D
0578:  CALL   260
0579:  MOVLW  10
057A:  MOVWF  04
057B:  MOVF   55,W
057C:  MOVWF  5A
057D:  MOVF   54,W
057E:  MOVWF  59
057F:  CALL   28A
0580:  MOVLW  0A
0581:  MOVWF  7D
0582:  CALL   260
....................       write_dac((unsigned int16)ELECthrottle); 
0583:  MOVF   4D,W
0584:  MOVWF  59
0585:  MOVF   4C,W
0586:  MOVWF  58
0587:  CALL   101
....................       //write_dac((right_position-(right_position-(Athrottle-Athrottle_Min)*Athrottle_servo_factor))*4); 
....................       //write_dac(((Athrottle-AThrottle_Min)*2)+950); 
....................       //write_dac((right_position-current_servo_position)*4); 
....................    } 
0588:  GOTO   4D7
=======
0762:  MOVF   4C,W
0763:  SUBLW  C0
0764:  MOVWF  56
0765:  MOVLW  12
0766:  MOVWF  57
0767:  MOVF   4D,W
0768:  BTFSS  03.0
0769:  INCFSZ 4D,W
076A:  SUBWF  57,F
076B:  MOVLW  C8
076C:  ADDWF  56,W
076D:  MOVWF  42
076E:  MOVF   57,W
076F:  MOVWF  43
0770:  BTFSC  03.0
0771:  INCF   43,F
....................     
....................       //SET OUTPUTS  
....................       //The writing of the ICEThrottle happens in interupts and all that is 
....................       //required is updating ICEthrottle 
....................       returnedValue = pid_Controller(Athrottle,vSpeed,& pidData); 
0772:  MOVF   53,W
0773:  MOVWF  57
0774:  MOVF   52,W
0775:  MOVWF  56
0776:  MOVF   4D,W
0777:  MOVWF  59
0778:  MOVF   4C,W
0779:  MOVWF  58
077A:  MOVLW  30
077B:  MOVWF  5A
077C:  GOTO   24B
077D:  MOVF   22,W
077E:  MOVWF  47
077F:  MOVF   21,W
0780:  MOVWF  46
....................        
....................       write_dac((right_position-(right_position-(Athrottle-Athrottle_Min)*Athrottle_servo_factor))*4); 
0781:  MOVLW  32
0782:  SUBWF  52,W
0783:  MOVWF  56
0784:  MOVF   53,W
0785:  MOVWF  57
0786:  MOVLW  01
0787:  BTFSS  03.0
0788:  MOVLW  02
0789:  SUBWF  57,F
078A:  MOVF   57,W
078B:  MOVWF  59
078C:  MOVF   56,W
078D:  MOVWF  58
078E:  GOTO   4B5
078F:  MOVF   23,W
0790:  MOVWF  5F
0791:  MOVF   22,W
0792:  MOVWF  5E
0793:  MOVF   21,W
0794:  MOVWF  5D
0795:  MOVF   20,W
0796:  MOVWF  5C
0797:  MOVLW  74
0798:  MOVWF  63
0799:  MOVLW  48
079A:  MOVWF  62
079B:  MOVLW  4D
079C:  MOVWF  61
079D:  MOVLW  7F
079E:  MOVWF  60
079F:  CALL   4D3
07A0:  BSF    03.1
07A1:  CLRF   5B
07A2:  CLRF   5A
07A3:  MOVLW  16
07A4:  MOVWF  59
07A5:  MOVLW  8B
07A6:  MOVWF  58
07A7:  MOVF   23,W
07A8:  MOVWF  5F
07A9:  MOVF   22,W
07AA:  MOVWF  5E
07AB:  MOVF   21,W
07AC:  MOVWF  5D
07AD:  MOVF   20,W
07AE:  MOVWF  5C
07AF:  CALL   548
07B0:  BSF    03.1
07B1:  CLRF   5B
07B2:  CLRF   5A
07B3:  MOVLW  16
07B4:  MOVWF  59
07B5:  MOVLW  8B
07B6:  MOVWF  58
07B7:  MOVF   23,W
07B8:  MOVWF  5F
07B9:  MOVF   22,W
07BA:  MOVWF  5E
07BB:  MOVF   21,W
07BC:  MOVWF  5D
07BD:  MOVF   20,W
07BE:  MOVWF  5C
07BF:  CALL   548
07C0:  MOVF   20,W
07C1:  MOVWF  58
07C2:  MOVF   21,W
07C3:  MOVWF  59
07C4:  MOVF   22,W
07C5:  MOVWF  5A
07C6:  MOVF   23,W
07C7:  MOVWF  5B
07C8:  MOVWF  5F
07C9:  MOVF   22,W
07CA:  MOVWF  5E
07CB:  MOVF   21,W
07CC:  MOVWF  5D
07CD:  MOVF   20,W
07CE:  MOVWF  5C
07CF:  CLRF   63
07D0:  CLRF   62
07D1:  CLRF   61
07D2:  MOVLW  81
07D3:  MOVWF  60
07D4:  CALL   4D3
07D5:  MOVF   23,W
07D6:  MOVWF  5F
07D7:  MOVF   22,W
07D8:  MOVWF  5E
07D9:  MOVF   21,W
07DA:  MOVWF  5D
07DB:  MOVF   20,W
07DC:  MOVWF  5C
07DD:  GOTO   686
07DE:  MOVF   22,W
07DF:  MOVWF  5D
07E0:  MOVF   21,W
07E1:  MOVWF  5C
07E2:  MOVF   22,W
07E3:  MOVWF  5F
07E4:  MOVF   21,W
07E5:  MOVWF  5E
07E6:  CALL   0D7
....................       //write_dac((right_position-current_servo_position)*4); 
....................    } 
07E7:  GOTO   72E
>>>>>>> c3b8e56ca4afb031060d4e36e288e08742690935
....................     
....................  
.................... } 
....................  
.................... /*! \brief Initialisation of PID controller parameters. 
....................  * 
....................  *  Initialise the variables used by the PID algorithm. 
....................  * 
....................  *  \param p_factor  Proportional term. 
....................  *  \param i_factor  Integral term. 
....................  *  \param d_factor  Derivate term. 
....................  *  \param pid  Struct with PID status. 
....................  */ 
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid) 
.................... // Set up PID controller parameters 
<<<<<<< HEAD
0589:  GOTO   589
=======
07E8:  GOTO   7E8
>>>>>>> c3b8e56ca4afb031060d4e36e288e08742690935
.................... { 
....................   // Start values for PID controller 
....................   pid->sumError = 0; 
*
<<<<<<< HEAD
015D:  MOVLW  02
015E:  ADDWF  5E,W
015F:  MOVWF  04
0160:  INCF   04,F
0161:  INCF   04,F
0162:  INCF   04,F
0163:  CLRF   00
0164:  DECF   04,F
0165:  CLRF   00
0166:  DECF   04,F
0167:  CLRF   00
0168:  DECF   04,F
0169:  CLRF   00
....................   pid->lastProcessValue = 0; 
016A:  MOVF   5E,W
016B:  MOVWF  04
016C:  INCF   04,F
016D:  CLRF   00
016E:  DECF   04,F
016F:  CLRF   00
....................   // Tuning constants for PID loop 
....................   pid->P_Factor = p_factor; 
0170:  MOVLW  06
0171:  ADDWF  5E,W
0172:  MOVWF  04
0173:  INCF   04,F
0174:  MOVF   59,W
0175:  MOVWF  00
0176:  DECF   04,F
0177:  MOVF   58,W
0178:  MOVWF  00
....................   pid->I_Factor = i_factor; 
0179:  MOVLW  08
017A:  ADDWF  5E,W
017B:  MOVWF  04
017C:  INCF   04,F
017D:  MOVF   5B,W
017E:  MOVWF  00
017F:  DECF   04,F
0180:  MOVF   5A,W
0181:  MOVWF  00
....................   pid->D_Factor = d_factor; 
0182:  MOVLW  0A
0183:  ADDWF  5E,W
0184:  MOVWF  04
0185:  INCF   04,F
0186:  MOVF   5D,W
0187:  MOVWF  00
0188:  DECF   04,F
0189:  MOVF   5C,W
018A:  MOVWF  00
....................   // Limits to avoid overflow 
....................   pid->maxError = MAX_INT / (pid->P_Factor + 1); 
018B:  MOVLW  0C
018C:  ADDWF  5E,W
018D:  MOVWF  5F
018E:  MOVLW  06
018F:  ADDWF  5E,W
0190:  MOVWF  04
0191:  INCF   04,F
0192:  MOVF   00,W
0193:  MOVWF  61
0194:  DECF   04,F
0195:  MOVF   00,W
0196:  MOVWF  60
0197:  MOVLW  01
0198:  ADDWF  60,W
0199:  MOVWF  21
019A:  MOVF   61,W
019B:  MOVWF  23
019C:  BTFSC  03.0
019D:  INCF   23,F
019E:  MOVF   21,W
019F:  MOVWF  62
01A0:  MOVF   23,W
01A1:  MOVWF  63
01A2:  MOVLW  7F
01A3:  MOVWF  65
01A4:  MOVLW  FF
01A5:  MOVWF  64
01A6:  MOVF   63,W
01A7:  MOVWF  67
01A8:  MOVF   62,W
01A9:  MOVWF  66
*
01CE:  MOVF   5F,W
01CF:  MOVWF  04
01D0:  INCF   04,F
01D1:  MOVF   22,W
01D2:  MOVWF  00
01D3:  DECF   04,F
01D4:  MOVF   21,W
01D5:  MOVWF  00
....................   pid->maxSumError = MAX_I_TERM / (pid->I_Factor + 1); 
01D6:  MOVLW  0E
01D7:  ADDWF  5E,W
01D8:  MOVWF  5F
01D9:  MOVLW  08
01DA:  ADDWF  5E,W
01DB:  MOVWF  04
01DC:  INCF   04,F
01DD:  MOVF   00,W
01DE:  MOVWF  61
01DF:  DECF   04,F
01E0:  MOVF   00,W
01E1:  MOVWF  60
01E2:  MOVLW  01
01E3:  ADDWF  60,W
01E4:  MOVWF  21
01E5:  MOVF   61,W
01E6:  MOVWF  23
01E7:  BTFSC  03.0
01E8:  INCF   23,F
01E9:  MOVF   21,W
01EA:  MOVWF  62
01EB:  MOVF   23,W
01EC:  MOVWF  63
01ED:  MOVF   04,W
01EE:  MOVWF  64
01EF:  MOVLW  3F
01F0:  MOVWF  68
01F1:  MOVLW  FF
01F2:  MOVWF  67
01F3:  MOVWF  66
01F4:  MOVWF  65
01F5:  CLRF   6C
01F6:  CLRF   6B
01F7:  MOVF   63,W
01F8:  MOVWF  6A
01F9:  MOVF   62,W
01FA:  MOVWF  69
*
023B:  MOVF   64,W
023C:  MOVWF  04
023D:  MOVF   5F,W
023E:  MOVWF  04
023F:  MOVF   20,W
0240:  MOVWF  00
0241:  INCF   04,F
0242:  MOVF   21,W
0243:  MOVWF  00
0244:  INCF   04,F
0245:  MOVF   22,W
0246:  MOVWF  00
0247:  INCF   04,F
0248:  MOVF   23,W
0249:  MOVWF  00
.................... } 
024A:  BCF    0A.3
024B:  GOTO   4D0 (RETURN)
=======
0133:  MOVLW  02
0134:  ADDWF  5C,W
0135:  MOVWF  04
0136:  INCF   04,F
0137:  INCF   04,F
0138:  INCF   04,F
0139:  CLRF   00
013A:  DECF   04,F
013B:  CLRF   00
013C:  DECF   04,F
013D:  CLRF   00
013E:  DECF   04,F
013F:  CLRF   00
....................   pid->lastProcessValue = 0; 
0140:  MOVF   5C,W
0141:  MOVWF  04
0142:  INCF   04,F
0143:  CLRF   00
0144:  DECF   04,F
0145:  CLRF   00
....................   // Tuning constants for PID loop 
....................   pid->P_Factor = p_factor; 
0146:  MOVLW  06
0147:  ADDWF  5C,W
0148:  MOVWF  04
0149:  INCF   04,F
014A:  MOVF   57,W
014B:  MOVWF  00
014C:  DECF   04,F
014D:  MOVF   56,W
014E:  MOVWF  00
....................   pid->I_Factor = i_factor; 
014F:  MOVLW  08
0150:  ADDWF  5C,W
0151:  MOVWF  04
0152:  INCF   04,F
0153:  MOVF   59,W
0154:  MOVWF  00
0155:  DECF   04,F
0156:  MOVF   58,W
0157:  MOVWF  00
....................   pid->D_Factor = d_factor; 
0158:  MOVLW  0A
0159:  ADDWF  5C,W
015A:  MOVWF  04
015B:  INCF   04,F
015C:  MOVF   5B,W
015D:  MOVWF  00
015E:  DECF   04,F
015F:  MOVF   5A,W
0160:  MOVWF  00
....................   // Limits to avoid overflow 
....................   pid->maxError = MAX_INT / (pid->P_Factor + 1); 
0161:  MOVLW  0C
0162:  ADDWF  5C,W
0163:  MOVWF  5D
0164:  MOVLW  06
0165:  ADDWF  5C,W
0166:  MOVWF  04
0167:  INCF   04,F
0168:  MOVF   00,W
0169:  MOVWF  5F
016A:  DECF   04,F
016B:  MOVF   00,W
016C:  MOVWF  5E
016D:  MOVLW  01
016E:  ADDWF  5E,W
016F:  MOVWF  21
0170:  MOVF   5F,W
0171:  MOVWF  23
0172:  BTFSC  03.0
0173:  INCF   23,F
0174:  MOVF   21,W
0175:  MOVWF  60
0176:  MOVF   23,W
0177:  MOVWF  61
0178:  MOVLW  7F
0179:  MOVWF  63
017A:  MOVLW  FF
017B:  MOVWF  62
017C:  MOVF   61,W
017D:  MOVWF  65
017E:  MOVF   60,W
017F:  MOVWF  64
*
01A4:  MOVF   5D,W
01A5:  MOVWF  04
01A6:  INCF   04,F
01A7:  MOVF   22,W
01A8:  MOVWF  00
01A9:  DECF   04,F
01AA:  MOVF   21,W
01AB:  MOVWF  00
....................   pid->maxSumError = MAX_I_TERM / (pid->I_Factor + 1); 
01AC:  MOVLW  0E
01AD:  ADDWF  5C,W
01AE:  MOVWF  5D
01AF:  MOVLW  08
01B0:  ADDWF  5C,W
01B1:  MOVWF  04
01B2:  INCF   04,F
01B3:  MOVF   00,W
01B4:  MOVWF  5F
01B5:  DECF   04,F
01B6:  MOVF   00,W
01B7:  MOVWF  5E
01B8:  MOVLW  01
01B9:  ADDWF  5E,W
01BA:  MOVWF  21
01BB:  MOVF   5F,W
01BC:  MOVWF  23
01BD:  BTFSC  03.0
01BE:  INCF   23,F
01BF:  MOVF   21,W
01C0:  MOVWF  60
01C1:  MOVF   23,W
01C2:  MOVWF  61
01C3:  MOVF   04,W
01C4:  MOVWF  62
01C5:  MOVLW  3F
01C6:  MOVWF  66
01C7:  MOVLW  FF
01C8:  MOVWF  65
01C9:  MOVWF  64
01CA:  MOVWF  63
01CB:  CLRF   6A
01CC:  CLRF   69
01CD:  MOVF   61,W
01CE:  MOVWF  68
01CF:  MOVF   60,W
01D0:  MOVWF  67
*
0211:  MOVF   62,W
0212:  MOVWF  04
0213:  MOVF   5D,W
0214:  MOVWF  04
0215:  MOVF   20,W
0216:  MOVWF  00
0217:  INCF   04,F
0218:  MOVF   21,W
0219:  MOVWF  00
021A:  INCF   04,F
021B:  MOVF   22,W
021C:  MOVWF  00
021D:  INCF   04,F
021E:  MOVF   23,W
021F:  MOVWF  00
.................... } 
0220:  BCF    0A.3
0221:  GOTO   727 (RETURN)
>>>>>>> c3b8e56ca4afb031060d4e36e288e08742690935
....................  
....................  
.................... /*! \brief PID control algorithm. 
....................  * 
....................  *  Calculates output from setpoint, process value and PID status. 
....................  * 
....................  *  \param setPoint  Desired value. 
....................  *  \param processValue  Measured value. 
....................  *  \param pid_st  PID status struct. 
....................  */ 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st) 
.................... { 
....................   signed int16 error, p_term, d_term; 
....................   signed int32 i_term, ret, temp; 
....................     processValue=processValue/4; 
*
0357:  RRF    5F,F
0358:  RRF    5E,F
0359:  RRF    5F,F
035A:  RRF    5E,F
035B:  MOVLW  3F
035C:  ANDWF  5F,F
....................   printf("input %ld speed %ld ",setPoint,processValue); 
035D:  CLRF   73
035E:  MOVF   73,W
035F:  CALL   055
0360:  INCF   73,F
0361:  MOVWF  20
0362:  MOVWF  7D
0363:  CALL   260
0364:  MOVLW  06
0365:  SUBWF  73,W
0366:  BTFSS  03.2
0367:  GOTO   35E
0368:  MOVLW  10
0369:  MOVWF  04
036A:  MOVF   5D,W
036B:  MOVWF  76
036C:  MOVF   5C,W
036D:  MOVWF  75
036E:  CALL   2E2
036F:  MOVLW  09
0370:  MOVWF  74
0371:  MOVF   74,W
0372:  CALL   055
0373:  INCF   74,F
0374:  MOVWF  20
0375:  MOVWF  7D
0376:  CALL   260
0377:  MOVLW  10
0378:  SUBWF  74,W
0379:  BTFSS  03.2
037A:  GOTO   371
037B:  MOVLW  10
037C:  MOVWF  04
037D:  MOVF   5F,W
037E:  MOVWF  76
037F:  MOVF   5E,W
0380:  MOVWF  75
0381:  CALL   2E2
0382:  MOVLW  20
0383:  MOVWF  7D
0384:  CALL   260
....................   error = setPoint - processValue; 
<<<<<<< HEAD
0385:  MOVF   5E,W
0386:  SUBWF  5C,W
0387:  MOVWF  20
0388:  MOVF   5D,W
0389:  MOVWF  23
038A:  MOVF   5F,W
038B:  BTFSS  03.0
038C:  INCFSZ 5F,W
038D:  SUBWF  23,F
038E:  MOVF   20,W
038F:  MOVWF  61
0390:  MOVF   23,W
0391:  MOVWF  62
....................    
....................   // Calculate Pterm and limit error overflow 
....................   /* 
....................   if (error > (signed int16) pid_st->maxError){ 
....................     p_term = MAX_INT; 
....................        printf(" greater error %ld a %ld p %ld",error,pid_st->maxError,p_term); 
....................  
....................   } 
....................   else if (error < (signed int16) -pid_st->maxError){ 
....................     p_term = -MAX_INT; 
....................     printf("less error %ld a %ld p %ld",error,-pid_st->maxError,p_term); 
....................  
....................   } 
....................   else{*/ 
....................     p_term = pid_st->P_Factor * error; 
0392:  MOVLW  06
0393:  ADDWF  60,W
0394:  MOVWF  04
0395:  INCF   04,F
0396:  MOVF   00,W
0397:  MOVWF  74
0398:  DECF   04,F
0399:  MOVF   00,W
039A:  MOVWF  73
039B:  MOVF   74,W
039C:  MOVWF  76
039D:  MOVF   73,W
039E:  MOVWF  75
039F:  MOVF   62,W
03A0:  MOVWF  78
03A1:  MOVF   61,W
03A2:  MOVWF  77
*
03B7:  MOVF   22,W
03B8:  MOVWF  64
03B9:  MOVF   21,W
03BA:  MOVWF  63
....................    //printf("error %ld a %ld p %ld",error,pid_st->maxError,p_term); 
....................   //} 
....................    
.................... /* 
=======
*
024B:  MOVF   58,W
024C:  SUBWF  56,W
024D:  MOVWF  5B
024E:  MOVF   57,W
024F:  MOVWF  5C
0250:  MOVF   59,W
0251:  BTFSS  03.0
0252:  INCFSZ 59,W
0253:  SUBWF  5C,F
....................  
....................   // Calculate Pterm and limit error overflow 
....................   if (error > pid_st->maxError){ 
0254:  MOVLW  0C
0255:  ADDWF  5A,W
0256:  MOVWF  04
0257:  INCF   04,F
0258:  MOVF   00,W
0259:  MOVWF  23
025A:  DECF   04,F
025B:  MOVF   00,W
025C:  MOVWF  21
025D:  MOVF   23,W
025E:  SUBWF  5C,W
025F:  BTFSS  03.0
0260:  GOTO   26C
0261:  BTFSS  03.2
0262:  GOTO   267
0263:  MOVF   5B,W
0264:  SUBWF  21,W
0265:  BTFSC  03.0
0266:  GOTO   26C
....................     p_term = MAX_INT; 
0267:  MOVLW  7F
0268:  MOVWF  5E
0269:  MOVLW  FF
026A:  MOVWF  5D
....................   } 
....................   else if (error < -pid_st->maxError){ 
026B:  GOTO   2A5
026C:  MOVLW  0C
026D:  ADDWF  5A,W
026E:  MOVWF  04
026F:  INCF   04,F
0270:  MOVF   00,W
0271:  MOVWF  23
0272:  DECF   04,F
0273:  MOVF   00,W
0274:  SUBLW  00
0275:  MOVWF  20
0276:  MOVF   23,W
0277:  BTFSS  03.0
0278:  INCFSZ 23,W
0279:  GOTO   27C
027A:  MOVLW  00
027B:  GOTO   27D
027C:  SUBLW  00
027D:  MOVWF  23
027E:  MOVF   20,W
027F:  MOVWF  21
0280:  MOVF   5C,W
0281:  SUBWF  23,W
0282:  BTFSS  03.0
0283:  GOTO   28F
0284:  BTFSS  03.2
0285:  GOTO   28A
0286:  MOVF   21,W
0287:  SUBWF  5B,W
0288:  BTFSC  03.0
0289:  GOTO   28F
....................     p_term = -MAX_INT; 
028A:  MOVLW  80
028B:  MOVWF  5E
028C:  MOVLW  01
028D:  MOVWF  5D
....................   } 
....................   else{ 
028E:  GOTO   2A5
....................     p_term = pid_st->P_Factor * error; 
028F:  MOVLW  06
0290:  ADDWF  5A,W
0291:  MOVWF  04
0292:  INCF   04,F
0293:  MOVF   00,W
0294:  MOVWF  6E
0295:  DECF   04,F
0296:  MOVF   00,W
0297:  MOVWF  6D
0298:  MOVF   6E,W
0299:  MOVWF  74
029A:  MOVF   6D,W
029B:  MOVWF  73
029C:  MOVF   5C,W
029D:  MOVWF  76
029E:  MOVF   5B,W
029F:  MOVWF  75
02A0:  CALL   236
02A1:  MOVF   22,W
02A2:  MOVWF  5E
02A3:  MOVF   21,W
02A4:  MOVWF  5D
....................   } 
....................  
>>>>>>> c3b8e56ca4afb031060d4e36e288e08742690935
....................   // Calculate Iterm and limit integral runaway 
....................   temp = pid_st->sumError + error; 
02A5:  MOVLW  02
02A6:  ADDWF  5A,W
02A7:  MOVWF  04
02A8:  MOVF   00,W
02A9:  MOVWF  6D
02AA:  INCF   04,F
02AB:  MOVF   00,W
02AC:  MOVWF  6E
02AD:  INCF   04,F
02AE:  MOVF   00,W
02AF:  MOVWF  6F
02B0:  INCF   04,F
02B1:  MOVF   00,W
02B2:  MOVWF  70
02B3:  MOVLW  FD
02B4:  ADDWF  04,F
02B5:  MOVF   5B,W
02B6:  ADDWF  6D,W
02B7:  MOVWF  69
02B8:  MOVF   6E,W
02B9:  MOVWF  6A
02BA:  MOVF   5C,W
02BB:  BTFSC  03.0
02BC:  INCFSZ 5C,W
02BD:  ADDWF  6A,F
02BE:  MOVF   6F,W
02BF:  MOVWF  6B
02C0:  MOVLW  00
02C1:  BTFSC  03.0
02C2:  MOVLW  01
02C3:  ADDWF  6B,F
02C4:  MOVF   70,W
02C5:  MOVWF  6C
02C6:  MOVLW  00
02C7:  BTFSC  03.0
02C8:  MOVLW  01
02C9:  ADDWF  6C,F
....................   if(temp > pid_st->maxSumError){ 
02CA:  MOVLW  0E
02CB:  ADDWF  5A,W
02CC:  MOVWF  04
02CD:  MOVF   00,W
02CE:  MOVWF  20
02CF:  INCF   04,F
02D0:  MOVF   00,W
02D1:  MOVWF  21
02D2:  INCF   04,F
02D3:  MOVF   00,W
02D4:  MOVWF  22
02D5:  INCF   04,F
02D6:  MOVF   00,W
02D7:  MOVWF  23
02D8:  SUBWF  6C,W
02D9:  BTFSS  03.0
02DA:  GOTO   312
02DB:  BTFSS  03.2
02DC:  GOTO   2ED
02DD:  MOVF   22,W
02DE:  SUBWF  6B,W
02DF:  BTFSS  03.0
02E0:  GOTO   312
02E1:  BTFSS  03.2
02E2:  GOTO   2ED
02E3:  MOVF   21,W
02E4:  SUBWF  6A,W
02E5:  BTFSS  03.0
02E6:  GOTO   312
02E7:  BTFSS  03.2
02E8:  GOTO   2ED
02E9:  MOVF   69,W
02EA:  SUBWF  20,W
02EB:  BTFSC  03.0
02EC:  GOTO   312
....................     i_term = MAX_I_TERM; 
02ED:  MOVLW  3F
02EE:  MOVWF  64
02EF:  MOVLW  FF
02F0:  MOVWF  63
02F1:  MOVWF  62
02F2:  MOVWF  61
....................     pid_st->sumError = pid_st->maxSumError; 
02F3:  MOVLW  02
02F4:  ADDWF  5A,W
02F5:  MOVWF  6D
02F6:  MOVLW  0E
02F7:  ADDWF  5A,W
02F8:  MOVWF  04
02F9:  MOVF   00,W
02FA:  MOVWF  20
02FB:  INCF   04,F
02FC:  MOVF   00,W
02FD:  MOVWF  21
02FE:  INCF   04,F
02FF:  MOVF   00,W
0300:  MOVWF  22
0301:  INCF   04,F
0302:  MOVF   00,W
0303:  MOVWF  23
0304:  MOVF   6D,W
0305:  MOVWF  04
0306:  MOVF   20,W
0307:  MOVWF  00
0308:  INCF   04,F
0309:  MOVF   21,W
030A:  MOVWF  00
030B:  INCF   04,F
030C:  MOVF   22,W
030D:  MOVWF  00
030E:  INCF   04,F
030F:  MOVF   23,W
0310:  MOVWF  00
....................   } 
....................   else if(temp < -pid_st->maxSumError){ 
0311:  GOTO   41F
0312:  MOVLW  0E
0313:  ADDWF  5A,W
0314:  MOVWF  04
0315:  MOVF   00,W
0316:  MOVWF  20
0317:  INCF   04,F
0318:  MOVF   00,W
0319:  MOVWF  21
031A:  INCF   04,F
031B:  MOVF   00,W
031C:  MOVWF  22
031D:  INCF   04,F
031E:  MOVF   00,W
031F:  MOVWF  23
0320:  MOVLW  FD
0321:  ADDWF  04,F
0322:  MOVF   20,W
0323:  SUBLW  00
0324:  MOVWF  20
0325:  MOVF   21,W
0326:  BTFSS  03.0
0327:  INCFSZ 21,W
0328:  GOTO   32B
0329:  MOVLW  00
032A:  GOTO   32C
032B:  SUBLW  00
032C:  MOVWF  21
032D:  MOVF   22,W
032E:  BTFSS  03.0
032F:  INCFSZ 22,W
0330:  GOTO   333
0331:  MOVLW  00
0332:  GOTO   334
0333:  SUBLW  00
0334:  MOVWF  22
0335:  MOVF   23,W
0336:  BTFSS  03.0
0337:  INCFSZ 23,W
0338:  GOTO   33B
0339:  MOVLW  00
033A:  GOTO   33C
033B:  SUBLW  00
033C:  MOVWF  23
033D:  MOVF   6C,W
033E:  SUBWF  23,W
033F:  BTFSS  03.0
0340:  GOTO   396
0341:  BTFSS  03.2
0342:  GOTO   353
0343:  MOVF   6B,W
0344:  SUBWF  22,W
0345:  BTFSS  03.0
0346:  GOTO   396
0347:  BTFSS  03.2
0348:  GOTO   353
0349:  MOVF   6A,W
034A:  SUBWF  21,W
034B:  BTFSS  03.0
034C:  GOTO   396
034D:  BTFSS  03.2
034E:  GOTO   353
034F:  MOVF   20,W
0350:  SUBWF  69,W
0351:  BTFSC  03.0
0352:  GOTO   396
....................     i_term = -MAX_I_TERM; 
0353:  MOVLW  C0
0354:  MOVWF  64
0355:  CLRF   63
0356:  CLRF   62
0357:  MOVLW  01
0358:  MOVWF  61
....................     pid_st->sumError = -pid_st->maxSumError; 
0359:  MOVLW  02
035A:  ADDWF  5A,W
035B:  MOVWF  6D
035C:  MOVLW  0E
035D:  ADDWF  5A,W
035E:  MOVWF  04
035F:  MOVF   00,W
0360:  MOVWF  20
0361:  INCF   04,F
0362:  MOVF   00,W
0363:  MOVWF  21
0364:  INCF   04,F
0365:  MOVF   00,W
0366:  MOVWF  22
0367:  INCF   04,F
0368:  MOVF   00,W
0369:  MOVWF  23
036A:  MOVLW  FD
036B:  ADDWF  04,F
036C:  MOVF   20,W
036D:  SUBLW  00
036E:  MOVWF  20
036F:  MOVF   21,W
0370:  BTFSS  03.0
0371:  INCFSZ 21,W
0372:  GOTO   375
0373:  MOVLW  00
0374:  GOTO   376
0375:  SUBLW  00
0376:  MOVWF  21
0377:  MOVF   22,W
0378:  BTFSS  03.0
0379:  INCFSZ 22,W
037A:  GOTO   37D
037B:  MOVLW  00
037C:  GOTO   37E
037D:  SUBLW  00
037E:  MOVWF  22
037F:  MOVF   23,W
0380:  BTFSS  03.0
0381:  INCFSZ 23,W
0382:  GOTO   385
0383:  MOVLW  00
0384:  GOTO   386
0385:  SUBLW  00
0386:  MOVWF  23
0387:  MOVWF  71
0388:  MOVF   6D,W
0389:  MOVWF  04
038A:  MOVF   20,W
038B:  MOVWF  00
038C:  INCF   04,F
038D:  MOVF   21,W
038E:  MOVWF  00
038F:  INCF   04,F
0390:  MOVF   22,W
0391:  MOVWF  00
0392:  INCF   04,F
0393:  MOVF   71,W
0394:  MOVWF  00
....................   } 
....................   else{ 
0395:  GOTO   41F
....................     pid_st->sumError = temp; 
0396:  MOVLW  02
0397:  ADDWF  5A,W
0398:  MOVWF  04
0399:  MOVF   69,W
039A:  MOVWF  00
039B:  INCF   04,F
039C:  MOVF   6A,W
039D:  MOVWF  00
039E:  INCF   04,F
039F:  MOVF   6B,W
03A0:  MOVWF  00
03A1:  INCF   04,F
03A2:  MOVF   6C,W
03A3:  MOVWF  00
....................     i_term = pid_st->I_Factor * pid_st->sumError; 
03A4:  MOVLW  08
03A5:  ADDWF  5A,W
03A6:  MOVWF  04
03A7:  INCF   04,F
03A8:  MOVF   00,W
03A9:  MOVWF  6E
03AA:  DECF   04,F
03AB:  MOVF   00,W
03AC:  MOVWF  6D
03AD:  MOVLW  02
03AE:  ADDWF  5A,W
03AF:  MOVWF  04
03B0:  MOVF   00,W
03B1:  MOVWF  20
03B2:  INCF   04,F
03B3:  MOVF   00,W
03B4:  MOVWF  21
03B5:  INCF   04,F
03B6:  MOVF   00,W
03B7:  MOVWF  22
03B8:  INCF   04,F
03B9:  MOVF   00,W
03BA:  MOVWF  23
03BB:  MOVLW  FD
03BC:  ADDWF  04,F
03BD:  MOVF   23,W
03BE:  MOVWF  72
03BF:  MOVF   22,W
03C0:  MOVWF  71
03C1:  MOVF   21,W
03C2:  MOVWF  70
03C3:  MOVF   20,W
03C4:  MOVWF  6F
03C5:  MOVF   04,W
03C6:  MOVWF  73
03C7:  CLRF   77
03C8:  CLRF   76
03C9:  MOVF   6E,W
03CA:  MOVWF  75
03CB:  MOVF   6D,W
03CC:  MOVWF  74
03CD:  MOVF   72,W
03CE:  MOVWF  7B
03CF:  MOVF   71,W
03D0:  MOVWF  7A
03D1:  MOVF   70,W
03D2:  MOVWF  79
03D3:  MOVF   6F,W
03D4:  MOVWF  78
*
0414:  BCF    03.5
0415:  MOVF   73,W
0416:  MOVWF  04
0417:  MOVF   23,W
0418:  MOVWF  64
0419:  MOVF   22,W
041A:  MOVWF  63
041B:  MOVF   21,W
041C:  MOVWF  62
041D:  MOVF   20,W
041E:  MOVWF  61
....................   } 
....................  
....................   // Calculate Dterm 
....................   d_term = pid_st->D_Factor * (pid_st->lastProcessValue - processValue); 
041F:  MOVLW  0A
0420:  ADDWF  5A,W
0421:  MOVWF  04
0422:  INCF   04,F
0423:  MOVF   00,W
0424:  MOVWF  6E
0425:  DECF   04,F
0426:  MOVF   00,W
0427:  MOVWF  6D
0428:  MOVF   5A,W
0429:  MOVWF  04
042A:  INCF   04,F
042B:  MOVF   00,W
042C:  MOVWF  70
042D:  DECF   04,F
042E:  MOVF   00,W
042F:  MOVWF  6F
0430:  MOVF   58,W
0431:  SUBWF  6F,W
0432:  MOVWF  20
0433:  MOVF   70,W
0434:  MOVWF  23
0435:  MOVF   59,W
0436:  BTFSS  03.0
0437:  INCFSZ 59,W
0438:  SUBWF  23,F
0439:  MOVF   20,W
043A:  MOVWF  71
043B:  MOVF   23,W
043C:  MOVWF  72
043D:  MOVF   6E,W
043E:  MOVWF  74
043F:  MOVF   6D,W
0440:  MOVWF  73
0441:  MOVF   23,W
0442:  MOVWF  76
0443:  MOVF   20,W
0444:  MOVWF  75
0445:  CALL   236
0446:  MOVF   22,W
0447:  MOVWF  60
0448:  MOVF   21,W
0449:  MOVWF  5F
....................  
....................   pid_st->lastProcessValue = processValue; 
<<<<<<< HEAD
.................... */ 
....................   //ret = (p_term + i_term + d_term) / SCALING_FACTOR; 
....................    ret = (p_term) / SCALING_FACTOR; 
03BB:  MOVF   64,W
03BC:  MOVWF  74
03BD:  MOVF   63,W
03BE:  MOVWF  73
03BF:  CLRF   76
03C0:  MOVLW  80
03C1:  MOVWF  75
*
03FF:  MOVF   22,W
0400:  MOVWF  23
0401:  MOVF   21,W
0402:  MOVWF  20
0403:  MOVF   22,W
0404:  MOVWF  21
0405:  CLRF   22
0406:  CLRF   23
0407:  BTFSS  21.7
0408:  GOTO   40B
0409:  DECF   22,F
040A:  DECF   23,F
040B:  MOVF   23,W
040C:  MOVWF  6E
040D:  MOVF   22,W
040E:  MOVWF  6D
040F:  MOVF   21,W
0410:  MOVWF  6C
0411:  MOVF   20,W
0412:  MOVWF  6B
....................   if(ret > MAX_INT){ 
0413:  BTFSC  6E.7
0414:  GOTO   426
0415:  MOVF   6E,F
0416:  BTFSS  03.2
0417:  GOTO   41F
0418:  MOVF   6D,F
0419:  BTFSS  03.2
041A:  GOTO   41F
041B:  MOVF   6C,W
041C:  SUBLW  7F
041D:  BTFSC  03.0
041E:  GOTO   426
....................     ret = MAX_INT; 
041F:  CLRF   6E
0420:  CLRF   6D
0421:  MOVLW  7F
0422:  MOVWF  6C
0423:  MOVLW  FF
0424:  MOVWF  6B
....................   } 
....................   else if(ret < -MAX_INT){ 
0425:  GOTO   445
0426:  BTFSS  6E.7
0427:  GOTO   445
0428:  MOVF   6E,W
0429:  SUBLW  FF
042A:  BTFSS  03.0
042B:  GOTO   445
042C:  BTFSS  03.2
042D:  GOTO   43E
042E:  MOVF   6D,W
042F:  SUBLW  FF
0430:  BTFSS  03.0
0431:  GOTO   445
0432:  BTFSS  03.2
0433:  GOTO   43E
0434:  MOVF   6C,W
0435:  SUBLW  80
0436:  BTFSS  03.0
0437:  GOTO   445
0438:  BTFSS  03.2
0439:  GOTO   43E
043A:  MOVF   6B,W
043B:  SUBLW  00
043C:  BTFSS  03.0
043D:  GOTO   445
=======
044A:  MOVF   5A,W
044B:  MOVWF  04
044C:  INCF   04,F
044D:  MOVF   59,W
044E:  MOVWF  00
044F:  DECF   04,F
0450:  MOVF   58,W
0451:  MOVWF  00
....................  
....................   ret = (p_term + i_term + d_term) / SCALING_FACTOR; 
0452:  MOVF   5D,W
0453:  ADDWF  61,W
0454:  MOVWF  6D
0455:  MOVF   62,W
0456:  MOVWF  6E
0457:  MOVF   5E,W
0458:  BTFSC  03.0
0459:  INCFSZ 5E,W
045A:  ADDWF  6E,F
045B:  MOVF   63,W
045C:  MOVWF  6F
045D:  MOVLW  00
045E:  BTFSC  03.0
045F:  MOVLW  01
0460:  ADDWF  6F,F
0461:  MOVF   64,W
0462:  MOVWF  70
0463:  MOVLW  00
0464:  BTFSC  03.0
0465:  MOVLW  01
0466:  ADDWF  70,F
0467:  MOVF   5F,W
0468:  ADDWF  6D,W
0469:  MOVWF  71
046A:  MOVF   6E,W
046B:  MOVWF  72
046C:  MOVF   60,W
046D:  BTFSC  03.0
046E:  INCFSZ 60,W
046F:  ADDWF  72,F
0470:  MOVF   6F,W
0471:  MOVWF  73
0472:  MOVLW  00
0473:  BTFSC  03.0
0474:  MOVLW  01
0475:  ADDWF  73,F
0476:  MOVF   70,W
0477:  MOVWF  74
0478:  MOVLW  00
0479:  BTFSC  03.0
047A:  MOVLW  01
047B:  ADDWF  74,F
047C:  RRF    74,W
047D:  MOVWF  68
047E:  RRF    73,W
047F:  MOVWF  67
0480:  RRF    72,W
0481:  MOVWF  66
0482:  RRF    71,W
0483:  MOVWF  65
0484:  RRF    68,F
0485:  RRF    67,F
0486:  RRF    66,F
0487:  RRF    65,F
0488:  RRF    68,F
0489:  RRF    67,F
048A:  RRF    66,F
048B:  RRF    65,F
048C:  RRF    68,F
048D:  RRF    67,F
048E:  RRF    66,F
048F:  RRF    65,F
0490:  RRF    68,F
0491:  RRF    67,F
0492:  RRF    66,F
0493:  RRF    65,F
0494:  RRF    68,F
0495:  RRF    67,F
0496:  RRF    66,F
0497:  RRF    65,F
0498:  RRF    68,F
0499:  RRF    67,F
049A:  RRF    66,F
049B:  RRF    65,F
049C:  MOVLW  01
049D:  ANDWF  68,F
....................   if(ret > MAX_INT){ 
049E:  MOVF   68,F
049F:  BTFSS  03.2
04A0:  GOTO   4A8
04A1:  MOVF   67,F
04A2:  BTFSS  03.2
04A3:  GOTO   4A8
04A4:  MOVF   66,W
04A5:  SUBLW  7F
04A6:  BTFSC  03.0
04A7:  GOTO   4AF
....................     ret = MAX_INT; 
04A8:  CLRF   68
04A9:  CLRF   67
04AA:  MOVLW  7F
04AB:  MOVWF  66
04AC:  MOVLW  FF
04AD:  MOVWF  65
....................   } 
....................   else if(ret < -MAX_INT){ 
04AE:  GOTO   4AF
>>>>>>> c3b8e56ca4afb031060d4e36e288e08742690935
....................     ret = -MAX_INT; 
043E:  MOVLW  FF
043F:  MOVWF  6E
0440:  MOVWF  6D
0441:  MOVLW  80
0442:  MOVWF  6C
0443:  MOVLW  01
0444:  MOVWF  6B
....................   } 
....................  
....................   return((int16)ret); 
<<<<<<< HEAD
0445:  MOVF   6B,W
0446:  MOVWF  21
0447:  MOVF   6C,W
0448:  MOVWF  22
.................... } 
0449:  BCF    0A.3
044A:  GOTO   554 (RETURN)
=======
04AF:  MOVF   65,W
04B0:  MOVWF  21
04B1:  MOVF   66,W
04B2:  MOVWF  22
.................... } 
04B3:  BCF    0A.3
04B4:  GOTO   77D (RETURN)
>>>>>>> c3b8e56ca4afb031060d4e36e288e08742690935
....................  
.................... /*! \brief Resets the integrator. 
....................  * 
....................  *  Calling this function will reset the integrator in the PID regulator. 
....................  */ 
.................... void pid_Reset_Integrator(pidData_t *pid_st) 
.................... { 
....................   pid_st->sumError = 0; 
.................... } 
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 373A   HS NOWDT NOPUT DEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
