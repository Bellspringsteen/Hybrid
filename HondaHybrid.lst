CCS PCM C Compiler, Version 4.084, 46530               04-Jul-12 17:24

               Filename: HondaHybrid.lst

               ROM used: 426 words (11%)
                         Largest free fragment is 1788
               RAM used: 29 (16%) at main() level
                         37 (21%) worst case
               Stack:    2 worst case (1 in main + 1 for interrupts)

*
0000:  NOP
0001:  MOVLW  00
0002:  MOVWF  0A
0003:  GOTO   124
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  26
0008:  MOVF   7F,W
0009:  MOVWF  25
000A:  MOVF   0A,W
000B:  MOVWF  2D
000C:  CLRF   0A
000D:  SWAPF  25,F
000E:  MOVF   04,W
000F:  MOVWF  27
0010:  MOVF   20,W
0011:  MOVWF  28
0012:  MOVF   21,W
0013:  MOVWF  29
0014:  MOVF   22,W
0015:  MOVWF  2A
0016:  MOVF   23,W
0017:  MOVWF  2B
0018:  MOVF   24,W
0019:  MOVWF  2C
001A:  BCF    03.7
001B:  BCF    03.5
001C:  MOVLW  8C
001D:  MOVWF  04
001E:  BTFSS  00.0
001F:  GOTO   022
0020:  BTFSC  0C.0
0021:  GOTO   03F
0022:  MOVLW  8D
0023:  MOVWF  04
0024:  BTFSS  00.0
0025:  GOTO   028
0026:  BTFSC  0D.0
0027:  GOTO   041
0028:  BTFSS  0B.5
0029:  GOTO   02C
002A:  BTFSC  0B.2
002B:  GOTO   043
002C:  MOVF   27,W
002D:  MOVWF  04
002E:  MOVF   28,W
002F:  MOVWF  20
0030:  MOVF   29,W
0031:  MOVWF  21
0032:  MOVF   2A,W
0033:  MOVWF  22
0034:  MOVF   2B,W
0035:  MOVWF  23
0036:  MOVF   2C,W
0037:  MOVWF  24
0038:  MOVF   2D,W
0039:  MOVWF  0A
003A:  SWAPF  26,W
003B:  MOVWF  03
003C:  SWAPF  7F,F
003D:  SWAPF  7F,W
003E:  RETFIE
003F:  BCF    0A.3
0040:  GOTO   061
0041:  BCF    0A.3
0042:  GOTO   08B
0043:  BCF    0A.3
0044:  GOTO   045
.................... #include "C:\Documents and Settings\Enter\My Documents\Hybrid\Hybrid-v2\HondaHybrid.h" 
.................... #include <16F873A.h> 
.................... //////// Standard Header file for the PIC16F873A device //////////////// 
.................... #device PIC16F873A 
.................... #list 
....................  
....................  
.................... //#include <16F737.h> 
.................... #device ICD=TRUE 
.................... #device adc=10 
.................... //#device adc=8 
.................... #use delay(clock=20000000) 
*
00B3:  MOVLW  3A
00B4:  MOVWF  04
00B5:  MOVF   00,W
00B6:  BTFSC  03.2
00B7:  GOTO   0C5
00B8:  MOVLW  06
00B9:  MOVWF  21
00BA:  CLRF   20
00BB:  DECFSZ 20,F
00BC:  GOTO   0BB
00BD:  DECFSZ 21,F
00BE:  GOTO   0BA
00BF:  MOVLW  7B
00C0:  MOVWF  20
00C1:  DECFSZ 20,F
00C2:  GOTO   0C1
00C3:  DECFSZ 00,F
00C4:  GOTO   0B8
00C5:  BCF    0A.3
00C6:  GOTO   19A (RETURN)
.................... #fuses HS,NOWDT 
.................... #use rs232 (debugger,STREAM=MONITOR) 
.................... #include <mcp4921.c> 
.................... //////////////// Driver for MCP4921 D/A Converter /////////////////////// 
.................... ////                                                                 //// 
.................... ////  init_dac()    Call this before using a MCP4921 DAC             //// 
.................... ////                                                                 //// 
.................... ////  write_dac( long int )   Writes command and 12 bit resolution   //// 
.................... ////                          to the MCP4921 which converts it to a  //// 
.................... ////                          voltage                                //// 
.................... ////                          0-4095 input represents 0-vref V out.  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SELECT 
....................  
.................... #define DAC_CS     PIN_C4 
.................... #define DAC_CLK    PIN_C3 
.................... #define DAC_DI     PIN_C5 
.................... #define DAC_LDAC   PIN_B4 
....................  
.................... #endif 
....................  
.................... void init_dac() 
.................... { 
....................    output_high(DAC_CS); 
*
009B:  BCF    2E.4
009C:  MOVF   2E,W
009D:  BSF    03.5
009E:  MOVWF  07
009F:  BCF    03.5
00A0:  BSF    07.4
....................    output_high(DAC_LDAC); 
00A1:  BSF    03.5
00A2:  BCF    06.4
00A3:  BCF    03.5
00A4:  BSF    06.4
....................    output_high(DAC_CLK); 
00A5:  BCF    2E.3
00A6:  MOVF   2E,W
00A7:  BSF    03.5
00A8:  MOVWF  07
00A9:  BCF    03.5
00AA:  BSF    07.3
....................    output_high(DAC_DI); 
00AB:  BCF    2E.5
00AC:  MOVF   2E,W
00AD:  BSF    03.5
00AE:  MOVWF  07
00AF:  BCF    03.5
00B0:  BSF    07.5
.................... } 
00B1:  BCF    0A.3
00B2:  GOTO   15F (RETURN)
....................  
.................... void write_dac(int16 data) { 
....................    BYTE cmd[3]; 
....................    BYTE i; 
....................  
....................    cmd[0]=data; 
*
00C7:  MOVF   3C,W
00C8:  MOVWF  3E
....................    cmd[1]=(data>>8); 
00C9:  MOVF   3D,W
00CA:  MOVWF  3F
....................    cmd[2]=0x03;                            
00CB:  MOVLW  03
00CC:  MOVWF  40
....................     
....................    output_high(DAC_LDAC); 
00CD:  BSF    03.5
00CE:  BCF    06.4
00CF:  BCF    03.5
00D0:  BSF    06.4
....................    output_low(DAC_CLK); 
00D1:  BCF    2E.3
00D2:  MOVF   2E,W
00D3:  BSF    03.5
00D4:  MOVWF  07
00D5:  BCF    03.5
00D6:  BCF    07.3
....................    output_low(DAC_CS); 
00D7:  BCF    2E.4
00D8:  MOVF   2E,W
00D9:  BSF    03.5
00DA:  MOVWF  07
00DB:  BCF    03.5
00DC:  BCF    07.4
....................  
....................    for(i=0; i<=23; ++i) 
00DD:  CLRF   41
00DE:  MOVF   41,W
00DF:  SUBLW  17
00E0:  BTFSS  03.0
00E1:  GOTO   10F
....................    { 
....................       if(i<4 || (i>7 && i<12)) 
00E2:  MOVF   41,W
00E3:  SUBLW  03
00E4:  BTFSC  03.0
00E5:  GOTO   0EE
00E6:  MOVF   41,W
00E7:  SUBLW  07
00E8:  BTFSC  03.0
00E9:  GOTO   0F3
00EA:  MOVF   41,W
00EB:  SUBLW  0B
00EC:  BTFSS  03.0
00ED:  GOTO   0F3
....................          shift_left(cmd,3,0); 
00EE:  BCF    03.0
00EF:  RLF    3E,F
00F0:  RLF    3F,F
00F1:  RLF    40,F
....................       else 
00F2:  GOTO   10D
....................       { 
....................          output_bit(DAC_DI, shift_left(cmd,3,0)); 
00F3:  BCF    03.0
00F4:  RLF    3E,F
00F5:  RLF    3F,F
00F6:  RLF    40,F
00F7:  BTFSC  03.0
00F8:  GOTO   0FB
00F9:  BCF    07.5
00FA:  GOTO   0FC
00FB:  BSF    07.5
00FC:  BCF    2E.5
00FD:  MOVF   2E,W
00FE:  BSF    03.5
00FF:  MOVWF  07
....................  
....................          output_high(DAC_CLK); 
0100:  BCF    03.5
0101:  BCF    2E.3
0102:  MOVF   2E,W
0103:  BSF    03.5
0104:  MOVWF  07
0105:  BCF    03.5
0106:  BSF    07.3
....................          output_low(DAC_CLK); 
0107:  BCF    2E.3
0108:  MOVF   2E,W
0109:  BSF    03.5
010A:  MOVWF  07
010B:  BCF    03.5
010C:  BCF    07.3
....................       } 
....................    } 
010D:  INCF   41,F
010E:  GOTO   0DE
....................    output_high(DAC_CS); 
010F:  BCF    2E.4
0110:  MOVF   2E,W
0111:  BSF    03.5
0112:  MOVWF  07
0113:  BCF    03.5
0114:  BSF    07.4
....................  
....................    output_low(DAC_LDAC); 
0115:  BSF    03.5
0116:  BCF    06.4
0117:  BCF    03.5
0118:  BCF    06.4
....................    delay_us(10); 
0119:  MOVLW  10
011A:  MOVWF  20
011B:  DECFSZ 20,F
011C:  GOTO   11B
011D:  NOP
....................     
....................    output_HIGH(DAC_LDAC); 
011E:  BSF    03.5
011F:  BCF    06.4
0120:  BCF    03.5
0121:  BSF    06.4
.................... } 
0122:  BCF    0A.3
0123:  GOTO   1A8 (RETURN)
....................  
....................  
....................  
....................  
.................... #define servo_pin PIN_B1  //Setting servo out pin to be hardware pin b1 
.................... /* 
.................... Clock Interrupt Settings 
....................  
.................... Number of operations per second is CLOCK/4/Timer Divisions 
.................... Number of operations per second is 20,000,000/4/2 = 2,500,000  
....................  
.................... Each operation takes 1/2,500,000 = 400 nano seconds 
....................  
.................... The period for the servo is .020 seconds which is 50,000 operations 
.................... The leftmost position of the server is .001 seconds which is 2,500 
.................... The rightmost position of the server is .002 seconds which is 5,000 
....................  
.................... */ 
.................... static int16 left_position = 2500; 
*
0135:  MOVLW  C4
0136:  MOVWF  2F
0137:  MOVLW  09
0138:  MOVWF  30
.................... static int16 right_position = 5000; 
0139:  MOVLW  88
013A:  MOVWF  31
013B:  MOVLW  13
013C:  MOVWF  32
.................... static int16 servo_period   = 65356-50000; 
013D:  MOVLW  FC
013E:  MOVWF  33
013F:  MOVLW  3B
0140:  MOVWF  34
....................  
.................... unsigned int16 current_servo_position=2500; 
0141:  MOVLW  C4
0142:  MOVWF  35
0143:  MOVLW  09
0144:  MOVWF  36
.................... int1 SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0; 
0145:  BCF    37.0
.................... int1 test_switch = 0; 
0146:  BCF    37.1
.................... unsigned int16 test_counter = 0; 
0147:  CLRF   38
0148:  CLRF   39
....................  
.................... #int_timer0 
.................... void timer0_isr(){ 
....................  
.................... test_counter++; 
*
0045:  INCF   38,F
0046:  BTFSC  03.2
0047:  INCF   39,F
.................... if (test_counter>100){ 
0048:  MOVF   39,F
0049:  BTFSS  03.2
004A:  GOTO   04F
004B:  MOVF   38,W
004C:  SUBLW  64
004D:  BTFSC  03.0
004E:  GOTO   05E
.................... test_counter=0; 
004F:  CLRF   39
0050:  CLRF   38
.................... if (test_switch){ 
0051:  BTFSS  37.1
0052:  GOTO   059
....................  output_high(PIN_B2);  
0053:  BSF    03.5
0054:  BCF    06.2
0055:  BCF    03.5
0056:  BSF    06.2
....................  test_switch = 0; 
0057:  BCF    37.1
.................... } 
.................... else{ 
0058:  GOTO   05E
....................  output_low(PIN_B2);  
0059:  BSF    03.5
005A:  BCF    06.2
005B:  BCF    03.5
005C:  BCF    06.2
....................  test_switch = 1; 
005D:  BSF    37.1
.................... } 
.................... } 
.................... } 
....................  
....................  
005E:  BCF    0B.2
005F:  BCF    0A.3
0060:  GOTO   02C
.................... #int_timer1 
.................... void isr() 
.................... { 
....................  
....................    if(SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER) 
0061:  BTFSS  37.0
0062:  GOTO   076
....................       {  
....................          output_high(servo_pin);                     //Set the servo control pin to high  
0063:  BSF    03.5
0064:  BCF    06.1
0065:  BCF    03.5
0066:  BSF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0;  
0067:  BCF    37.0
....................          set_timer1(65356-current_servo_position);                 //Set timer for the position high pulse 
0068:  MOVF   35,W
0069:  SUBLW  4C
006A:  MOVWF  42
006B:  MOVLW  FF
006C:  MOVWF  43
006D:  MOVF   36,W
006E:  BTFSS  03.0
006F:  INCFSZ 36,W
0070:  SUBWF  43,F
0071:  MOVF   43,W
0072:  MOVWF  0F
0073:  MOVF   42,W
0074:  MOVWF  0E
....................       }  
....................    else  
0075:  GOTO   088
....................       {  
....................          output_low(servo_pin);                      // Set the servo control pin to low   
0076:  BSF    03.5
0077:  BCF    06.1
0078:  BCF    03.5
0079:  BCF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 1;  
007A:  BSF    37.0
....................          set_timer1(servo_period+current_servo_position);          //Set timer for the low position the length is the difference between  
007B:  MOVF   35,W
007C:  ADDWF  33,W
007D:  MOVWF  42
007E:  MOVF   34,W
007F:  MOVWF  43
0080:  MOVF   36,W
0081:  BTFSC  03.0
0082:  INCFSZ 36,W
0083:  ADDWF  43,F
0084:  MOVF   43,W
0085:  MOVWF  0F
0086:  MOVF   42,W
0087:  MOVWF  0E
....................                                                      //the total int16 lenght - high pulse length 
....................       }   
....................  
.................... } 
....................  
....................  
....................  
0088:  BCF    0C.0
0089:  BCF    0A.3
008A:  GOTO   02C
.................... #int_ccp2 
.................... void isr2() 
.................... { 
....................  
.................... if (test_switch){ 
008B:  BTFSS  37.1
008C:  GOTO   093
....................  output_high(PIN_B2);  
008D:  BSF    03.5
008E:  BCF    06.2
008F:  BCF    03.5
0090:  BSF    06.2
....................  test_switch = 0; 
0091:  BCF    37.1
.................... } 
.................... else{ 
0092:  GOTO   098
....................  output_low(PIN_B2);  
0093:  BSF    03.5
0094:  BCF    06.2
0095:  BCF    03.5
0096:  BCF    06.2
....................  test_switch = 1; 
0097:  BSF    37.1
.................... } 
....................     
....................     
.................... } 
....................  
....................  
....................  
0098:  BCF    0D.0
0099:  BCF    0A.3
009A:  GOTO   02C
.................... void main() 
.................... {   
*
0124:  CLRF   04
0125:  MOVLW  1F
0126:  ANDWF  03,F
0127:  BSF    03.5
0128:  BCF    06.3
0129:  BCF    03.5
012A:  BSF    06.3
012B:  BSF    03.5
012C:  BSF    1F.0
012D:  BSF    1F.1
012E:  BSF    1F.2
012F:  BCF    1F.3
0130:  MOVLW  07
0131:  MOVWF  1C
....................     
....................    setup_adc_ports(NO_ANALOGS); 
*
0149:  BSF    03.5
014A:  BSF    1F.0
014B:  BSF    1F.1
014C:  BSF    1F.2
014D:  BCF    1F.3
....................    setup_adc(ADC_OFF); 
014E:  BCF    03.5
014F:  BCF    1F.0
....................    setup_spi(FALSE); 
0150:  CLRF   14
....................     
....................    //setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
....................    //setup_timer_1(T1_DISABLED); 
....................    //setup_timer_2(T2_DISABLED,0,1); 
....................    setup_port_a(ALL_ANALOG); 
0151:  BSF    03.5
0152:  BCF    1F.0
0153:  BCF    1F.1
0154:  BCF    1F.2
0155:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
0156:  BCF    1F.6
0157:  BCF    03.5
0158:  BSF    1F.6
0159:  BSF    1F.7
015A:  BSF    03.5
015B:  BSF    1F.7
015C:  BCF    03.5
015D:  BSF    1F.0
....................    init_dac(); 
015E:  GOTO   09B
....................   
....................    setup_timer_1(T1_DIV_BY_2| T1_INTERNAL);  
015F:  MOVLW  95
0160:  MOVWF  10
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_128); 
0161:  BSF    03.5
0162:  MOVF   01,W
0163:  ANDLW  C0
0164:  IORLW  06
0165:  MOVWF  01
....................    setup_ccp2(CCP_CAPTURE_RE);    // Configure CCP2 to capture fall 
0166:  BCF    03.5
0167:  BSF    2E.1
0168:  MOVF   2E,W
0169:  BSF    03.5
016A:  MOVWF  07
016B:  BCF    03.5
016C:  CLRF   1D
016D:  MOVLW  05
016E:  MOVWF  1D
....................    enable_interrupts(INT_CCP2);   // Setup interrupt on falling edge 
016F:  BSF    03.5
0170:  BSF    0D.0
....................    enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
0171:  BSF    0C.0
....................    enable_interrupts(INT_TIMER0); 
0172:  BCF    03.5
0173:  BSF    0B.5
....................    enable_interrupts(GLOBAL); 
0174:  MOVLW  C0
0175:  IORWF  0B,F
....................    while(TRUE) { 
....................    if (current_servo_position<left_position){ 
0176:  MOVF   36,W
0177:  SUBWF  30,W
0178:  BTFSS  03.0
0179:  GOTO   185
017A:  BTFSS  03.2
017B:  GOTO   180
017C:  MOVF   2F,W
017D:  SUBWF  35,W
017E:  BTFSC  03.0
017F:  GOTO   185
....................       current_servo_position = left_position; 
0180:  MOVF   30,W
0181:  MOVWF  36
0182:  MOVF   2F,W
0183:  MOVWF  35
....................    } 
....................    else if (current_servo_position > right_position){ 
0184:  GOTO   197
0185:  MOVF   32,W
0186:  SUBWF  36,W
0187:  BTFSS  03.0
0188:  GOTO   194
0189:  BTFSS  03.2
018A:  GOTO   18F
018B:  MOVF   35,W
018C:  SUBWF  31,W
018D:  BTFSC  03.0
018E:  GOTO   194
....................       current_servo_position = left_position; 
018F:  MOVF   30,W
0190:  MOVWF  36
0191:  MOVF   2F,W
0192:  MOVWF  35
....................    } 
....................    else { 
0193:  GOTO   197
....................       current_servo_position++; 
0194:  INCF   35,F
0195:  BTFSC  03.2
0196:  INCF   36,F
....................    } 
....................       //fprintf(MONITOR,"Hello"); 
....................       //left_adjust++; 
....................       //output_low(servo_pin); 
....................       delay_ms(10); 
0197:  MOVLW  0A
0198:  MOVWF  3A
0199:  GOTO   0B3
....................       //left_adjust--; 
....................       //delay_ms(1000); 
....................       //output_high(servo_pin); 
....................       //delay_ms(1000); 
....................       write_dac(current_servo_position-1000); 
019A:  MOVLW  E8
019B:  SUBWF  35,W
019C:  MOVWF  3A
019D:  MOVF   36,W
019E:  MOVWF  3B
019F:  MOVLW  03
01A0:  BTFSS  03.0
01A1:  MOVLW  04
01A2:  SUBWF  3B,F
01A3:  MOVF   3B,W
01A4:  MOVWF  3D
01A5:  MOVF   3A,W
01A6:  MOVWF  3C
01A7:  GOTO   0C7
....................    } 
01A8:  GOTO   176
....................     
....................  
.................... } 
....................  
....................  
....................  
01A9:  GOTO   1A9

Configuration Fuses:
   Word  1: 373A   HS NOWDT NOPUT DEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
