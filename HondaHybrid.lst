CCS PCM C Compiler, Version 4.084, 46530               29-Jun-13 14:45

               Filename: HondaHybrid.lst

               ROM used: 2191 words (53%)
                         Largest free fragment is 1437
               RAM used: 56 (29%) at main() level
                         103 (54%) worst case
               Stack:    3 worst case (2 in main + 1 for interrupts)

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  26
0008:  MOVF   7F,W
0009:  MOVWF  25
000A:  MOVF   0A,W
000B:  MOVWF  2D
000C:  CLRF   0A
000D:  SWAPF  25,F
000E:  MOVF   04,W
000F:  MOVWF  27
0010:  MOVF   20,W
0011:  MOVWF  28
0012:  MOVF   21,W
0013:  MOVWF  29
0014:  MOVF   22,W
0015:  MOVWF  2A
0016:  MOVF   23,W
0017:  MOVWF  2B
0018:  MOVF   24,W
0019:  MOVWF  2C
001A:  BCF    03.7
001B:  BCF    03.5
001C:  MOVLW  8C
001D:  MOVWF  04
001E:  BTFSS  00.0
001F:  GOTO   022
0020:  BTFSC  0C.0
0021:  GOTO   03F
0022:  MOVLW  8D
0023:  MOVWF  04
0024:  BTFSS  00.0
0025:  GOTO   028
0026:  BTFSC  0D.0
0027:  GOTO   041
0028:  BTFSS  0B.5
0029:  GOTO   02C
002A:  BTFSC  0B.2
002B:  GOTO   043
002C:  MOVF   27,W
002D:  MOVWF  04
002E:  MOVF   28,W
002F:  MOVWF  20
0030:  MOVF   29,W
0031:  MOVWF  21
0032:  MOVF   2A,W
0033:  MOVWF  22
0034:  MOVF   2B,W
0035:  MOVWF  23
0036:  MOVF   2C,W
0037:  MOVWF  24
0038:  MOVF   2D,W
0039:  MOVWF  0A
003A:  SWAPF  26,W
003B:  MOVWF  03
003C:  SWAPF  7F,F
003D:  SWAPF  7F,W
003E:  RETFIE
003F:  BCF    0A.3
0040:  GOTO   053
0041:  BCF    0A.3
0042:  GOTO   0AB
0043:  BCF    0A.3
0044:  GOTO   045
.................... //#define DEBUG 
.................... #include "HondaHybrid.h" 
.................... #include <16F873A.h> 
.................... //////// Standard Header file for the PIC16F873A device //////////////// 
.................... #device PIC16F873A 
.................... #list 
....................  
....................  
.................... #ifdef DEBUG 
....................    #device ICD=TRUE 
.................... #endif 
....................  
.................... #device adc=10 
.................... #use delay(clock=20000000) 
*
022B:  MOVLW  54
022C:  MOVWF  04
022D:  MOVF   00,W
022E:  BTFSC  03.2
022F:  GOTO   23D
0230:  MOVLW  06
0231:  MOVWF  21
0232:  CLRF   20
0233:  DECFSZ 20,F
0234:  GOTO   233
0235:  DECFSZ 21,F
0236:  GOTO   232
0237:  MOVLW  7B
0238:  MOVWF  20
0239:  DECFSZ 20,F
023A:  GOTO   239
023B:  DECFSZ 00,F
023C:  GOTO   230
023D:  RETLW  00
.................... #ifdef DEBUG 
....................    #use rs232 (DEBUGGER) 
.................... #endif 
.................... #fuses HS,PUT,NOWDT 
.................... #include <mcp4921.c> 
.................... //////////////// Driver for MCP4921 D/A Converter /////////////////////// 
.................... ////                                                                 //// 
.................... ////  init_dac()    Call this before using a MCP4921 DAC             //// 
.................... ////                                                                 //// 
.................... ////  write_dac( long int )   Writes command and 12 bit resolution   //// 
.................... ////                          to the MCP4921 which converts it to a  //// 
.................... ////                          voltage                                //// 
.................... ////                          0-4095 input represents 0-vref V out.  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SELECT 
....................  
.................... #define DAC_CS     PIN_C4 
.................... #define DAC_CLK    PIN_C3 
.................... #define DAC_DI     PIN_C5 
.................... #define DAC_LDAC   PIN_B5 
....................  
.................... #endif 
....................  
.................... void init_dac() 
.................... { 
....................    output_high(DAC_CS); 
*
00C8:  BCF    2E.4
00C9:  MOVF   2E,W
00CA:  BSF    03.5
00CB:  MOVWF  07
00CC:  BCF    03.5
00CD:  BSF    07.4
....................    output_high(DAC_LDAC); 
00CE:  BSF    03.5
00CF:  BCF    06.5
00D0:  BCF    03.5
00D1:  BSF    06.5
....................    output_high(DAC_CLK); 
00D2:  BCF    2E.3
00D3:  MOVF   2E,W
00D4:  BSF    03.5
00D5:  MOVWF  07
00D6:  BCF    03.5
00D7:  BSF    07.3
....................    output_high(DAC_DI); 
00D8:  BCF    2E.5
00D9:  MOVF   2E,W
00DA:  BSF    03.5
00DB:  MOVWF  07
00DC:  BCF    03.5
00DD:  BSF    07.5
.................... } 
00DE:  BSF    0A.3
00DF:  GOTO   047 (RETURN)
....................  
.................... void write_dac(int16 data) { 
....................    BYTE cmd[3]; 
....................    BYTE i; 
....................  
....................    cmd[0]=data; 
00E0:  MOVF   57,W
00E1:  MOVWF  59
....................    cmd[1]=(data>>8); 
00E2:  MOVF   58,W
00E3:  MOVWF  5A
....................    cmd[2]=0x03;                            
00E4:  MOVLW  03
00E5:  MOVWF  5B
....................     
....................    output_high(DAC_LDAC); 
00E6:  BSF    03.5
00E7:  BCF    06.5
00E8:  BCF    03.5
00E9:  BSF    06.5
....................    output_low(DAC_CLK); 
00EA:  BCF    2E.3
00EB:  MOVF   2E,W
00EC:  BSF    03.5
00ED:  MOVWF  07
00EE:  BCF    03.5
00EF:  BCF    07.3
....................    output_low(DAC_CS); 
00F0:  BCF    2E.4
00F1:  MOVF   2E,W
00F2:  BSF    03.5
00F3:  MOVWF  07
00F4:  BCF    03.5
00F5:  BCF    07.4
....................  
....................    for(i=0; i<=23; ++i) 
00F6:  CLRF   5C
00F7:  MOVF   5C,W
00F8:  SUBLW  17
00F9:  BTFSS  03.0
00FA:  GOTO   128
....................    { 
....................       if(i<4 || (i>7 && i<12)) 
00FB:  MOVF   5C,W
00FC:  SUBLW  03
00FD:  BTFSC  03.0
00FE:  GOTO   107
00FF:  MOVF   5C,W
0100:  SUBLW  07
0101:  BTFSC  03.0
0102:  GOTO   10C
0103:  MOVF   5C,W
0104:  SUBLW  0B
0105:  BTFSS  03.0
0106:  GOTO   10C
....................          shift_left(cmd,3,0); 
0107:  BCF    03.0
0108:  RLF    59,F
0109:  RLF    5A,F
010A:  RLF    5B,F
....................       else 
010B:  GOTO   126
....................       { 
....................          output_bit(DAC_DI, shift_left(cmd,3,0)); 
010C:  BCF    03.0
010D:  RLF    59,F
010E:  RLF    5A,F
010F:  RLF    5B,F
0110:  BTFSC  03.0
0111:  GOTO   114
0112:  BCF    07.5
0113:  GOTO   115
0114:  BSF    07.5
0115:  BCF    2E.5
0116:  MOVF   2E,W
0117:  BSF    03.5
0118:  MOVWF  07
....................  
....................          output_high(DAC_CLK); 
0119:  BCF    03.5
011A:  BCF    2E.3
011B:  MOVF   2E,W
011C:  BSF    03.5
011D:  MOVWF  07
011E:  BCF    03.5
011F:  BSF    07.3
....................          output_low(DAC_CLK); 
0120:  BCF    2E.3
0121:  MOVF   2E,W
0122:  BSF    03.5
0123:  MOVWF  07
0124:  BCF    03.5
0125:  BCF    07.3
....................       } 
....................    } 
0126:  INCF   5C,F
0127:  GOTO   0F7
....................    output_high(DAC_CS); 
0128:  BCF    2E.4
0129:  MOVF   2E,W
012A:  BSF    03.5
012B:  MOVWF  07
012C:  BCF    03.5
012D:  BSF    07.4
....................  
....................    output_low(DAC_LDAC); 
012E:  BSF    03.5
012F:  BCF    06.5
0130:  BCF    03.5
0131:  BCF    06.5
....................    delay_us(10); 
0132:  MOVLW  10
0133:  MOVWF  20
0134:  DECFSZ 20,F
0135:  GOTO   134
0136:  NOP
....................     
....................    output_HIGH(DAC_LDAC); 
0137:  BSF    03.5
0138:  BCF    06.5
0139:  BCF    03.5
013A:  BSF    06.5
.................... } 
013B:  RETLW  00
....................  
....................  
....................  
.................... #include "pid.h" 
.................... /*This file has been prepared for Doxygen automatic documentation generation.*/ 
.................... /*! \file ********************************************************************* 
....................  * 
....................  * \brief Header file for pid.c. 
....................  * 
....................  * - File:               pid.h 
....................  * - Compiler:           IAR EWAAVR 4.11A 
....................  * - Supported devices:  All AVR devices can be used. 
....................  * - AppNote:            AVR221 - Discrete PID controller 
....................  * 
....................  * \author               Atmel Corporation: http://www.atmel.com \n 
....................  *                       Support email: avr@atmel.com 
....................  * 
....................  * $Name$ 
....................  * $Revision: 456 $ 
....................  * $RCSfile$ 
....................  * $Date: 2006-02-16 12:46:13 +0100 (to, 16 feb 2006) $ 
....................  *****************************************************************************/ 
....................  
.................... #ifndef PID_H 
.................... #define PID_H 
....................  
.................... //#include "stdint.h" 
.................... #define INT16_MAX 32767 
.................... #define INT32_MAX 2147483647 
.................... #define SCALING_FACTOR  128 
....................  
.................... /*! \brief PID Status 
....................  * 
....................  * Setpoints and data used by the PID control algorithm 
....................  */ 
.................... typedef struct PID_DATA{ 
....................   //! Last process value, used to find derivative of process value. 
....................   int16 lastProcessValue; 
....................   //! Summation of errors, used for integrate calculations 
....................   int32 sumError; 
....................   //! The Proportional tuning constant, multiplied with SCALING_FACTOR 
....................   int16 P_Factor; 
....................   //! The Integral tuning constant, multiplied with SCALING_FACTOR 
....................   int16 I_Factor; 
....................   //! The Derivative tuning constant, multiplied with SCALING_FACTOR 
....................   int16 D_Factor; 
....................   //! Maximum allowed error, avoid overflow 
....................   int16 maxError; 
....................   //! Maximum allowed sumerror, avoid overflow 
....................   int32 maxSumError; 
.................... } pidData_t; 
....................  
.................... /*! \brief Maximum values 
....................  * 
....................  * Needed to avoid sign/overflow problems 
....................  */ 
.................... // Maximum value of variables 
.................... #define MAX_INT         INT16_MAX 
.................... #define MAX_LONG        INT32_MAX 
.................... #define MAX_I_TERM      (MAX_LONG / 2) 
....................  
.................... // Boolean values 
.................... //#define FALSE           0 
.................... //#define TRUE            1 
....................  
.................... boolean checkRunnaway(struct PID_DATA *pid); 
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid); 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st); 
.................... void pid_Reset_Integrator(pidData_t *pid_st); 
....................  
.................... #endif 
....................  
.................... /* 
.................... This is the main controller for the super capacitor hybrid scooter a.k.a RED 
.................... B2 close contactor 
.................... CONTROL BOX INPUTS 
.................... Athrottle- A0 - analog input representing the users input for speed, 10 bit 
.................... Vspeed - CCp2-a 16 bit representation of the speed of the vehicle 
.................... Acaps- A1 - analog input representing the current voltage of the supercapacitors, 10 bit 
.................... There are 18 Supercaps with a maximum voltage of 2.7 (2.85 is breakdown) volts for a total of 48.6 V 
.................... The circuit has a 10/110 voltage divider into the ADC. So minimum voltage of 18 Volts is 335 and 48 Volts is 893. Measured 38.2V equal to 726 
....................  
.................... CONTROL BOX OUTPUT 
.................... ICEthrottle- B1 - a 16 bit number sent to the internal combustion engine(ICE) throttle  
.................... ELECthrottle-  - a 16 bit number sent as analog value representing the demanded electric power 
....................  
.................... SPECIFICS OF I/O 
....................  
.................... Athrottle - the electric throttle is a 3 wire unit with a 5 volt,ground, and analog out 
....................    representing how far throttle is turned. Pin AN0 is the input. 
....................     
.................... Vspeed - There is a encoder in the rear wheel/electric motor that is used by the electric 
....................    power controller. Tapping in to this this Main Controller receives a 5 Volt square wave 
....................    with 42 pulses. There are two options for measuring speed. The first is to measure the  
....................    length of the pulses. The second is to measure the rate of pulses. This controller currently 
....................    uses the rate method. The int_ccp2 interupt is called on each falling edge and stores the  
....................    Vspeed value as the max number of 16bit (65535-timer0_since_last_reset).  
....................     
....................    The RED scooter has a circumpherence of 16.3*2*pi = 102.4 
....................    X m/h * 63360 inch/mile * 1/3600 h/sec * 1/(102.4 inch/rev) = .171875* X 
....................    Examples 50 mph is 8.9 ms 1 overflow of timer0 
....................    Example 5 mph is 89 ms or 13 time overflow 
....................     
....................    #int_timer0 increments the counter number_of_overflows each time it overflows 
....................    On int ccp2 we multiply number_of_overflows * 256 + timer0 to get timer0_since_last_reset 
....................     
.................... Acaps - the analog voltage which is the 5volt representation of the voltage in the caps which 
....................    have a value of between 0-48v. The voltages are factored so that the voltage on AN1 goes 
....................    from 0 - 4.8 volts (TODO check this factor, think its 1/11 not 1/10) 
....................     
.................... ICEthrottle -  #int_timer1 is set to make sure the period follows the required below 
....................    The period for the servo is .020 seconds which is 50,000 operations 
....................    The leftmost position of the server is .001 seconds which is 2,500 
....................    The rightmost position of the server is .002 seconds which is 5,000 
....................     
....................    The output pin is pin_B1.-> 
....................  
.................... ELECthrottle 
....................    The electric power controller takes an analog voltage as input. The output voltage 
....................    is set by the DAC. The pins used are C3,C4,C5. if CHARGING_STATE is true then  
....................     
.................... ALGORITHM 
....................    The algorithm is basically a PID controller. In broad terms we are trying to set the 
....................    ICEthrottle and ICEelectric to maximize the use of electric and accelerate to meet the 
....................    requirements set by the rider with the Athrottle signal. When the demanded power is  
....................    less than the power output possible by the ICE and the caps are in the CHARGING_STATE  
....................    then the ICE is turned up to the max and the ELECthrottle is set to regen to 
....................    charge the capacitors.If CHARGING_STATE is false then the caps are supplying the drivig power 
....................    and the ICE is set to "off", the caps supply the power. Unless the user requested supply 
....................    is enough to require both power sources. 
....................     
....................    If CHARGING_STATE is true. Then pin_b2 is set as high which will close the brake number 
....................    for the electric power controller.  
....................     
....................    If CHARGING_STATE is false then the pin_b2 is set low which opens brake. 
....................     
....................     
....................  
....................  
.................... The encoder has 42 on and offs per rotation, i.e. 21 steps 
....................  
.................... Number of operations per second is CLOCK/4/Timer Divisions 
.................... Number of operations per second is 20,000,000/4/128 = 39062.5  
.................... Each operation takes 1/39062.5 = .256 micro (x10^-6) seconds 
.................... Seconds to Overflow timer0 8bit timer = .256x10^-6 * 256 = 6.55ms 
....................  
....................  
....................  
.................... */ 
.................... #define servo_pin PIN_B1  //Setting servo out pin to be hardware pin b1 
.................... #define brake_pin PIN_B4 
.................... #define ADC_DELAY delay_us(20) 
.................... #define Acaps_pin PIN_A1 
.................... #define Acaps_channel 1 
.................... #define Athrottle_pin PIN_A0  //Voltage goes from 1.5 (306)to 4.1(836) 
.................... #define Athrottle_Min 316 
.................... #define Athrottle_Max 860 
.................... #define Athrottle_Full Athrottle_Max-Athrottle_Min 
.................... #define Athrottle_channel 0 
.................... #define Electric_Controller_Switch PIN_B0 
.................... #define Contactor_Switch PIN_B2 
.................... #define A_CAPS_MAX 725//893 
.................... #define A_CAPS_MIN 335 
.................... #define A_CAPS_MID_LOW (A_CAPS_MIN + 100) //This is the low end of the middle ACaps range. The range in which discharge and charge are allowed.  
.................... #define A_CAPS_MID_HIGH (A_CAPS_MAX - 100) //This is the low end of the middle ACaps range. The range in which discharge and charge are allowed.  
.................... #define V_SPEED_REGEN_MIN 50 //Why is there a minimum speed? Because below this no regenerative action is possible with electric motor 
.................... #define INSUFFICIENT_BRAKING_RUNNAWAY_ERROR 50000 
....................  
.................... //PID Values 
.................... #define K_P 0.80 
.................... #define K_I 0.00 
.................... #define K_D 0.00 
....................  
.................... struct PID_DATA pidData; 
.................... #define TIME_INTERVAL 157 //TODO replace 
....................  
.................... #define left_position 3500//4450 
.................... #define right_position 5300 
.................... #define servo_difference  right_position-left_position 
.................... #define servo_difference_div 5200 
.................... #define ELEC_CONTROLLER_OFFSET 900 
.................... //const float Athrottle_servo_factor = ((float) servo_difference)/((float) Athrottle_FULL); 
.................... #define servo_period   65356-50000 
.................... unsigned int16 current_servo_position=right_position; 
*
080D:  MOVLW  B4
080E:  MOVWF  41
080F:  MOVLW  14
0810:  MOVWF  42
.................... int1 SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0; 
0811:  BCF    43.0
....................  
.................... unsigned int16 number_of_timer0_interupts_since_reset =0; 
0812:  CLRF   44
0813:  CLRF   45
.................... unsigned int16 vSpeed= 0; 
0814:  CLRF   46
0815:  CLRF   47
.................... signed int16 ELECthrottle = 0; 
0816:  CLRF   48
0817:  CLRF   49
.................... unsigned int16 ICEthrottle = 0; 
0818:  CLRF   4A
0819:  CLRF   4B
.................... unsigned int16 Athrottle = 0; 
081A:  CLRF   4C
081B:  CLRF   4D
.................... unsigned int16 Acaps = 0; 
081C:  CLRF   4E
081D:  CLRF   4F
.................... int1 ICE_ON = 0; 
081E:  BCF    43.1
.................... int1 CURRENTLY_CHARGING = 0; 
081F:  BCF    43.2
.................... int1 RUNNAWAY_CHECK = 0; 
0820:  BCF    43.3
.................... signed int16 returnedValue =0;  
0821:  CLRF   50
0822:  CLRF   51
....................  
.................... enum{  
....................    EVERYTHING_OFF, 
....................    SPEED_TO_LOW_ICE_DIRECT, 
....................    CHARGING_ALLOWED,  
....................    DISCHARGING_ALLOWED,  
....................    CHARGING_AND_DISCHARING_ALLOWED, 
....................    INSUFFICIENT_BRAKING_RUNAWAY, 
....................    USER_INPUT_OFF 
.................... } CHARGING_STATE;  
....................  
.................... /* 
.................... The #int_timer0 interupt is triggered on each timer0 8bit interupt 
.................... the function simply increments a overflow counter to be used by the ccp2 
.................... interupt to calculate speed 
.................... NUMBER OF OPERATIONS =  
.................... */ 
.................... #int_timer0 
.................... void timer0_isr(){ 
....................     
....................       number_of_timer0_interupts_since_reset=number_of_timer0_interupts_since_reset+256; 
*
0045:  MOVLW  01
0046:  ADDWF  45,F
....................       //current_servo_position=current_servo_position+1; 
....................        
....................     
....................    if (number_of_timer0_interupts_since_reset>=1024){ 
0047:  MOVF   45,W
0048:  SUBLW  03
0049:  BTFSC  03.0
004A:  GOTO   050
....................       vSpeed = 0; 
004B:  CLRF   47
004C:  CLRF   46
....................       number_of_timer0_interupts_since_reset=1024; 
004D:  MOVLW  04
004E:  MOVWF  45
004F:  CLRF   44
....................        
....................        
....................    } 
.................... } 
....................  
.................... /* 
.................... #int_timer1 is used by the ICEservo throttle to regulate the timing pulses. The  
.................... timer is setup for a pulsetrain of 20ms period. This is done as follows, 
....................  
.................... Period is 1/(CLOCK/4opsperclock)*(startingPostionOfClock) = 20 ms 
.................... for this setup 1/(20000000/4)*(50000) = 20 ms 
....................  
.................... The timer1 starts at 0 and counts up. So we set the beggining of the clock at 
.................... servo_period which is 65356-50000 so that the total time is 20ms. 
.................... */ 
0050:  BCF    0B.2
0051:  BCF    0A.3
0052:  GOTO   02C
.................... #int_timer1 
.................... void isr() 
.................... { 
....................  
.................... //Make sure that the position is within the left and right positions of the servo 
....................    if (current_servo_position<left_position){ 
0053:  MOVF   42,W
0054:  SUBLW  0D
0055:  BTFSS  03.0
0056:  GOTO   062
0057:  BTFSS  03.2
0058:  GOTO   05D
0059:  MOVF   41,W
005A:  SUBLW  AB
005B:  BTFSS  03.0
005C:  GOTO   062
....................       current_servo_position = left_position; 
005D:  MOVLW  0D
005E:  MOVWF  42
005F:  MOVLW  AC
0060:  MOVWF  41
....................    } 
....................    else if (current_servo_position > right_position){ 
0061:  GOTO   071
0062:  MOVF   42,W
0063:  SUBLW  13
0064:  BTFSC  03.0
0065:  GOTO   071
0066:  XORLW  FF
0067:  BTFSS  03.2
0068:  GOTO   06D
0069:  MOVF   41,W
006A:  SUBLW  B4
006B:  BTFSC  03.0
006C:  GOTO   071
....................       current_servo_position = right_position; 
006D:  MOVLW  14
006E:  MOVWF  42
006F:  MOVLW  B4
0070:  MOVWF  41
....................    } 
.................... //printf("Current servo position %ld",current_servo_position); 
....................    if(SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER) 
0071:  BTFSS  43.0
0072:  GOTO   090
....................       {  
....................          output_high(servo_pin);        //Set the servo control pin to high  
0073:  BSF    03.5
0074:  BCF    06.1
0075:  BCF    03.5
0076:  BSF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0;  
0077:  BCF    43.0
....................          set_timer1(65356-current_servo_position); //Set timer for the position high pulse 
0078:  MOVF   41,W
0079:  SUBLW  4C
007A:  BSF    03.5
007B:  MOVWF  25
007C:  MOVLW  FF
007D:  MOVWF  26
007E:  BCF    03.5
007F:  MOVF   42,W
0080:  BTFSS  03.0
0081:  INCFSZ 42,W
0082:  GOTO   084
0083:  GOTO   087
0084:  BSF    03.5
0085:  SUBWF  26,F
0086:  BCF    03.5
0087:  BSF    03.5
0088:  MOVF   26,W
0089:  BCF    03.5
008A:  MOVWF  0F
008B:  BSF    03.5
008C:  MOVF   25,W
008D:  BCF    03.5
008E:  MOVWF  0E
....................       }  
....................    else  
008F:  GOTO   0A8
....................       {  
....................          output_low(servo_pin);                      // Set the servo control pin to low   
0090:  BSF    03.5
0091:  BCF    06.1
0092:  BCF    03.5
0093:  BCF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 1;  
0094:  BSF    43.0
....................          set_timer1(servo_period+current_servo_position);          //Set timer for the low position the length is the difference between  
0095:  MOVLW  FC
0096:  ADDWF  41,W
0097:  BSF    03.5
0098:  MOVWF  25
0099:  BCF    03.5
009A:  MOVF   42,W
009B:  BSF    03.5
009C:  MOVWF  26
009D:  MOVLW  3B
009E:  BTFSC  03.0
009F:  MOVLW  3C
00A0:  ADDWF  26,F
00A1:  MOVF   26,W
00A2:  BCF    03.5
00A3:  MOVWF  0F
00A4:  BSF    03.5
00A5:  MOVF   25,W
00A6:  BCF    03.5
00A7:  MOVWF  0E
....................                                                      //the total int16 lenght - high pulse length 
....................       }   
....................  
.................... } 
....................  
....................  
.................... /* 
.................... #int_ccp2 is called on the falling edge of the encoder pulse. We calculate the time 
.................... between pulses.  
.................... TODO will have to put some kind of smoothing mechanism 
.................... */ 
00A8:  BCF    0C.0
00A9:  BCF    0A.3
00AA:  GOTO   02C
.................... #int_ccp2 
.................... void isr2() 
.................... { 
.................... if (number_of_timer0_interupts_since_reset>10){ 
00AB:  MOVF   45,F
00AC:  BTFSS  03.2
00AD:  GOTO   0B2
00AE:  MOVF   44,W
00AF:  SUBLW  0A
00B0:  BTFSC  03.0
00B1:  GOTO   0C5
.................... vSpeed  = 1280 - (number_of_timer0_interupts_since_reset+get_timer0()); 
00B2:  MOVF   01,W
00B3:  ADDWF  44,W
00B4:  MOVWF  21
00B5:  MOVF   45,W
00B6:  MOVWF  23
00B7:  BTFSC  03.0
00B8:  INCF   23,F
00B9:  MOVF   21,W
00BA:  SUBLW  00
00BB:  MOVWF  46
00BC:  MOVLW  05
00BD:  MOVWF  47
00BE:  MOVF   23,W
00BF:  BTFSS  03.0
00C0:  INCFSZ 23,W
00C1:  SUBWF  47,F
.................... //vSpeed  = -(get_timer0()); 
.................... set_timer0(0); 
00C2:  CLRF   01
.................... number_of_timer0_interupts_since_reset = 0; 
00C3:  CLRF   45
00C4:  CLRF   44
.................... } 
.................... } 
....................  
00C5:  BCF    0D.0
00C6:  BCF    0A.3
00C7:  GOTO   02C
.................... void trickBreaking(){ 
.................... write_dac((unsigned int16) 400+ELEC_CONTROLLER_OFFSET); 
*
061E:  MOVLW  05
061F:  MOVWF  58
0620:  MOVLW  14
0621:  MOVWF  57
0622:  CALL   0E0
.................... delay_ms(500);       
0623:  MOVLW  02
0624:  MOVWF  53
0625:  MOVLW  FA
0626:  MOVWF  54
0627:  CALL   22B
0628:  DECFSZ 53,F
0629:  GOTO   625
.................... } 
062A:  BSF    0A.3
062B:  GOTO   1EC (RETURN)
....................  
.................... void printfLogf(char string){ 
....................    #ifdef DEBUG 
....................       printf("IN PrintfLog"); 
....................       printf("%c",string); 
....................    #else 
....................       delay_ms(250); 
....................    #endif 
.................... } 
....................  
.................... #ifdef TEST 
....................  
.................... /* 
.................... TEST SUITE 
.................... */ 
....................  
.................... void createHeartbeat(){ 
....................   //This creates a heartbeat on pin B1 
....................   while (1){ 
....................            output_high(servo_pin);        //Set the servo control pin to high 
....................            delay_ms(1000); 
....................            output_low(servo_pin); 
....................            delay_ms(1000); 
....................     } 
.................... } 
....................  
.................... void wiperAnalogVoltage(){ 
....................   
....................  //signed int16 test =0; 
....................  unsigned int16 wiperValue = 0; 
....................     while (1){ 
.................... printf("Wiper Value is now %ld",wiperValue); 
....................    
....................   if (wiperValue>(4095)){ 
....................      wiperValue = 0; 
....................     printf("Wiper Value is now %ld",wiperValue); 
....................   } 
....................   wiperValue=wiperValue+10; 
....................   write_dac(wiperValue); 
....................   delay_ms(10); 
....................     } 
.................... } 
....................  
.................... void heartbeatElectricControllerPower(){ 
....................     while (1){ 
....................  
....................   output_high(Contactor_Switch);        //Set the servo control pin to high 
....................            delay_ms(1000); 
....................            output_low(Contactor_Switch); 
....................            delay_ms(1000); 
....................     } 
.................... } 
....................  
.................... void wiperServo(){ 
....................     while (1){ 
....................  
....................   unsigned int16 wiperValue = servo_difference; 
....................   current_servo_position =right_position-wiperValue; 
....................   wiperValue--; 
....................   if (wiperValue<0){ 
....................     wiperValue = servo_difference; 
....................   } 
....................   delay_ms(10); 
....................     } 
.................... } 
....................  
.................... void printAnalogThrottleInput(){ 
....................     set_adc_channel(Athrottle_channel); 
....................       ADC_DELAY; 
....................       Athrottle = read_adc(); 
....................   printf("Analog Throttle is %ld",Athrottle ); 
.................... } 
....................  
.................... void main() 
.................... { 
....................  
....................    setup_adc_ports(NO_ANALOGS); 
....................    setup_adc(ADC_OFF); 
....................    setup_spi(FALSE); 
....................  
....................    setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
....................    setup_timer_1(T1_DISABLED); 
....................    setup_timer_2(T2_DISABLED,0,1); 
....................    setup_port_a(ALL_ANALOG); 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
....................  
....................    init_dac(); 
....................  
....................    setup_timer_1(T1_DIV_BY_2| T1_INTERNAL); 
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_128); 
....................    setup_ccp2(CCP_CAPTURE_RE);    // Configure CCP2 to capture fall 
....................    enable_interrupts(INT_CCP2);   // Setup interrupt on falling edge 
....................    enable_interrupts(INT_TIMER0); 
....................    enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
....................    enable_interrupts(GLOBAL); 
....................  
....................    while(TRUE) { 
....................         //Test Breaking Analog Voltage. Should produce analog voltage  on pin 13 as well as drive pin 12 LOW 
....................         //output_high(brake_pin); 
....................         //output_high(Electric_Controller_Switch); 
....................         //wiperAnalogVoltage(); 
....................  
....................         //Test Accelerating Analog Voltage. Should produce analog voltage on pin 15 and let pin 12 float. 
....................         //output_low(brake_pin); 
....................         //output_low(Electric_Controller_Switch); 
....................         //wiperAnalogVoltage(); 
....................          
....................         //Test Short Circuit from Pin 11 to pin 8 with 1 second heartbeat. This tests V+ Controller. Also pin 9 should be heartbeating between 0 and 12V 
....................         //heartbeatElectricControllerPower(); 
....................  
....................         //Test Wiper of Servo 
....................         //wiperServo(); 
....................  
....................        //printAnalogThrottleInput(); 
....................         
....................        //Test Electric Controller Out 
....................        output_high(Contactor_Switch); 
....................        output_high(Contactor_Switch2); 
....................  
....................    } 
....................  
....................  
.................... } 
....................  
....................  
....................  
.................... #else 
.................... void main() 
.................... {   
*
0800:  CLRF   04
0801:  MOVLW  1F
0802:  ANDWF  03,F
0803:  BSF    03.5
0804:  BSF    1F.0
0805:  BSF    1F.1
0806:  BSF    1F.2
0807:  BCF    1F.3
0808:  MOVLW  07
0809:  MOVWF  1C
....................     
....................    setup_adc_ports(NO_ANALOGS); 
*
0823:  BSF    03.5
0824:  BSF    1F.0
0825:  BSF    1F.1
0826:  BSF    1F.2
0827:  BCF    1F.3
....................    setup_adc(ADC_OFF); 
0828:  BCF    03.5
0829:  BCF    1F.0
....................    setup_spi(FALSE); 
082A:  CLRF   14
....................     
....................    setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
082B:  BSF    03.5
082C:  MOVF   01,W
082D:  ANDLW  C0
082E:  IORLW  00
082F:  MOVWF  01
0830:  CLRWDT
....................    setup_timer_1(T1_DISABLED); 
0831:  BCF    03.5
0832:  CLRF   10
....................    setup_timer_2(T2_DISABLED,0,1); 
0833:  MOVLW  00
0834:  MOVWF  21
0835:  MOVWF  12
0836:  MOVLW  00
0837:  BSF    03.5
0838:  MOVWF  12
....................    setup_port_a(ALL_ANALOG); 
0839:  BCF    1F.0
083A:  BCF    1F.1
083B:  BCF    1F.2
083C:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
083D:  BCF    1F.6
083E:  BCF    03.5
083F:  BSF    1F.6
0840:  BSF    1F.7
0841:  BSF    03.5
0842:  BSF    1F.7
0843:  BCF    03.5
0844:  BSF    1F.0
....................     
....................    init_dac(); 
0845:  BCF    0A.3
0846:  GOTO   0C8
0847:  BSF    0A.3
....................   
....................    setup_timer_1(T1_DIV_BY_2| T1_INTERNAL);  
0848:  MOVLW  95
0849:  MOVWF  10
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_128); 
084A:  BSF    03.5
084B:  MOVF   01,W
084C:  ANDLW  C0
084D:  IORLW  06
084E:  MOVWF  01
....................    setup_ccp2(CCP_CAPTURE_RE);    // Configure CCP2 to capture fall 
084F:  BCF    03.5
0850:  BSF    2E.1
0851:  MOVF   2E,W
0852:  BSF    03.5
0853:  MOVWF  07
0854:  BCF    03.5
0855:  CLRF   1D
0856:  MOVLW  05
0857:  MOVWF  1D
....................    enable_interrupts(INT_CCP2);   // Setup interrupt on falling edge 
0858:  BSF    03.5
0859:  BSF    0D.0
....................    enable_interrupts(INT_TIMER0); 
085A:  BCF    03.5
085B:  BSF    0B.5
....................    enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
085C:  BSF    03.5
085D:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
085E:  MOVLW  C0
085F:  BCF    03.5
0860:  IORWF  0B,F
....................     
....................    CHARGING_STATE = EVERYTHING_OFF; 
0861:  CLRF   52
....................    output_low(Electric_Controller_Switch); 
0862:  BSF    03.5
0863:  BCF    06.0
0864:  BCF    03.5
0865:  BCF    06.0
....................    write_dac(0); 
0866:  CLRF   58
0867:  CLRF   57
0868:  BCF    0A.3
0869:  CALL   0E0
086A:  BSF    0A.3
....................    ICE_ON=TRUE; 
086B:  BSF    43.1
....................    output_high(Contactor_Switch); 
086C:  BSF    03.5
086D:  BCF    06.2
086E:  BCF    03.5
086F:  BSF    06.2
....................    output_low(brake_pin); 
0870:  BSF    03.5
0871:  BCF    06.4
0872:  BCF    03.5
0873:  BCF    06.4
....................    pid_Init(K_P*SCALING_FACTOR,K_I*SCALING_FACTOR,K_D*SCALING_FACTOR, & pidData); 
0874:  CLRF   54
0875:  MOVLW  66
0876:  MOVWF  53
0877:  CLRF   56
0878:  CLRF   55
0879:  CLRF   58
087A:  CLRF   57
087B:  MOVLW  2F
087C:  MOVWF  59
087D:  BCF    0A.3
087E:  GOTO   13C
087F:  BSF    0A.3
....................    delay_ms(3000); 
0880:  MOVLW  0C
0881:  MOVWF  53
0882:  MOVLW  FA
0883:  MOVWF  54
0884:  BCF    0A.3
0885:  CALL   22B
0886:  BSF    0A.3
0887:  DECFSZ 53,F
0888:  GOTO   082
....................    current_servo_position =right_position-800; 
0889:  MOVLW  11
088A:  MOVWF  42
088B:  MOVLW  94
088C:  MOVWF  41
....................    delay_ms(2000); 
088D:  MOVLW  08
088E:  MOVWF  53
088F:  MOVLW  FA
0890:  MOVWF  54
0891:  BCF    0A.3
0892:  CALL   22B
0893:  BSF    0A.3
0894:  DECFSZ 53,F
0895:  GOTO   08F
....................    current_servo_position =right_position; 
0896:  MOVLW  14
0897:  MOVWF  42
0898:  MOVLW  B4
0899:  MOVWF  41
....................    //write_dac(1000); 
....................    //delay_ms(10000); 
....................    //output_high(Contactor_Switch); 
....................    //output_high(brake_pin); 
....................    //output_high(Electric_Controller_Switch); 
....................    while(TRUE) { 
....................        
....................       //GET INPUTS 
....................       //Vspeedhappens in interrupts 
....................        
....................       set_adc_channel(Acaps_channel); 
089A:  MOVLW  08
089B:  MOVWF  21
089C:  MOVF   1F,W
089D:  ANDLW  C7
089E:  IORWF  21,W
089F:  MOVWF  1F
....................       ADC_DELAY; 
08A0:  MOVLW  21
08A1:  MOVWF  20
08A2:  DECFSZ 20,F
08A3:  GOTO   0A2
....................       Acaps = read_adc(); 
08A4:  BSF    1F.2
08A5:  BTFSC  1F.2
08A6:  GOTO   0A5
08A7:  BSF    03.5
08A8:  MOVF   1E,W
08A9:  BCF    03.5
08AA:  MOVWF  4E
08AB:  MOVF   1E,W
08AC:  MOVWF  4F
....................        
....................       set_adc_channel(Athrottle_channel); 
08AD:  MOVLW  00
08AE:  MOVWF  21
08AF:  MOVF   1F,W
08B0:  ANDLW  C7
08B1:  IORWF  21,W
08B2:  MOVWF  1F
....................       ADC_DELAY; 
08B3:  MOVLW  21
08B4:  MOVWF  20
08B5:  DECFSZ 20,F
08B6:  GOTO   0B5
....................       Athrottle = read_adc(); 
08B7:  BSF    1F.2
08B8:  BTFSC  1F.2
08B9:  GOTO   0B8
08BA:  BSF    03.5
08BB:  MOVF   1E,W
08BC:  BCF    03.5
08BD:  MOVWF  4C
08BE:  MOVF   1E,W
08BF:  MOVWF  4D
....................       if (Athrottle<Athrottle_Min){ 
08C0:  MOVF   4D,W
08C1:  SUBLW  01
08C2:  BTFSS  03.0
08C3:  GOTO   0CE
08C4:  BTFSS  03.2
08C5:  GOTO   0CA
08C6:  MOVF   4C,W
08C7:  SUBLW  3B
08C8:  BTFSS  03.0
08C9:  GOTO   0CE
....................          Athrottle=Athrottle_Min; 
08CA:  MOVLW  01
08CB:  MOVWF  4D
08CC:  MOVLW  3C
08CD:  MOVWF  4C
....................       } 
....................  
....................       //SET THE STATE 
....................       if (Acaps> (A_CAPS_MAX +10)){ 
08CE:  MOVF   4F,W
08CF:  SUBLW  01
08D0:  BTFSC  03.0
08D1:  GOTO   0E6
08D2:  XORLW  FF
08D3:  BTFSS  03.2
08D4:  GOTO   0D9
08D5:  MOVF   4E,W
08D6:  SUBLW  DF
08D7:  BTFSC  03.0
08D8:  GOTO   0E6
....................          //FREAK OUT 
....................          //printf("State: Freak Out \n"); 
....................          output_low(Electric_Controller_Switch); 
08D9:  BSF    03.5
08DA:  BCF    06.0
08DB:  BCF    03.5
08DC:  BCF    06.0
....................          write_dac(0); 
08DD:  CLRF   58
08DE:  CLRF   57
08DF:  BCF    0A.3
08E0:  CALL   0E0
08E1:  BSF    0A.3
....................          //ICE_ON = FALSE; 
....................          ICEthrottle = 0; 
08E2:  CLRF   4B
08E3:  CLRF   4A
....................          //output_high(Contactor_Switch); 
....................          CHARGING_STATE =EVERYTHING_OFF; 
08E4:  CLRF   52
....................         //return; 
....................         //break; 
....................       } 
....................       else if (Athrottle<(Athrottle_Min+5)){ 
08E5:  GOTO   15F
08E6:  MOVF   4D,W
08E7:  SUBLW  01
08E8:  BTFSS  03.0
08E9:  GOTO   0F8
08EA:  BTFSS  03.2
08EB:  GOTO   0F0
08EC:  MOVF   4C,W
08ED:  SUBLW  40
08EE:  BTFSS  03.0
08EF:  GOTO   0F8
....................          CHARGING_STATE = USER_INPUT_OFF; 
08F0:  MOVLW  06
08F1:  MOVWF  52
....................          #ifdef DEBUG 
....................             printf("State: Throttle Off \n");   
....................          #else 
....................             delay_ms(250); 
08F2:  MOVLW  FA
08F3:  MOVWF  54
08F4:  BCF    0A.3
08F5:  CALL   22B
08F6:  BSF    0A.3
....................          #endif 
....................           
....................          } 
....................       else if (ICE_ON&&(vSpeed<V_SPEED_REGEN_MIN)){ 
08F7:  GOTO   15F
08F8:  BTFSS  43.1
08F9:  GOTO   109
08FA:  MOVF   47,F
08FB:  BTFSS  03.2
08FC:  GOTO   109
08FD:  MOVF   46,W
08FE:  SUBLW  31
08FF:  BTFSS  03.0
0900:  GOTO   109
....................          #ifdef DEBUG 
....................             printf("State: Speed To Low %ld \n",vSpeed);   
....................          #else 
....................             delay_ms(250); 
0901:  MOVLW  FA
0902:  MOVWF  54
0903:  BCF    0A.3
0904:  CALL   22B
0905:  BSF    0A.3
....................          #endif 
....................          CHARGING_STATE=SPEED_TO_LOW_ICE_DIRECT; 
0906:  MOVLW  01
0907:  MOVWF  52
....................       } 
....................       else if (checkRunnaway(& pidData)){// INSUFFICIENT_BRAKING_RUNNAWAY_ERROR){ 
0908:  GOTO   15F
0909:  MOVLW  2F
090A:  MOVWF  53
090B:  BCF    0A.3
090C:  GOTO   23E
090D:  BSF    0A.3
090E:  MOVF   21,F
090F:  BTFSC  03.2
0910:  GOTO   11A
....................          #ifdef DEBUG 
....................             printf("State: RUNNAWAY \n");   
....................          #else 
....................             delay_ms(250); 
0911:  MOVLW  FA
0912:  MOVWF  54
0913:  BCF    0A.3
0914:  CALL   22B
0915:  BSF    0A.3
....................          #endif 
....................          ICE_ON=TRUE; 
0916:  BSF    43.1
....................          CHARGING_STATE=INSUFFICIENT_BRAKING_RUNAWAY; 
0917:  MOVLW  05
0918:  MOVWF  52
....................       } 
....................       else if ((Acaps > A_CAPS_MAX)&&(CHARGING_STATE==CHARGING_ALLOWED||CHARGING_STATE==CHARGING_AND_DISCHARING_ALLOWED)){ 
0919:  GOTO   15F
091A:  MOVF   4F,W
091B:  SUBLW  01
091C:  BTFSC  03.0
091D:  GOTO   136
091E:  XORLW  FF
091F:  BTFSS  03.2
0920:  GOTO   125
0921:  MOVF   4E,W
0922:  SUBLW  D5
0923:  BTFSC  03.0
0924:  GOTO   136
0925:  MOVF   52,W
0926:  SUBLW  02
0927:  BTFSC  03.2
0928:  GOTO   12D
0929:  MOVF   52,W
092A:  SUBLW  04
092B:  BTFSS  03.2
092C:  GOTO   136
....................          //Stop Charging they are full 
....................           
....................          #ifdef DEBUG 
....................             printf("State: Caps Full \n");   
....................          #else 
....................             delay_ms(250); 
092D:  MOVLW  FA
092E:  MOVWF  54
092F:  BCF    0A.3
0930:  CALL   22B
0931:  BSF    0A.3
....................          #endif 
....................           
....................         ICE_ON=FALSE; 
0932:  BCF    43.1
....................         CHARGING_STATE=DISCHARGING_ALLOWED; 
0933:  MOVLW  03
0934:  MOVWF  52
....................       } 
....................       else if ((Acaps < A_CAPS_MIN)&& CHARGING_STATE!=CHARGING_ALLOWED){ 
0935:  GOTO   15F
0936:  MOVF   4F,W
0937:  SUBLW  01
0938:  BTFSS  03.0
0939:  GOTO   14D
093A:  BTFSS  03.2
093B:  GOTO   140
093C:  MOVF   4E,W
093D:  SUBLW  4E
093E:  BTFSS  03.0
093F:  GOTO   14D
0940:  MOVF   52,W
0941:  SUBLW  02
0942:  BTFSC  03.2
0943:  GOTO   14D
....................          //Stop running electric, the caps are almost empty 
....................          
....................         #ifdef DEBUG 
....................             printf("State: Caps Empty \n");   
....................          #else 
....................             delay_ms(250); 
0944:  MOVLW  FA
0945:  MOVWF  54
0946:  BCF    0A.3
0947:  CALL   22B
0948:  BSF    0A.3
....................          #endif 
....................  
....................         ICE_ON=TRUE; 
0949:  BSF    43.1
....................         CHARGING_STATE=CHARGING_ALLOWED; 
094A:  MOVLW  02
094B:  MOVWF  52
....................       } 
....................      else if (A_CAPS_MID_LOW < Acaps < A_CAPS_MID_HIGH){ 
094C:  GOTO   15F
094D:  MOVF   4F,W
094E:  SUBLW  00
094F:  BTFSC  03.0
0950:  GOTO   157
0951:  XORLW  FF
0952:  BTFSS  03.2
0953:  GOTO   158
0954:  MOVF   4E,W
0955:  SUBLW  B3
0956:  BTFSC  03.0
0957:  MOVLW  00
....................         #ifdef DEBUG 
....................             printf("State: Normal \n");   
....................          #else 
....................             delay_ms(250); 
0958:  MOVLW  FA
0959:  MOVWF  54
095A:  BCF    0A.3
095B:  CALL   22B
095C:  BSF    0A.3
....................          #endif 
....................          CHARGING_STATE=CHARGING_AND_DISCHARING_ALLOWED; 
095D:  MOVLW  04
095E:  MOVWF  52
....................      } 
....................       
....................       
.................... //PID CONTROLLER 
....................       //Servo to mirror Athrottle ->  
....................       //current_servo_position=right_position-(Athrottle-Athrottle_Min)*Athrottle_servo_factor;//(Athrottle/Athrottle_Full)*servo_difference;//(vSpeed/65536.0)*(2500); 
....................       ////printf("Analog Cap %d Analog Throttle %Lu\n",(int) Acaps,Athrottle); 
....................       //current_servo_position =right_position-vSpeed+200; 
....................       ////printf("Speed %lu \n",speeder); 
....................       //SET OUTPUTS  
....................       //The writing of the ICEThrottle happens in interupts and all that is 
....................       //required is updating ICEthrottle 
....................       ////printf("speed before %ld \n",vSpeed); 
....................        
....................       returnedValue = pid_Controller((Athrottle-AThrottle_Min),vSpeed,& pidData); 
095F:  MOVLW  3C
0960:  SUBWF  4C,W
0961:  MOVWF  53
0962:  MOVF   4D,W
0963:  MOVWF  54
0964:  MOVLW  01
0965:  BTFSS  03.0
0966:  MOVLW  02
0967:  SUBWF  54,F
0968:  MOVF   54,W
0969:  MOVWF  56
096A:  MOVF   53,W
096B:  MOVWF  55
096C:  MOVF   47,W
096D:  MOVWF  58
096E:  MOVF   46,W
096F:  MOVWF  57
0970:  MOVLW  2F
0971:  MOVWF  59
0972:  BCF    0A.3
0973:  GOTO   242
0974:  BSF    0A.3
0975:  MOVF   22,W
0976:  MOVWF  51
0977:  MOVF   21,W
0978:  MOVWF  50
....................       ELECthrottle = ELECthrottle+returnedValue; 
0979:  MOVF   50,W
097A:  ADDWF  48,F
097B:  MOVF   51,W
097C:  BTFSC  03.0
097D:  INCFSZ 51,W
097E:  ADDWF  49,F
....................       
....................       
....................       if (ELECthrottle>2500){ 
097F:  BTFSC  49.7
0980:  GOTO   191
0981:  MOVF   49,W
0982:  SUBLW  08
0983:  BTFSC  03.0
0984:  GOTO   191
0985:  XORLW  FF
0986:  BTFSS  03.2
0987:  GOTO   18C
0988:  MOVF   48,W
0989:  SUBLW  C4
098A:  BTFSC  03.0
098B:  GOTO   191
....................          ELECthrottle=2500; 
098C:  MOVLW  09
098D:  MOVWF  49
098E:  MOVLW  C4
098F:  MOVWF  48
....................       } 
....................       else if (ELECthrottle<-500){ 
0990:  GOTO   1A1
0991:  BTFSS  49.7
0992:  GOTO   1A1
0993:  MOVF   49,W
0994:  SUBLW  FE
0995:  BTFSS  03.0
0996:  GOTO   1A1
0997:  BTFSS  03.2
0998:  GOTO   19D
0999:  MOVF   48,W
099A:  SUBLW  0B
099B:  BTFSS  03.0
099C:  GOTO   1A1
....................          ELECthrottle = -500; 
099D:  MOVLW  FE
099E:  MOVWF  49
099F:  MOVLW  0C
09A0:  MOVWF  48
....................       } 
....................        
....................        
....................       //SET OUTPUTS 
....................       if (CHARGING_STATE==EVERYTHING_OFF||CHARGING_STATE==USER_INPUT_OFF){ 
09A1:  MOVF   52,F
09A2:  BTFSC  03.2
09A3:  GOTO   1A8
09A4:  MOVF   52,W
09A5:  SUBLW  06
09A6:  BTFSS  03.2
09A7:  GOTO   1B5
....................          ICEthrottle = 0; 
09A8:  CLRF   4B
09A9:  CLRF   4A
....................          ICE_ON = FALSE; 
09AA:  BCF    43.1
....................          current_servo_position =right_position; 
09AB:  MOVLW  14
09AC:  MOVWF  42
09AD:  MOVLW  B4
09AE:  MOVWF  41
....................          write_dac(0); 
09AF:  CLRF   58
09B0:  CLRF   57
09B1:  BCF    0A.3
09B2:  CALL   0E0
09B3:  BSF    0A.3
....................       } 
....................       else if (CHARGING_STATE==SPEED_TO_LOW_ICE_DIRECT || CHARGING_STATE==INSUFFICIENT_BRAKING_RUNAWAY){ 
09B4:  GOTO   261
09B5:  DECFSZ 52,W
09B6:  GOTO   1B8
09B7:  GOTO   1BC
09B8:  MOVF   52,W
09B9:  SUBLW  05
09BA:  BTFSS  03.2
09BB:  GOTO   1DE
....................          if (ELECthrottle>0){ 
09BC:  BTFSC  49.7
09BD:  GOTO   1D3
09BE:  MOVF   49,F
09BF:  BTFSS  03.2
09C0:  GOTO   1C5
09C1:  MOVF   48,W
09C2:  SUBLW  00
09C3:  BTFSC  03.0
09C4:  GOTO   1D3
....................             current_servo_position =right_position- (ELECthrottle); 
09C5:  MOVF   48,W
09C6:  SUBLW  B4
09C7:  MOVWF  20
09C8:  MOVLW  14
09C9:  MOVWF  23
09CA:  MOVF   49,W
09CB:  BTFSS  03.0
09CC:  INCFSZ 49,W
09CD:  SUBWF  23,F
09CE:  MOVF   20,W
09CF:  MOVWF  41
09D0:  MOVF   23,W
09D1:  MOVWF  42
....................          } 
....................          else{ 
09D2:  GOTO   1D7
....................             current_servo_position =right_position; 
09D3:  MOVLW  14
09D4:  MOVWF  42
09D5:  MOVLW  B4
09D6:  MOVWF  41
....................          } 
....................          ICE_ON = TRUE; 
09D7:  BSF    43.1
....................          write_dac(0); 
09D8:  CLRF   58
09D9:  CLRF   57
09DA:  BCF    0A.3
09DB:  CALL   0E0
09DC:  BSF    0A.3
....................       } 
....................       else{ 
09DD:  GOTO   261
....................       if (ELECthrottle<0){ 
09DE:  BTFSS  49.7
09DF:  GOTO   21E
....................         if (CHARGING_STATE==CHARGING_ALLOWED || CHARGING_STATE ==CHARGING_AND_DISCHARING_ALLOWED){ 
09E0:  MOVF   52,W
09E1:  SUBLW  02
09E2:  BTFSC  03.2
09E3:  GOTO   1E8
09E4:  MOVF   52,W
09E5:  SUBLW  04
09E6:  BTFSS  03.2
09E7:  GOTO   218
....................              if (CURRENTLY_CHARGING==1){ 
09E8:  BTFSS  43.2
09E9:  GOTO   1ED
....................                 trickBreaking(); 
09EA:  BCF    0A.3
09EB:  GOTO   61E
09EC:  BSF    0A.3
....................              } 
....................              //ELECthrottle = 300; 
....................              CURRENTLY_CHARGING=0; 
09ED:  BCF    43.2
....................              output_high(brake_pin); 
09EE:  BSF    03.5
09EF:  BCF    06.4
09F0:  BCF    03.5
09F1:  BSF    06.4
....................              output_high(Electric_Controller_Switch); 
09F2:  BSF    03.5
09F3:  BCF    06.0
09F4:  BCF    03.5
09F5:  BSF    06.0
....................              //printf("BREAKING \n"); 
....................              write_dac((abs(ELECthrottle)+ELEC_CONTROLLER_OFFSET)); 
09F6:  MOVF   49,W
09F7:  MOVWF  23
09F8:  MOVF   48,W
09F9:  BTFSS  49.7
09FA:  GOTO   204
09FB:  MOVF   48,W
09FC:  SUBLW  00
09FD:  MOVWF  20
09FE:  CLRF   23
09FF:  MOVF   49,W
0A00:  BTFSS  03.0
0A01:  INCFSZ 49,W
0A02:  SUBWF  23,F
0A03:  MOVF   20,W
0A04:  MOVWF  53
0A05:  MOVF   23,W
0A06:  MOVWF  54
0A07:  MOVLW  84
0A08:  ADDWF  53,W
0A09:  MOVWF  55
0A0A:  MOVF   54,W
0A0B:  MOVWF  56
0A0C:  MOVLW  03
0A0D:  BTFSC  03.0
0A0E:  MOVLW  04
0A0F:  ADDWF  56,F
0A10:  MOVF   56,W
0A11:  MOVWF  58
0A12:  MOVF   55,W
0A13:  MOVWF  57
0A14:  BCF    0A.3
0A15:  CALL   0E0
0A16:  BSF    0A.3
....................         } 
....................         else{ 
0A17:  GOTO   21D
....................            //Decrease ICE throttle 
....................            write_dac(0); 
0A18:  CLRF   58
0A19:  CLRF   57
0A1A:  BCF    0A.3
0A1B:  CALL   0E0
0A1C:  BSF    0A.3
....................        
....................         } 
....................       } 
....................       else { 
0A1D:  GOTO   256
....................         if (CHARGING_STATE==DISCHARGING_ALLOWED || CHARGING_STATE ==CHARGING_AND_DISCHARING_ALLOWED){ 
0A1E:  MOVF   52,W
0A1F:  SUBLW  03
0A20:  BTFSC  03.2
0A21:  GOTO   226
0A22:  MOVF   52,W
0A23:  SUBLW  04
0A24:  BTFSS  03.2
0A25:  GOTO   251
....................              CURRENTLY_CHARGING=1; 
0A26:  BSF    43.2
....................              output_low(brake_pin); 
0A27:  BSF    03.5
0A28:  BCF    06.4
0A29:  BCF    03.5
0A2A:  BCF    06.4
....................              output_low(Electric_Controller_Switch); 
0A2B:  BSF    03.5
0A2C:  BCF    06.0
0A2D:  BCF    03.5
0A2E:  BCF    06.0
....................              //printf("ACCELERATING \n"); 
....................              write_dac((abs(ELECthrottle)+ELEC_CONTROLLER_OFFSET)); 
0A2F:  MOVF   49,W
0A30:  MOVWF  23
0A31:  MOVF   48,W
0A32:  BTFSS  49.7
0A33:  GOTO   23D
0A34:  MOVF   48,W
0A35:  SUBLW  00
0A36:  MOVWF  20
0A37:  CLRF   23
0A38:  MOVF   49,W
0A39:  BTFSS  03.0
0A3A:  INCFSZ 49,W
0A3B:  SUBWF  23,F
0A3C:  MOVF   20,W
0A3D:  MOVWF  53
0A3E:  MOVF   23,W
0A3F:  MOVWF  54
0A40:  MOVLW  84
0A41:  ADDWF  53,W
0A42:  MOVWF  55
0A43:  MOVF   54,W
0A44:  MOVWF  56
0A45:  MOVLW  03
0A46:  BTFSC  03.0
0A47:  MOVLW  04
0A48:  ADDWF  56,F
0A49:  MOVF   56,W
0A4A:  MOVWF  58
0A4B:  MOVF   55,W
0A4C:  MOVWF  57
0A4D:  BCF    0A.3
0A4E:  CALL   0E0
0A4F:  BSF    0A.3
....................         } 
....................         else{ 
0A50:  GOTO   256
....................            //Increase ICE throttle 
....................            write_dac(0); 
0A51:  CLRF   58
0A52:  CLRF   57
0A53:  BCF    0A.3
0A54:  CALL   0E0
0A55:  BSF    0A.3
....................        
....................         } 
....................           
....................       } 
....................       if (ICE_ON){ 
0A56:  BTFSS  43.1
0A57:  GOTO   25D
....................          //printf("ICE NORMAL \n"); 
....................          current_servo_position =right_position-800; 
0A58:  MOVLW  11
0A59:  MOVWF  42
0A5A:  MOVLW  94
0A5B:  MOVWF  41
....................       } 
....................       else{ 
0A5C:  GOTO   261
....................          current_servo_position =right_position; 
0A5D:  MOVLW  14
0A5E:  MOVWF  42
0A5F:  MOVLW  B4
0A60:  MOVWF  41
....................          //printf("ICE OFF \n"); 
....................       } 
....................       } 
....................             
....................    } 
0A61:  GOTO   09A
....................     
....................  
.................... } 
....................  
.................... #endif 
....................  
.................... boolean checkRunnaway(struct PID_DATA *pid) 
.................... { 
0A62:  SLEEP
.................... //return (pid->sumError > INSUFFICIENT_BRAKING_RUNNAWAY_ERROR); 
.................... return FALSE; 
*
023E:  MOVLW  00
023F:  MOVWF  21
.................... } 
0240:  BSF    0A.3
0241:  GOTO   10D (RETURN)
....................  
.................... /*! \brief Initialisation of PID controller parameters. 
....................  * 
....................  *  Initialise the variables used by the PID algorithm. 
....................  * 
....................  *  \param p_factor  Proportional term. 
....................  *  \param i_factor  Integral term. 
....................  *  \param d_factor  Derivate term. 
....................  *  \param pid  Struct with PID status. 
....................  */ 
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid) 
.................... // Set up PID controller parameters 
.................... { 
....................   // Start values for PID controller 
....................   pid->sumError = 0; 
*
013C:  MOVLW  02
013D:  ADDWF  59,W
013E:  MOVWF  04
013F:  INCF   04,F
0140:  INCF   04,F
0141:  INCF   04,F
0142:  CLRF   00
0143:  DECF   04,F
0144:  CLRF   00
0145:  DECF   04,F
0146:  CLRF   00
0147:  DECF   04,F
0148:  CLRF   00
....................   pid->lastProcessValue = 0; 
0149:  MOVF   59,W
014A:  MOVWF  04
014B:  INCF   04,F
014C:  CLRF   00
014D:  DECF   04,F
014E:  CLRF   00
....................   // Tuning constants for PID loop 
....................   pid->P_Factor = p_factor; 
014F:  MOVLW  06
0150:  ADDWF  59,W
0151:  MOVWF  04
0152:  INCF   04,F
0153:  MOVF   54,W
0154:  MOVWF  00
0155:  DECF   04,F
0156:  MOVF   53,W
0157:  MOVWF  00
....................   pid->I_Factor = i_factor; 
0158:  MOVLW  08
0159:  ADDWF  59,W
015A:  MOVWF  04
015B:  INCF   04,F
015C:  MOVF   56,W
015D:  MOVWF  00
015E:  DECF   04,F
015F:  MOVF   55,W
0160:  MOVWF  00
....................   pid->D_Factor = d_factor; 
0161:  MOVLW  0A
0162:  ADDWF  59,W
0163:  MOVWF  04
0164:  INCF   04,F
0165:  MOVF   58,W
0166:  MOVWF  00
0167:  DECF   04,F
0168:  MOVF   57,W
0169:  MOVWF  00
....................   // Limits to avoid overflow 
....................   pid->maxError = MAX_INT / (pid->P_Factor + 1); 
016A:  MOVLW  0C
016B:  ADDWF  59,W
016C:  MOVWF  5A
016D:  MOVLW  06
016E:  ADDWF  59,W
016F:  MOVWF  04
0170:  INCF   04,F
0171:  MOVF   00,W
0172:  MOVWF  5C
0173:  DECF   04,F
0174:  MOVF   00,W
0175:  MOVWF  5B
0176:  MOVLW  01
0177:  ADDWF  5B,W
0178:  MOVWF  21
0179:  MOVF   5C,W
017A:  MOVWF  23
017B:  BTFSC  03.0
017C:  INCF   23,F
017D:  MOVF   21,W
017E:  MOVWF  5D
017F:  MOVF   23,W
0180:  MOVWF  5E
0181:  MOVLW  7F
0182:  MOVWF  60
0183:  MOVLW  FF
0184:  MOVWF  5F
0185:  MOVF   5E,W
0186:  MOVWF  62
0187:  MOVF   5D,W
0188:  MOVWF  61
*
01AD:  MOVF   5A,W
01AE:  MOVWF  04
01AF:  INCF   04,F
01B0:  MOVF   22,W
01B1:  MOVWF  00
01B2:  DECF   04,F
01B3:  MOVF   21,W
01B4:  MOVWF  00
....................   ////printf("Max %ld factor %ld and pid %ld",MAX_INT,pid->I_Factor,pid->maxError); 
....................   pid->maxSumError = MAX_I_TERM / (pid->I_Factor + 1); 
01B5:  MOVLW  0E
01B6:  ADDWF  59,W
01B7:  MOVWF  5A
01B8:  MOVLW  08
01B9:  ADDWF  59,W
01BA:  MOVWF  04
01BB:  INCF   04,F
01BC:  MOVF   00,W
01BD:  MOVWF  5C
01BE:  DECF   04,F
01BF:  MOVF   00,W
01C0:  MOVWF  5B
01C1:  MOVLW  01
01C2:  ADDWF  5B,W
01C3:  MOVWF  21
01C4:  MOVF   5C,W
01C5:  MOVWF  23
01C6:  BTFSC  03.0
01C7:  INCF   23,F
01C8:  MOVF   21,W
01C9:  MOVWF  5D
01CA:  MOVF   23,W
01CB:  MOVWF  5E
01CC:  MOVF   04,W
01CD:  MOVWF  5F
01CE:  MOVLW  3F
01CF:  MOVWF  63
01D0:  MOVLW  FF
01D1:  MOVWF  62
01D2:  MOVWF  61
01D3:  MOVWF  60
01D4:  CLRF   67
01D5:  CLRF   66
01D6:  MOVF   5E,W
01D7:  MOVWF  65
01D8:  MOVF   5D,W
01D9:  MOVWF  64
*
021A:  MOVF   5F,W
021B:  MOVWF  04
021C:  MOVF   5A,W
021D:  MOVWF  04
021E:  MOVF   20,W
021F:  MOVWF  00
0220:  INCF   04,F
0221:  MOVF   21,W
0222:  MOVWF  00
0223:  INCF   04,F
0224:  MOVF   22,W
0225:  MOVWF  00
0226:  INCF   04,F
0227:  MOVF   23,W
0228:  MOVWF  00
.................... } 
0229:  BSF    0A.3
022A:  GOTO   07F (RETURN)
....................  
....................  
.................... /*! \brief PID control algorithm. 
....................  * 
....................  *  Calculates output from setpoint, process value and PID status. 
....................  * 
....................  *  \param setPoint  Desired value. 
....................  *  \param processValue  Measured value. 
....................  *  \param pid_st  PID status struct. 
....................  */ 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st) 
.................... { 
....................   signed int16 error, p_term, d_term; 
....................   signed int32 i_term, ret, temp; 
....................     processValue=processValue/4; 
*
0242:  RRF    58,F
0243:  RRF    57,F
0244:  RRF    58,F
0245:  RRF    57,F
0246:  MOVLW  3F
0247:  ANDWF  58,F
....................   ////printf("input %ld speed %ld ",setPoint,processValue); 
....................   error = setPoint - processValue; 
0248:  MOVF   57,W
0249:  SUBWF  55,W
024A:  MOVWF  20
024B:  MOVF   56,W
024C:  MOVWF  23
024D:  MOVF   58,W
024E:  BTFSS  03.0
024F:  INCFSZ 58,W
0250:  SUBWF  23,F
0251:  MOVF   20,W
0252:  MOVWF  5A
0253:  MOVF   23,W
0254:  MOVWF  5B
....................    
....................   // Calculate Pterm and limit error overflow 
....................    
....................   if (error > (signed int16) pid_st->maxError){ 
0255:  MOVLW  0C
0256:  ADDWF  59,W
0257:  MOVWF  04
0258:  INCF   04,F
0259:  MOVF   00,W
025A:  MOVWF  23
025B:  DECF   04,F
025C:  MOVF   00,W
025D:  MOVWF  21
025E:  BTFSS  23.7
025F:  GOTO   263
0260:  BTFSS  5B.7
0261:  GOTO   26F
0262:  GOTO   265
0263:  BTFSC  5B.7
0264:  GOTO   274
0265:  MOVF   23,W
0266:  SUBWF  5B,W
0267:  BTFSS  03.0
0268:  GOTO   274
0269:  BTFSS  03.2
026A:  GOTO   26F
026B:  MOVF   5A,W
026C:  SUBWF  21,W
026D:  BTFSC  03.0
026E:  GOTO   274
....................     p_term = MAX_INT; 
026F:  MOVLW  7F
0270:  MOVWF  5D
0271:  MOVLW  FF
0272:  MOVWF  5C
....................     ////printf("p greater error %ld a %ld p %ld",error,pid_st->maxError,p_term); 
....................  
....................   } 
....................   else if (error < (signed int16) -pid_st->maxError){ 
0273:  GOTO   3A5
0274:  MOVLW  0C
0275:  ADDWF  59,W
0276:  MOVWF  04
0277:  INCF   04,F
0278:  MOVF   00,W
0279:  MOVWF  23
027A:  DECF   04,F
027B:  MOVF   00,W
027C:  SUBLW  00
027D:  MOVWF  20
027E:  MOVF   23,W
027F:  BTFSS  03.0
0280:  INCFSZ 23,W
0281:  GOTO   284
0282:  MOVLW  00
0283:  GOTO   285
0284:  SUBLW  00
0285:  MOVWF  23
0286:  MOVF   20,W
0287:  MOVWF  21
0288:  BTFSS  5B.7
0289:  GOTO   28D
028A:  BTFSS  23.7
028B:  GOTO   299
028C:  GOTO   28F
028D:  BTFSC  23.7
028E:  GOTO   29E
028F:  MOVF   5B,W
0290:  SUBWF  23,W
0291:  BTFSS  03.0
0292:  GOTO   29E
0293:  BTFSS  03.2
0294:  GOTO   299
0295:  MOVF   21,W
0296:  SUBWF  5A,W
0297:  BTFSC  03.0
0298:  GOTO   29E
....................     p_term = -MAX_INT; 
0299:  MOVLW  80
029A:  MOVWF  5D
029B:  MOVLW  01
029C:  MOVWF  5C
....................     ////printf("p less error %ld a %ld p %ld",error,-pid_st->maxError,p_term); 
....................  
....................   } 
....................   else{ 
029D:  GOTO   3A5
....................     p_term = (signed int16) (pid_st->P_Factor * (float) error); 
029E:  MOVLW  06
029F:  ADDWF  59,W
02A0:  MOVWF  04
02A1:  INCF   04,F
02A2:  MOVF   00,W
02A3:  MOVWF  6D
02A4:  DECF   04,F
02A5:  MOVF   00,W
02A6:  MOVWF  6C
02A7:  MOVF   5B,W
02A8:  MOVWF  6F
02A9:  MOVF   5A,W
02AA:  MOVWF  6E
*
02CF:  MOVF   20,W
02D0:  MOVWF  6E
02D1:  MOVF   21,W
02D2:  MOVWF  6F
02D3:  MOVF   22,W
02D4:  MOVWF  70
02D5:  MOVF   23,W
02D6:  MOVWF  71
02D7:  MOVF   6D,W
02D8:  MOVWF  73
02D9:  MOVF   6C,W
02DA:  MOVWF  72
*
02F7:  MOVF   23,W
02F8:  MOVWF  75
02F9:  MOVF   22,W
02FA:  MOVWF  74
02FB:  MOVF   21,W
02FC:  MOVWF  73
02FD:  MOVF   20,W
02FE:  MOVWF  72
02FF:  MOVF   71,W
0300:  MOVWF  79
0301:  MOVF   70,W
0302:  MOVWF  78
0303:  MOVF   6F,W
0304:  MOVWF  77
0305:  MOVF   6E,W
0306:  MOVWF  76
*
037B:  MOVF   23,W
037C:  MOVWF  75
037D:  MOVF   22,W
037E:  MOVWF  74
037F:  MOVF   21,W
0380:  MOVWF  73
0381:  MOVF   20,W
0382:  MOVWF  72
*
03A1:  MOVF   22,W
03A2:  MOVWF  5D
03A3:  MOVF   21,W
03A4:  MOVWF  5C
....................     ////printf("error %ld a %ld p %ld",error,pid_st->maxError,p_term); 
....................   } 
....................    
....................   // Calculate Iterm and limit integral runaway 
....................   temp = pid_st->sumError + error; 
03A5:  MOVLW  02
03A6:  ADDWF  59,W
03A7:  MOVWF  04
03A8:  MOVF   00,W
03A9:  MOVWF  6C
03AA:  INCF   04,F
03AB:  MOVF   00,W
03AC:  MOVWF  6D
03AD:  INCF   04,F
03AE:  MOVF   00,W
03AF:  MOVWF  6E
03B0:  INCF   04,F
03B1:  MOVF   00,W
03B2:  MOVWF  6F
03B3:  MOVF   5A,W
03B4:  MOVWF  20
03B5:  MOVF   5B,W
03B6:  MOVWF  21
03B7:  CLRF   22
03B8:  CLRF   23
03B9:  BTFSS  5B.7
03BA:  GOTO   3BD
03BB:  DECF   22,F
03BC:  DECF   23,F
03BD:  MOVF   20,W
03BE:  ADDWF  6C,W
03BF:  MOVWF  68
03C0:  MOVF   6D,W
03C1:  MOVWF  69
03C2:  MOVF   21,W
03C3:  BTFSC  03.0
03C4:  INCFSZ 21,W
03C5:  ADDWF  69,F
03C6:  MOVF   6E,W
03C7:  MOVWF  6A
03C8:  MOVF   22,W
03C9:  BTFSC  03.0
03CA:  INCFSZ 22,W
03CB:  ADDWF  6A,F
03CC:  MOVF   6F,W
03CD:  MOVWF  6B
03CE:  MOVF   23,W
03CF:  BTFSC  03.0
03D0:  INCFSZ 23,W
03D1:  ADDWF  6B,F
....................   if(temp > (signed int32)pid_st->maxSumError){ 
03D2:  MOVLW  0E
03D3:  ADDWF  59,W
03D4:  MOVWF  04
03D5:  MOVF   00,W
03D6:  MOVWF  20
03D7:  INCF   04,F
03D8:  MOVF   00,W
03D9:  MOVWF  21
03DA:  INCF   04,F
03DB:  MOVF   00,W
03DC:  MOVWF  22
03DD:  INCF   04,F
03DE:  MOVF   00,W
03DF:  MOVWF  23
03E0:  BTFSS  23.7
03E1:  GOTO   3E5
03E2:  BTFSS  6B.7
03E3:  GOTO   3FD
03E4:  GOTO   3E7
03E5:  BTFSC  6B.7
03E6:  GOTO   422
03E7:  MOVF   23,W
03E8:  SUBWF  6B,W
03E9:  BTFSS  03.0
03EA:  GOTO   422
03EB:  BTFSS  03.2
03EC:  GOTO   3FD
03ED:  MOVF   22,W
03EE:  SUBWF  6A,W
03EF:  BTFSS  03.0
03F0:  GOTO   422
03F1:  BTFSS  03.2
03F2:  GOTO   3FD
03F3:  MOVF   21,W
03F4:  SUBWF  69,W
03F5:  BTFSS  03.0
03F6:  GOTO   422
03F7:  BTFSS  03.2
03F8:  GOTO   3FD
03F9:  MOVF   68,W
03FA:  SUBWF  20,W
03FB:  BTFSC  03.0
03FC:  GOTO   422
....................     i_term = MAX_I_TERM; 
03FD:  MOVLW  3F
03FE:  MOVWF  63
03FF:  MOVLW  FF
0400:  MOVWF  62
0401:  MOVWF  61
0402:  MOVWF  60
....................     pid_st->sumError = pid_st->maxSumError; 
0403:  MOVLW  02
0404:  ADDWF  59,W
0405:  MOVWF  6C
0406:  MOVLW  0E
0407:  ADDWF  59,W
0408:  MOVWF  04
0409:  MOVF   00,W
040A:  MOVWF  20
040B:  INCF   04,F
040C:  MOVF   00,W
040D:  MOVWF  21
040E:  INCF   04,F
040F:  MOVF   00,W
0410:  MOVWF  22
0411:  INCF   04,F
0412:  MOVF   00,W
0413:  MOVWF  23
0414:  MOVF   6C,W
0415:  MOVWF  04
0416:  MOVF   20,W
0417:  MOVWF  00
0418:  INCF   04,F
0419:  MOVF   21,W
041A:  MOVWF  00
041B:  INCF   04,F
041C:  MOVF   22,W
041D:  MOVWF  00
041E:  INCF   04,F
041F:  MOVF   23,W
0420:  MOVWF  00
....................     ////printf("\n greater temp %ld a %ld sum %ld",temp,pid_st->maxSumError,pid_st->sumError); 
....................  
....................  } 
....................   else if(temp < (signed int32)-pid_st->maxSumError){ 
0421:  GOTO   536
0422:  MOVLW  0E
0423:  ADDWF  59,W
0424:  MOVWF  04
0425:  MOVF   00,W
0426:  MOVWF  20
0427:  INCF   04,F
0428:  MOVF   00,W
0429:  MOVWF  21
042A:  INCF   04,F
042B:  MOVF   00,W
042C:  MOVWF  22
042D:  INCF   04,F
042E:  MOVF   00,W
042F:  MOVWF  23
0430:  MOVLW  FD
0431:  ADDWF  04,F
0432:  MOVF   20,W
0433:  SUBLW  00
0434:  MOVWF  20
0435:  MOVF   21,W
0436:  BTFSS  03.0
0437:  INCFSZ 21,W
0438:  GOTO   43B
0439:  MOVLW  00
043A:  GOTO   43C
043B:  SUBLW  00
043C:  MOVWF  21
043D:  MOVF   22,W
043E:  BTFSS  03.0
043F:  INCFSZ 22,W
0440:  GOTO   443
0441:  MOVLW  00
0442:  GOTO   444
0443:  SUBLW  00
0444:  MOVWF  22
0445:  MOVF   23,W
0446:  BTFSS  03.0
0447:  INCFSZ 23,W
0448:  GOTO   44B
0449:  MOVLW  00
044A:  GOTO   44C
044B:  SUBLW  00
044C:  MOVWF  23
044D:  BTFSS  6B.7
044E:  GOTO   452
044F:  BTFSS  23.7
0450:  GOTO   46A
0451:  GOTO   454
0452:  BTFSC  23.7
0453:  GOTO   4AD
0454:  MOVF   6B,W
0455:  SUBWF  23,W
0456:  BTFSS  03.0
0457:  GOTO   4AD
0458:  BTFSS  03.2
0459:  GOTO   46A
045A:  MOVF   6A,W
045B:  SUBWF  22,W
045C:  BTFSS  03.0
045D:  GOTO   4AD
045E:  BTFSS  03.2
045F:  GOTO   46A
0460:  MOVF   69,W
0461:  SUBWF  21,W
0462:  BTFSS  03.0
0463:  GOTO   4AD
0464:  BTFSS  03.2
0465:  GOTO   46A
0466:  MOVF   20,W
0467:  SUBWF  68,W
0468:  BTFSC  03.0
0469:  GOTO   4AD
....................     i_term = -MAX_I_TERM; 
046A:  MOVLW  C0
046B:  MOVWF  63
046C:  CLRF   62
046D:  CLRF   61
046E:  MOVLW  01
046F:  MOVWF  60
....................     pid_st->sumError = -pid_st->maxSumError; 
0470:  MOVLW  02
0471:  ADDWF  59,W
0472:  MOVWF  6C
0473:  MOVLW  0E
0474:  ADDWF  59,W
0475:  MOVWF  04
0476:  MOVF   00,W
0477:  MOVWF  20
0478:  INCF   04,F
0479:  MOVF   00,W
047A:  MOVWF  21
047B:  INCF   04,F
047C:  MOVF   00,W
047D:  MOVWF  22
047E:  INCF   04,F
047F:  MOVF   00,W
0480:  MOVWF  23
0481:  MOVLW  FD
0482:  ADDWF  04,F
0483:  MOVF   20,W
0484:  SUBLW  00
0485:  MOVWF  20
0486:  MOVF   21,W
0487:  BTFSS  03.0
0488:  INCFSZ 21,W
0489:  GOTO   48C
048A:  MOVLW  00
048B:  GOTO   48D
048C:  SUBLW  00
048D:  MOVWF  21
048E:  MOVF   22,W
048F:  BTFSS  03.0
0490:  INCFSZ 22,W
0491:  GOTO   494
0492:  MOVLW  00
0493:  GOTO   495
0494:  SUBLW  00
0495:  MOVWF  22
0496:  MOVF   23,W
0497:  BTFSS  03.0
0498:  INCFSZ 23,W
0499:  GOTO   49C
049A:  MOVLW  00
049B:  GOTO   49D
049C:  SUBLW  00
049D:  MOVWF  23
049E:  MOVWF  70
049F:  MOVF   6C,W
04A0:  MOVWF  04
04A1:  MOVF   20,W
04A2:  MOVWF  00
04A3:  INCF   04,F
04A4:  MOVF   21,W
04A5:  MOVWF  00
04A6:  INCF   04,F
04A7:  MOVF   22,W
04A8:  MOVWF  00
04A9:  INCF   04,F
04AA:  MOVF   70,W
04AB:  MOVWF  00
....................     ////printf("\n less temp %ld a %ld sum %ld",temp,pid_st->maxSumError,pid_st->sumError); 
....................  
....................   } 
....................   else{ 
04AC:  GOTO   536
....................     pid_st->sumError = temp; 
04AD:  MOVLW  02
04AE:  ADDWF  59,W
04AF:  MOVWF  04
04B0:  MOVF   68,W
04B1:  MOVWF  00
04B2:  INCF   04,F
04B3:  MOVF   69,W
04B4:  MOVWF  00
04B5:  INCF   04,F
04B6:  MOVF   6A,W
04B7:  MOVWF  00
04B8:  INCF   04,F
04B9:  MOVF   6B,W
04BA:  MOVWF  00
....................     i_term = pid_st->I_Factor * pid_st->sumError; 
04BB:  MOVLW  08
04BC:  ADDWF  59,W
04BD:  MOVWF  04
04BE:  INCF   04,F
04BF:  MOVF   00,W
04C0:  MOVWF  6D
04C1:  DECF   04,F
04C2:  MOVF   00,W
04C3:  MOVWF  6C
04C4:  MOVLW  02
04C5:  ADDWF  59,W
04C6:  MOVWF  04
04C7:  MOVF   00,W
04C8:  MOVWF  20
04C9:  INCF   04,F
04CA:  MOVF   00,W
04CB:  MOVWF  21
04CC:  INCF   04,F
04CD:  MOVF   00,W
04CE:  MOVWF  22
04CF:  INCF   04,F
04D0:  MOVF   00,W
04D1:  MOVWF  23
04D2:  MOVLW  FD
04D3:  ADDWF  04,F
04D4:  MOVF   23,W
04D5:  MOVWF  71
04D6:  MOVF   22,W
04D7:  MOVWF  70
04D8:  MOVF   21,W
04D9:  MOVWF  6F
04DA:  MOVF   20,W
04DB:  MOVWF  6E
04DC:  MOVF   04,W
04DD:  MOVWF  72
04DE:  CLRF   76
04DF:  CLRF   75
04E0:  MOVF   6D,W
04E1:  MOVWF  74
04E2:  MOVF   6C,W
04E3:  MOVWF  73
04E4:  MOVF   71,W
04E5:  MOVWF  7A
04E6:  MOVF   70,W
04E7:  MOVWF  79
04E8:  MOVF   6F,W
04E9:  MOVWF  78
04EA:  MOVF   6E,W
04EB:  MOVWF  77
*
052B:  BCF    03.5
052C:  MOVF   72,W
052D:  MOVWF  04
052E:  MOVF   23,W
052F:  MOVWF  63
0530:  MOVF   22,W
0531:  MOVWF  62
0532:  MOVF   21,W
0533:  MOVWF  61
0534:  MOVF   20,W
0535:  MOVWF  60
....................     ////printf("\n eror temp %ld i_term %ld sum %ld error %ld ",temp,i_term,pid_st->sumError,error); 
....................  
....................   } 
....................  
....................   // Calculate Dterm 
....................   d_term = pid_st->D_Factor * (pid_st->lastProcessValue - processValue); 
0536:  MOVLW  0A
0537:  ADDWF  59,W
0538:  MOVWF  04
0539:  INCF   04,F
053A:  MOVF   00,W
053B:  MOVWF  6D
053C:  DECF   04,F
053D:  MOVF   00,W
053E:  MOVWF  6C
053F:  MOVF   59,W
0540:  MOVWF  04
0541:  INCF   04,F
0542:  MOVF   00,W
0543:  MOVWF  6F
0544:  DECF   04,F
0545:  MOVF   00,W
0546:  MOVWF  6E
0547:  MOVF   57,W
0548:  SUBWF  6E,W
0549:  MOVWF  20
054A:  MOVF   6F,W
054B:  MOVWF  23
054C:  MOVF   58,W
054D:  BTFSS  03.0
054E:  INCFSZ 58,W
054F:  SUBWF  23,F
0550:  MOVF   20,W
0551:  MOVWF  70
0552:  MOVF   23,W
0553:  MOVWF  71
0554:  MOVF   6D,W
0555:  MOVWF  73
0556:  MOVF   6C,W
0557:  MOVWF  72
0558:  MOVF   71,W
0559:  MOVWF  75
055A:  MOVF   70,W
055B:  MOVWF  74
*
0570:  MOVF   21,W
0571:  MOVWF  5E
0572:  MOVF   22,W
0573:  MOVWF  5F
.................... ////printf("\n p_term %ld d_term %ld i_term %ld",p_term,d_term,i_term); 
....................   pid_st->lastProcessValue = processValue; 
0574:  MOVF   59,W
0575:  MOVWF  04
0576:  INCF   04,F
0577:  MOVF   58,W
0578:  MOVWF  00
0579:  DECF   04,F
057A:  MOVF   57,W
057B:  MOVWF  00
....................  
....................   //ret = (p_term + i_term + d_term) / SCALING_FACTOR; 
....................    ret = (p_term+d_term+(signed int16)i_term) / SCALING_FACTOR; 
057C:  MOVF   5E,W
057D:  ADDWF  5C,W
057E:  MOVWF  6C
057F:  MOVF   5D,W
0580:  MOVWF  6D
0581:  MOVF   5F,W
0582:  BTFSC  03.0
0583:  INCFSZ 5F,W
0584:  ADDWF  6D,F
0585:  MOVF   60,W
0586:  ADDWF  6C,W
0587:  MOVWF  6E
0588:  MOVF   6D,W
0589:  MOVWF  6F
058A:  MOVF   61,W
058B:  BTFSC  03.0
058C:  INCFSZ 61,W
058D:  ADDWF  6F,F
058E:  MOVF   6F,W
058F:  MOVWF  71
0590:  MOVF   6E,W
0591:  MOVWF  70
0592:  CLRF   73
0593:  MOVLW  80
0594:  MOVWF  72
*
05D2:  MOVF   22,W
05D3:  MOVWF  23
05D4:  MOVF   21,W
05D5:  MOVWF  20
05D6:  MOVF   22,W
05D7:  MOVWF  21
05D8:  CLRF   22
05D9:  CLRF   23
05DA:  BTFSS  21.7
05DB:  GOTO   5DE
05DC:  DECF   22,F
05DD:  DECF   23,F
05DE:  MOVF   23,W
05DF:  MOVWF  67
05E0:  MOVF   22,W
05E1:  MOVWF  66
05E2:  MOVF   21,W
05E3:  MOVWF  65
05E4:  MOVF   20,W
05E5:  MOVWF  64
....................   if(ret > MAX_INT){ 
05E6:  BTFSC  67.7
05E7:  GOTO   5F9
05E8:  MOVF   67,F
05E9:  BTFSS  03.2
05EA:  GOTO   5F2
05EB:  MOVF   66,F
05EC:  BTFSS  03.2
05ED:  GOTO   5F2
05EE:  MOVF   65,W
05EF:  SUBLW  7F
05F0:  BTFSC  03.0
05F1:  GOTO   5F9
....................     ret = MAX_INT; 
05F2:  CLRF   67
05F3:  CLRF   66
05F4:  MOVLW  7F
05F5:  MOVWF  65
05F6:  MOVLW  FF
05F7:  MOVWF  64
....................   } 
....................   else if(ret < -MAX_INT){ 
05F8:  GOTO   618
05F9:  BTFSS  67.7
05FA:  GOTO   618
05FB:  MOVF   67,W
05FC:  SUBLW  FF
05FD:  BTFSS  03.0
05FE:  GOTO   618
05FF:  BTFSS  03.2
0600:  GOTO   611
0601:  MOVF   66,W
0602:  SUBLW  FF
0603:  BTFSS  03.0
0604:  GOTO   618
0605:  BTFSS  03.2
0606:  GOTO   611
0607:  MOVF   65,W
0608:  SUBLW  80
0609:  BTFSS  03.0
060A:  GOTO   618
060B:  BTFSS  03.2
060C:  GOTO   611
060D:  MOVF   64,W
060E:  SUBLW  00
060F:  BTFSS  03.0
0610:  GOTO   618
....................     ret = -MAX_INT; 
0611:  MOVLW  FF
0612:  MOVWF  67
0613:  MOVWF  66
0614:  MOVLW  80
0615:  MOVWF  65
0616:  MOVLW  01
0617:  MOVWF  64
....................   } 
....................  
....................   return((signed int16)ret); 
0618:  MOVF   64,W
0619:  MOVWF  21
061A:  MOVF   65,W
061B:  MOVWF  22
.................... } 
061C:  BSF    0A.3
061D:  GOTO   174 (RETURN)
....................  
.................... /*! \brief Resets the integrator. 
....................  * 
....................  *  Calling this function will reset the integrator in the PID regulator. 
....................  */ 
.................... void pid_Reset_Integrator(pidData_t *pid_st) 
.................... { 
....................   pid_st->sumError = 0; 
.................... } 
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
