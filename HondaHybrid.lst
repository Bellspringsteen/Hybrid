CCS PCM C Compiler, Version 4.084, 46530               03-Aug-13 14:26

               Filename: HondaHybrid.lst

               ROM used: 2192 words (54%)
                         Largest free fragment is 1436
               RAM used: 56 (29%) at main() level
                         103 (54%) worst case
               Stack:    3 worst case (2 in main + 1 for interrupts)

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  26
0008:  MOVF   7F,W
0009:  MOVWF  25
000A:  MOVF   0A,W
000B:  MOVWF  2D
000C:  CLRF   0A
000D:  SWAPF  25,F
000E:  MOVF   04,W
000F:  MOVWF  27
0010:  MOVF   20,W
0011:  MOVWF  28
0012:  MOVF   21,W
0013:  MOVWF  29
0014:  MOVF   22,W
0015:  MOVWF  2A
0016:  MOVF   23,W
0017:  MOVWF  2B
0018:  MOVF   24,W
0019:  MOVWF  2C
001A:  BCF    03.7
001B:  BCF    03.5
001C:  MOVLW  8C
001D:  MOVWF  04
001E:  BTFSS  00.0
001F:  GOTO   022
0020:  BTFSC  0C.0
0021:  GOTO   03F
0022:  MOVLW  8D
0023:  MOVWF  04
0024:  BTFSS  00.0
0025:  GOTO   028
0026:  BTFSC  0D.0
0027:  GOTO   041
0028:  BTFSS  0B.5
0029:  GOTO   02C
002A:  BTFSC  0B.2
002B:  GOTO   043
002C:  MOVF   27,W
002D:  MOVWF  04
002E:  MOVF   28,W
002F:  MOVWF  20
0030:  MOVF   29,W
0031:  MOVWF  21
0032:  MOVF   2A,W
0033:  MOVWF  22
0034:  MOVF   2B,W
0035:  MOVWF  23
0036:  MOVF   2C,W
0037:  MOVWF  24
0038:  MOVF   2D,W
0039:  MOVWF  0A
003A:  SWAPF  26,W
003B:  MOVWF  03
003C:  SWAPF  7F,F
003D:  SWAPF  7F,W
003E:  RETFIE
003F:  BCF    0A.3
0040:  GOTO   053
0041:  BCF    0A.3
0042:  GOTO   0AB
0043:  BCF    0A.3
0044:  GOTO   045
.................... //#define DEBUG 
.................... #include "HondaHybrid.h" 
.................... #include <16F873A.h> 
.................... //////// Standard Header file for the PIC16F873A device //////////////// 
.................... #device PIC16F873A 
.................... #list 
....................  
....................  
.................... #ifdef DEBUG 
....................    #device ICD=TRUE 
.................... #endif 
....................  
.................... #device adc=10 
.................... #use delay(clock=20000000) 
*
022B:  MOVLW  54
022C:  MOVWF  04
022D:  MOVF   00,W
022E:  BTFSC  03.2
022F:  GOTO   23D
0230:  MOVLW  06
0231:  MOVWF  21
0232:  CLRF   20
0233:  DECFSZ 20,F
0234:  GOTO   233
0235:  DECFSZ 21,F
0236:  GOTO   232
0237:  MOVLW  7B
0238:  MOVWF  20
0239:  DECFSZ 20,F
023A:  GOTO   239
023B:  DECFSZ 00,F
023C:  GOTO   230
023D:  RETLW  00
.................... #ifdef DEBUG 
....................    #use rs232 (DEBUGGER) 
.................... #endif 
.................... #fuses HS,PUT,NOWDT 
.................... #include <mcp4921.c> 
.................... //////////////// Driver for MCP4921 D/A Converter /////////////////////// 
.................... ////                                                                 //// 
.................... ////  init_dac()    Call this before using a MCP4921 DAC             //// 
.................... ////                                                                 //// 
.................... ////  write_dac( long int )   Writes command and 12 bit resolution   //// 
.................... ////                          to the MCP4921 which converts it to a  //// 
.................... ////                          voltage                                //// 
.................... ////                          0-4095 input represents 0-vref V out.  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SELECT 
....................  
.................... #define DAC_CS     PIN_C4 
.................... #define DAC_CLK    PIN_C3 
.................... #define DAC_DI     PIN_C5 
.................... #define DAC_LDAC   PIN_B5 
....................  
.................... #endif 
....................  
.................... void init_dac() 
.................... { 
....................    output_high(DAC_CS); 
*
00C8:  BCF    2E.4
00C9:  MOVF   2E,W
00CA:  BSF    03.5
00CB:  MOVWF  07
00CC:  BCF    03.5
00CD:  BSF    07.4
....................    output_high(DAC_LDAC); 
00CE:  BSF    03.5
00CF:  BCF    06.5
00D0:  BCF    03.5
00D1:  BSF    06.5
....................    output_high(DAC_CLK); 
00D2:  BCF    2E.3
00D3:  MOVF   2E,W
00D4:  BSF    03.5
00D5:  MOVWF  07
00D6:  BCF    03.5
00D7:  BSF    07.3
....................    output_high(DAC_DI); 
00D8:  BCF    2E.5
00D9:  MOVF   2E,W
00DA:  BSF    03.5
00DB:  MOVWF  07
00DC:  BCF    03.5
00DD:  BSF    07.5
.................... } 
00DE:  BSF    0A.3
00DF:  GOTO   047 (RETURN)
....................  
.................... void write_dac(int16 data) { 
....................    BYTE cmd[3]; 
....................    BYTE i; 
....................  
....................    cmd[0]=data; 
00E0:  MOVF   57,W
00E1:  MOVWF  59
....................    cmd[1]=(data>>8); 
00E2:  MOVF   58,W
00E3:  MOVWF  5A
....................    cmd[2]=0x03;                            
00E4:  MOVLW  03
00E5:  MOVWF  5B
....................     
....................    output_high(DAC_LDAC); 
00E6:  BSF    03.5
00E7:  BCF    06.5
00E8:  BCF    03.5
00E9:  BSF    06.5
....................    output_low(DAC_CLK); 
00EA:  BCF    2E.3
00EB:  MOVF   2E,W
00EC:  BSF    03.5
00ED:  MOVWF  07
00EE:  BCF    03.5
00EF:  BCF    07.3
....................    output_low(DAC_CS); 
00F0:  BCF    2E.4
00F1:  MOVF   2E,W
00F2:  BSF    03.5
00F3:  MOVWF  07
00F4:  BCF    03.5
00F5:  BCF    07.4
....................  
....................    for(i=0; i<=23; ++i) 
00F6:  CLRF   5C
00F7:  MOVF   5C,W
00F8:  SUBLW  17
00F9:  BTFSS  03.0
00FA:  GOTO   128
....................    { 
....................       if(i<4 || (i>7 && i<12)) 
00FB:  MOVF   5C,W
00FC:  SUBLW  03
00FD:  BTFSC  03.0
00FE:  GOTO   107
00FF:  MOVF   5C,W
0100:  SUBLW  07
0101:  BTFSC  03.0
0102:  GOTO   10C
0103:  MOVF   5C,W
0104:  SUBLW  0B
0105:  BTFSS  03.0
0106:  GOTO   10C
....................          shift_left(cmd,3,0); 
0107:  BCF    03.0
0108:  RLF    59,F
0109:  RLF    5A,F
010A:  RLF    5B,F
....................       else 
010B:  GOTO   126
....................       { 
....................          output_bit(DAC_DI, shift_left(cmd,3,0)); 
010C:  BCF    03.0
010D:  RLF    59,F
010E:  RLF    5A,F
010F:  RLF    5B,F
0110:  BTFSC  03.0
0111:  GOTO   114
0112:  BCF    07.5
0113:  GOTO   115
0114:  BSF    07.5
0115:  BCF    2E.5
0116:  MOVF   2E,W
0117:  BSF    03.5
0118:  MOVWF  07
....................  
....................          output_high(DAC_CLK); 
0119:  BCF    03.5
011A:  BCF    2E.3
011B:  MOVF   2E,W
011C:  BSF    03.5
011D:  MOVWF  07
011E:  BCF    03.5
011F:  BSF    07.3
....................          output_low(DAC_CLK); 
0120:  BCF    2E.3
0121:  MOVF   2E,W
0122:  BSF    03.5
0123:  MOVWF  07
0124:  BCF    03.5
0125:  BCF    07.3
....................       } 
....................    } 
0126:  INCF   5C,F
0127:  GOTO   0F7
....................    output_high(DAC_CS); 
0128:  BCF    2E.4
0129:  MOVF   2E,W
012A:  BSF    03.5
012B:  MOVWF  07
012C:  BCF    03.5
012D:  BSF    07.4
....................  
....................    output_low(DAC_LDAC); 
012E:  BSF    03.5
012F:  BCF    06.5
0130:  BCF    03.5
0131:  BCF    06.5
....................    delay_us(10); 
0132:  MOVLW  10
0133:  MOVWF  20
0134:  DECFSZ 20,F
0135:  GOTO   134
0136:  NOP
....................     
....................    output_HIGH(DAC_LDAC); 
0137:  BSF    03.5
0138:  BCF    06.5
0139:  BCF    03.5
013A:  BSF    06.5
.................... } 
013B:  RETLW  00
....................  
....................  
....................  
.................... #include "pid.h" 
.................... /*This file has been prepared for Doxygen automatic documentation generation.*/ 
.................... /*! \file ********************************************************************* 
....................  * 
....................  * \brief Header file for pid.c. 
....................  * 
....................  * - File:               pid.h 
....................  * - Compiler:           IAR EWAAVR 4.11A 
....................  * - Supported devices:  All AVR devices can be used. 
....................  * - AppNote:            AVR221 - Discrete PID controller 
....................  * 
....................  * \author               Atmel Corporation: http://www.atmel.com \n 
....................  *                       Support email: avr@atmel.com 
....................  * 
....................  * $Name$ 
....................  * $Revision: 456 $ 
....................  * $RCSfile$ 
....................  * $Date: 2006-02-16 12:46:13 +0100 (to, 16 feb 2006) $ 
....................  *****************************************************************************/ 
....................  
.................... #ifndef PID_H 
.................... #define PID_H 
....................  
.................... //#include "stdint.h" 
.................... #define INT16_MAX 32767 
.................... #define INT32_MAX 2147483647 
.................... #define SCALING_FACTOR  128 
....................  
.................... /*! \brief PID Status 
....................  * 
....................  * Setpoints and data used by the PID control algorithm 
....................  */ 
.................... typedef struct PID_DATA{ 
....................   //! Last process value, used to find derivative of process value. 
....................   int16 lastProcessValue; 
....................   //! Summation of errors, used for integrate calculations 
....................   int32 sumError; 
....................   //! The Proportional tuning constant, multiplied with SCALING_FACTOR 
....................   int16 P_Factor; 
....................   //! The Integral tuning constant, multiplied with SCALING_FACTOR 
....................   int16 I_Factor; 
....................   //! The Derivative tuning constant, multiplied with SCALING_FACTOR 
....................   int16 D_Factor; 
....................   //! Maximum allowed error, avoid overflow 
....................   int16 maxError; 
....................   //! Maximum allowed sumerror, avoid overflow 
....................   int32 maxSumError; 
.................... } pidData_t; 
....................  
.................... /*! \brief Maximum values 
....................  * 
....................  * Needed to avoid sign/overflow problems 
....................  */ 
.................... // Maximum value of variables 
.................... #define MAX_INT         INT16_MAX 
.................... #define MAX_LONG        INT32_MAX 
.................... #define MAX_I_TERM      (MAX_LONG / 2) 
....................  
.................... // Boolean values 
.................... //#define FALSE           0 
.................... //#define TRUE            1 
....................  
.................... boolean checkRunnaway(struct PID_DATA *pid); 
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid); 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st); 
.................... void pid_Reset_Integrator(pidData_t *pid_st); 
....................  
.................... #endif 
....................  
.................... /* 
.................... This is the main controller for the super capacitor hybrid scooter a.k.a RED 
.................... B2 close contactor 
.................... CONTROL BOX INPUTS 
.................... Athrottle- A0 - analog input representing the users input for speed, 10 bit 
.................... Vspeed - CCp2-a 16 bit representation of the speed of the vehicle 
.................... Acaps- A1 - analog input representing the current voltage of the supercapacitors, 10 bit 
.................... There are 18 Supercaps with a maximum voltage of 2.7 (2.85 is breakdown) volts for a total of 48.6 V 
.................... The circuit has a 10/110 voltage divider into the ADC. So minimum voltage of 18 Volts is 335 and 48 Volts is 893. Measured 38.2V equal to 726 
....................  
.................... CONTROL BOX OUTPUT 
.................... ICEthrottle- B1 - a 16 bit number sent to the internal combustion engine(ICE) throttle  
.................... ELECthrottle-  - a 16 bit number sent as analog value representing the demanded electric power 
....................  
.................... SPECIFICS OF I/O 
....................  
.................... Athrottle - the electric throttle is a 3 wire unit with a 5 volt,ground, and analog out 
....................    representing how far throttle is turned. Pin AN0 is the input. 
....................     
.................... Vspeed - There is a encoder in the rear wheel/electric motor that is used by the electric 
....................    power controller. Tapping in to this this Main Controller receives a 5 Volt square wave 
....................    with 42 pulses. There are two options for measuring speed. The first is to measure the  
....................    length of the pulses. The second is to measure the rate of pulses. This controller currently 
....................    uses the rate method. The int_ccp2 interupt is called on each falling edge and stores the  
....................    Vspeed value as the max number of 16bit (65535-timer0_since_last_reset).  
....................     
....................    The RED scooter has a circumpherence of 16.3*2*pi = 102.4 
....................    X m/h * 63360 inch/mile * 1/3600 h/sec * 1/(102.4 inch/rev) = .171875* X 
....................    Examples 50 mph is 8.9 ms 1 overflow of timer0 
....................    Example 5 mph is 89 ms or 13 time overflow 
....................     
....................    #int_timer0 increments the counter number_of_overflows each time it overflows 
....................    On int ccp2 we multiply number_of_overflows * 256 + timer0 to get timer0_since_last_reset 
....................     
.................... Acaps - the analog voltage which is the 5volt representation of the voltage in the caps which 
....................    have a value of between 0-48v. The voltages are factored so that the voltage on AN1 goes 
....................    from 0 - 4.8 volts (TODO check this factor, think its 1/11 not 1/10) 
....................     
.................... ICEthrottle -  #int_timer1 is set to make sure the period follows the required below 
....................    The period for the servo is .020 seconds which is 50,000 operations 
....................    The leftmost position of the server is .001 seconds which is 2,500 
....................    The rightmost position of the server is .002 seconds which is 5,000 
....................     
....................    The output pin is pin_B1.-> 
....................  
.................... ELECthrottle 
....................    The electric power controller takes an analog voltage as input. The output voltage 
....................    is set by the DAC. The pins used are C3,C4,C5. if CHARGING_STATE is true then  
....................     
.................... ALGORITHM 
....................    The algorithm is basically a PID controller. In broad terms we are trying to set the 
....................    ICEthrottle and ICEelectric to maximize the use of electric and accelerate to meet the 
....................    requirements set by the rider with the Athrottle signal. When the demanded power is  
....................    less than the power output possible by the ICE and the caps are in the CHARGING_STATE  
....................    then the ICE is turned up to the max and the ELECthrottle is set to regen to 
....................    charge the capacitors.If CHARGING_STATE is false then the caps are supplying the drivig power 
....................    and the ICE is set to "off", the caps supply the power. Unless the user requested supply 
....................    is enough to require both power sources. 
....................     
....................    If CHARGING_STATE is true. Then pin_b2 is set as high which will close the brake number 
....................    for the electric power controller.  
....................     
....................    If CHARGING_STATE is false then the pin_b2 is set low which opens brake. 
....................     
....................     
....................  
....................  
.................... The encoder has 42 on and offs per rotation, i.e. 21 steps 
....................  
.................... Number of operations per second is CLOCK/4/Timer Divisions 
.................... Number of operations per second is 20,000,000/4/128 = 39062.5  
.................... Each operation takes 1/39062.5 = .256 micro (x10^-6) seconds 
.................... Seconds to Overflow timer0 8bit timer = .256x10^-6 * 256 = 6.55ms 
....................  
....................  
....................  
.................... */ 
.................... #define servo_pin PIN_B1  //Setting servo out pin to be hardware pin b1 
.................... #define brake_pin PIN_B4 
.................... #define ADC_DELAY delay_us(20) 
.................... #define Acaps_pin PIN_A1 
.................... #define Acaps_channel 1 
.................... #define Athrottle_pin PIN_A0  //Voltage goes from 1.5 (306)to 4.1(836) 
.................... #define Athrottle_Min 316 
.................... #define Athrottle_Max 860 
.................... #define Athrottle_Full Athrottle_Max-Athrottle_Min 
.................... #define Athrottle_channel 0 
.................... #define Electric_Controller_Switch PIN_B0 
.................... #define Contactor_Switch PIN_B2 
.................... #define A_CAPS_MAX 725//893 
.................... #define A_CAPS_MIN 335 
.................... #define A_CAPS_MID_LOW (A_CAPS_MIN + 100) //This is the low end of the middle ACaps range. The range in which discharge and charge are allowed.  
.................... #define A_CAPS_MID_HIGH (A_CAPS_MAX - 100) //This is the low end of the middle ACaps range. The range in which discharge and charge are allowed.  
.................... #define V_SPEED_REGEN_MIN 50 //Why is there a minimum speed? Because below this no regenerative action is possible with electric motor 
.................... #define INSUFFICIENT_BRAKING_RUNNAWAY_ERROR 50000 
....................  
.................... //PID Values 
.................... #define K_P 1.50 
.................... #define K_I 0.00 
.................... #define K_D 0.20 
....................  
.................... struct PID_DATA pidData; 
.................... #define TIME_INTERVAL 157 //TODO replace 
....................  
.................... #define left_position 3900//4450 
.................... #define right_position 6100 
.................... #define servo_difference  right_position-left_position 
.................... #define servo_difference_div 5200 
.................... #define ELEC_CONTROLLER_OFFSET 900 
.................... //const float Athrottle_servo_factor = ((float) servo_difference)/((float) Athrottle_FULL); 
.................... #define servo_period   65356-50000 
.................... unsigned int16 current_servo_position=right_position; 
*
080D:  MOVLW  D4
080E:  MOVWF  41
080F:  MOVLW  17
0810:  MOVWF  42
.................... int1 SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0; 
0811:  BCF    43.0
....................  
.................... unsigned int16 number_of_timer0_interupts_since_reset =0; 
0812:  CLRF   44
0813:  CLRF   45
.................... unsigned int16 vSpeed= 0; 
0814:  CLRF   46
0815:  CLRF   47
.................... signed int16 ELECthrottle = 0; 
0816:  CLRF   48
0817:  CLRF   49
.................... unsigned int16 ICEthrottle = 0; 
0818:  CLRF   4A
0819:  CLRF   4B
.................... unsigned int16 Athrottle = 0; 
081A:  CLRF   4C
081B:  CLRF   4D
.................... unsigned int16 Acaps = 0; 
081C:  CLRF   4E
081D:  CLRF   4F
.................... int1 ICE_ON = 0; 
081E:  BCF    43.1
.................... int1 CURRENTLY_CHARGING = 0; 
081F:  BCF    43.2
.................... int1 RUNNAWAY_CHECK = 0; 
0820:  BCF    43.3
.................... signed int16 returnedValue =0;  
0821:  CLRF   50
0822:  CLRF   51
....................  
.................... enum{  
....................    EVERYTHING_OFF, 
....................    SPEED_TO_LOW_ICE_DIRECT, 
....................    CHARGING_ALLOWED,  
....................    DISCHARGING_ALLOWED,  
....................    CHARGING_AND_DISCHARING_ALLOWED, 
....................    INSUFFICIENT_BRAKING_RUNAWAY, 
....................    USER_INPUT_OFF 
.................... } CHARGING_STATE;  
....................  
.................... /* 
.................... The #int_timer0 interupt is triggered on each timer0 8bit interupt 
.................... the function simply increments a overflow counter to be used by the ccp2 
.................... interupt to calculate speed 
.................... NUMBER OF OPERATIONS =  
.................... */ 
.................... #int_timer0 
.................... void timer0_isr(){ 
....................     
....................       number_of_timer0_interupts_since_reset=number_of_timer0_interupts_since_reset+256; 
*
0045:  MOVLW  01
0046:  ADDWF  45,F
....................       //current_servo_position=current_servo_position+1; 
....................        
....................     
....................    if (number_of_timer0_interupts_since_reset>=1024){ 
0047:  MOVF   45,W
0048:  SUBLW  03
0049:  BTFSC  03.0
004A:  GOTO   050
....................       vSpeed = 0; 
004B:  CLRF   47
004C:  CLRF   46
....................       number_of_timer0_interupts_since_reset=1024; 
004D:  MOVLW  04
004E:  MOVWF  45
004F:  CLRF   44
....................        
....................        
....................    } 
.................... } 
....................  
.................... /* 
.................... #int_timer1 is used by the ICEservo throttle to regulate the timing pulses. The  
.................... timer is setup for a pulsetrain of 20ms period. This is done as follows, 
....................  
.................... Period is 1/(CLOCK/4opsperclock)*(startingPostionOfClock) = 20 ms 
.................... for this setup 1/(20000000/4)*(50000) = 20 ms 
....................  
.................... The timer1 starts at 0 and counts up. So we set the beggining of the clock at 
.................... servo_period which is 65356-50000 so that the total time is 20ms. 
.................... */ 
0050:  BCF    0B.2
0051:  BCF    0A.3
0052:  GOTO   02C
.................... #int_timer1 
.................... void isr() 
.................... { 
....................  
.................... //Make sure that the position is within the left and right positions of the servo 
....................    if (current_servo_position<left_position){ 
0053:  MOVF   42,W
0054:  SUBLW  0F
0055:  BTFSS  03.0
0056:  GOTO   062
0057:  BTFSS  03.2
0058:  GOTO   05D
0059:  MOVF   41,W
005A:  SUBLW  3B
005B:  BTFSS  03.0
005C:  GOTO   062
....................       current_servo_position = left_position; 
005D:  MOVLW  0F
005E:  MOVWF  42
005F:  MOVLW  3C
0060:  MOVWF  41
....................    } 
....................    else if (current_servo_position > right_position){ 
0061:  GOTO   071
0062:  MOVF   42,W
0063:  SUBLW  16
0064:  BTFSC  03.0
0065:  GOTO   071
0066:  XORLW  FF
0067:  BTFSS  03.2
0068:  GOTO   06D
0069:  MOVF   41,W
006A:  SUBLW  D4
006B:  BTFSC  03.0
006C:  GOTO   071
....................       current_servo_position = right_position; 
006D:  MOVLW  17
006E:  MOVWF  42
006F:  MOVLW  D4
0070:  MOVWF  41
....................    } 
.................... //printf("Current servo position %ld",current_servo_position); 
....................    if(SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER) 
0071:  BTFSS  43.0
0072:  GOTO   090
....................       {  
....................          output_high(servo_pin);        //Set the servo control pin to high  
0073:  BSF    03.5
0074:  BCF    06.1
0075:  BCF    03.5
0076:  BSF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0;  
0077:  BCF    43.0
....................          set_timer1(65356-current_servo_position); //Set timer for the position high pulse 
0078:  MOVF   41,W
0079:  SUBLW  4C
007A:  BSF    03.5
007B:  MOVWF  25
007C:  MOVLW  FF
007D:  MOVWF  26
007E:  BCF    03.5
007F:  MOVF   42,W
0080:  BTFSS  03.0
0081:  INCFSZ 42,W
0082:  GOTO   084
0083:  GOTO   087
0084:  BSF    03.5
0085:  SUBWF  26,F
0086:  BCF    03.5
0087:  BSF    03.5
0088:  MOVF   26,W
0089:  BCF    03.5
008A:  MOVWF  0F
008B:  BSF    03.5
008C:  MOVF   25,W
008D:  BCF    03.5
008E:  MOVWF  0E
....................       }  
....................    else  
008F:  GOTO   0A8
....................       {  
....................          output_low(servo_pin);                      // Set the servo control pin to low   
0090:  BSF    03.5
0091:  BCF    06.1
0092:  BCF    03.5
0093:  BCF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 1;  
0094:  BSF    43.0
....................          set_timer1(servo_period+current_servo_position);          //Set timer for the low position the length is the difference between  
0095:  MOVLW  FC
0096:  ADDWF  41,W
0097:  BSF    03.5
0098:  MOVWF  25
0099:  BCF    03.5
009A:  MOVF   42,W
009B:  BSF    03.5
009C:  MOVWF  26
009D:  MOVLW  3B
009E:  BTFSC  03.0
009F:  MOVLW  3C
00A0:  ADDWF  26,F
00A1:  MOVF   26,W
00A2:  BCF    03.5
00A3:  MOVWF  0F
00A4:  BSF    03.5
00A5:  MOVF   25,W
00A6:  BCF    03.5
00A7:  MOVWF  0E
....................                                                      //the total int16 lenght - high pulse length 
....................       }   
....................  
.................... } 
....................  
....................  
.................... /* 
.................... #int_ccp2 is called on the falling edge of the encoder pulse. We calculate the time 
.................... between pulses.  
.................... TODO will have to put some kind of smoothing mechanism 
.................... */ 
00A8:  BCF    0C.0
00A9:  BCF    0A.3
00AA:  GOTO   02C
.................... #int_ccp2 
.................... void isr2() 
.................... { 
.................... if (number_of_timer0_interupts_since_reset>10){ 
00AB:  MOVF   45,F
00AC:  BTFSS  03.2
00AD:  GOTO   0B2
00AE:  MOVF   44,W
00AF:  SUBLW  0A
00B0:  BTFSC  03.0
00B1:  GOTO   0C5
.................... vSpeed  = 1280 - (number_of_timer0_interupts_since_reset+get_timer0()); 
00B2:  MOVF   01,W
00B3:  ADDWF  44,W
00B4:  MOVWF  21
00B5:  MOVF   45,W
00B6:  MOVWF  23
00B7:  BTFSC  03.0
00B8:  INCF   23,F
00B9:  MOVF   21,W
00BA:  SUBLW  00
00BB:  MOVWF  46
00BC:  MOVLW  05
00BD:  MOVWF  47
00BE:  MOVF   23,W
00BF:  BTFSS  03.0
00C0:  INCFSZ 23,W
00C1:  SUBWF  47,F
.................... //vSpeed  = -(get_timer0()); 
.................... set_timer0(0); 
00C2:  CLRF   01
.................... number_of_timer0_interupts_since_reset = 0; 
00C3:  CLRF   45
00C4:  CLRF   44
.................... } 
.................... } 
....................  
00C5:  BCF    0D.0
00C6:  BCF    0A.3
00C7:  GOTO   02C
.................... void trickBreaking(){ 
.................... write_dac((unsigned int16) 400+ELEC_CONTROLLER_OFFSET); 
*
061E:  MOVLW  05
061F:  MOVWF  58
0620:  MOVLW  14
0621:  MOVWF  57
0622:  CALL   0E0
.................... delay_ms(500);       
0623:  MOVLW  02
0624:  MOVWF  53
0625:  MOVLW  FA
0626:  MOVWF  54
0627:  CALL   22B
0628:  DECFSZ 53,F
0629:  GOTO   625
.................... } 
062A:  BSF    0A.3
062B:  GOTO   1ED (RETURN)
....................  
.................... void printfLogf(char string){ 
....................    #ifdef DEBUG 
....................       printf("IN PrintfLog"); 
....................       printf("%c",string); 
....................    #else 
....................       delay_ms(250); 
....................    #endif 
.................... } 
....................  
.................... #ifdef TEST 
....................  
.................... /* 
.................... TEST SUITE 
.................... */ 
....................  
.................... void createHeartbeat(){ 
....................   //This creates a heartbeat on pin B1 
....................   while (1){ 
....................            output_high(servo_pin);        //Set the servo control pin to high 
....................            delay_ms(1000); 
....................            output_low(servo_pin); 
....................            delay_ms(1000); 
....................     } 
.................... } 
....................  
.................... void wiperAnalogVoltage(){ 
....................   
....................  //signed int16 test =0; 
....................  unsigned int16 wiperValue = 0; 
....................     while (1){ 
.................... printf("Wiper Value is now %ld",wiperValue); 
....................    
....................   if (wiperValue>(4095)){ 
....................      wiperValue = 0; 
....................     printf("Wiper Value is now %ld",wiperValue); 
....................   } 
....................   wiperValue=wiperValue+10; 
....................   write_dac(wiperValue); 
....................   delay_ms(10); 
....................     } 
.................... } 
....................  
.................... void heartbeatElectricControllerPower(){ 
....................     while (1){ 
....................  
....................   output_high(Contactor_Switch);        //Set the servo control pin to high 
....................            delay_ms(1000); 
....................            output_low(Contactor_Switch); 
....................            delay_ms(1000); 
....................     } 
.................... } 
....................  
.................... void wiperServo(){ 
....................     while (1){ 
....................  
....................   unsigned int16 wiperValue = servo_difference; 
....................   current_servo_position =right_position-wiperValue; 
....................   wiperValue--; 
....................   if (wiperValue<0){ 
....................     wiperValue = servo_difference; 
....................   } 
....................   delay_ms(10); 
....................     } 
.................... } 
....................  
.................... void printAnalogThrottleInput(){ 
....................     set_adc_channel(Athrottle_channel); 
....................       ADC_DELAY; 
....................       Athrottle = read_adc(); 
....................   printf("Analog Throttle is %ld",Athrottle ); 
.................... } 
....................  
.................... void main() 
.................... { 
....................  
....................    setup_adc_ports(NO_ANALOGS); 
....................    setup_adc(ADC_OFF); 
....................    setup_spi(FALSE); 
....................  
....................    setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
....................    setup_timer_1(T1_DISABLED); 
....................    setup_timer_2(T2_DISABLED,0,1); 
....................    setup_port_a(ALL_ANALOG); 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
....................  
....................    init_dac(); 
....................  
....................    setup_timer_1(T1_DIV_BY_2| T1_INTERNAL); 
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_128); 
....................    setup_ccp2(CCP_CAPTURE_RE);    // Configure CCP2 to capture fall 
....................    enable_interrupts(INT_CCP2);   // Setup interrupt on falling edge 
....................    enable_interrupts(INT_TIMER0); 
....................    enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
....................    enable_interrupts(GLOBAL); 
....................  
....................    while(TRUE) { 
....................         //Test Breaking Analog Voltage. Should produce analog voltage  on pin 13 as well as drive pin 12 LOW 
....................         //output_high(brake_pin); 
....................         //output_high(Electric_Controller_Switch); 
....................         //wiperAnalogVoltage(); 
....................  
....................         //Test Accelerating Analog Voltage. Should produce analog voltage on pin 15 and let pin 12 float. 
....................         //output_low(brake_pin); 
....................         //output_low(Electric_Controller_Switch); 
....................         //wiperAnalogVoltage(); 
....................          
....................         //Test Short Circuit from Pin 11 to pin 8 with 1 second heartbeat. This tests V+ Controller. Also pin 9 should be heartbeating between 0 and 12V 
....................         //heartbeatElectricControllerPower(); 
....................  
....................         //Test Wiper of Servo 
....................         //wiperServo(); 
....................  
....................        //printAnalogThrottleInput(); 
....................         
....................        //Test Electric Controller Out 
....................        output_high(Contactor_Switch); 
....................        output_high(Contactor_Switch2); 
....................  
....................    } 
....................  
....................  
.................... } 
....................  
....................  
....................  
.................... #else 
.................... void main() 
.................... {   
*
0800:  CLRF   04
0801:  MOVLW  1F
0802:  ANDWF  03,F
0803:  BSF    03.5
0804:  BSF    1F.0
0805:  BSF    1F.1
0806:  BSF    1F.2
0807:  BCF    1F.3
0808:  MOVLW  07
0809:  MOVWF  1C
....................     
....................    setup_adc_ports(NO_ANALOGS); 
*
0823:  BSF    03.5
0824:  BSF    1F.0
0825:  BSF    1F.1
0826:  BSF    1F.2
0827:  BCF    1F.3
....................    setup_adc(ADC_OFF); 
0828:  BCF    03.5
0829:  BCF    1F.0
....................    setup_spi(FALSE); 
082A:  CLRF   14
....................     
....................    setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
082B:  BSF    03.5
082C:  MOVF   01,W
082D:  ANDLW  C0
082E:  IORLW  00
082F:  MOVWF  01
0830:  CLRWDT
....................    setup_timer_1(T1_DISABLED); 
0831:  BCF    03.5
0832:  CLRF   10
....................    setup_timer_2(T2_DISABLED,0,1); 
0833:  MOVLW  00
0834:  MOVWF  21
0835:  MOVWF  12
0836:  MOVLW  00
0837:  BSF    03.5
0838:  MOVWF  12
....................    setup_port_a(ALL_ANALOG); 
0839:  BCF    1F.0
083A:  BCF    1F.1
083B:  BCF    1F.2
083C:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
083D:  BCF    1F.6
083E:  BCF    03.5
083F:  BSF    1F.6
0840:  BSF    1F.7
0841:  BSF    03.5
0842:  BSF    1F.7
0843:  BCF    03.5
0844:  BSF    1F.0
....................     
....................    init_dac(); 
0845:  BCF    0A.3
0846:  GOTO   0C8
0847:  BSF    0A.3
....................   
....................    setup_timer_1(T1_DIV_BY_2| T1_INTERNAL);  
0848:  MOVLW  95
0849:  MOVWF  10
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_128); 
084A:  BSF    03.5
084B:  MOVF   01,W
084C:  ANDLW  C0
084D:  IORLW  06
084E:  MOVWF  01
....................    setup_ccp2(CCP_CAPTURE_RE);    // Configure CCP2 to capture fall 
084F:  BCF    03.5
0850:  BSF    2E.1
0851:  MOVF   2E,W
0852:  BSF    03.5
0853:  MOVWF  07
0854:  BCF    03.5
0855:  CLRF   1D
0856:  MOVLW  05
0857:  MOVWF  1D
....................    enable_interrupts(INT_CCP2);   // Setup interrupt on falling edge 
0858:  BSF    03.5
0859:  BSF    0D.0
....................    enable_interrupts(INT_TIMER0); 
085A:  BCF    03.5
085B:  BSF    0B.5
....................    enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
085C:  BSF    03.5
085D:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
085E:  MOVLW  C0
085F:  BCF    03.5
0860:  IORWF  0B,F
....................     
....................    CHARGING_STATE = EVERYTHING_OFF; 
0861:  CLRF   52
....................    output_low(Electric_Controller_Switch); 
0862:  BSF    03.5
0863:  BCF    06.0
0864:  BCF    03.5
0865:  BCF    06.0
....................    write_dac(0); 
0866:  CLRF   58
0867:  CLRF   57
0868:  BCF    0A.3
0869:  CALL   0E0
086A:  BSF    0A.3
....................    ICE_ON=TRUE; 
086B:  BSF    43.1
....................    output_high(Contactor_Switch); 
086C:  BSF    03.5
086D:  BCF    06.2
086E:  BCF    03.5
086F:  BSF    06.2
....................    output_low(brake_pin); 
0870:  BSF    03.5
0871:  BCF    06.4
0872:  BCF    03.5
0873:  BCF    06.4
....................    pid_Init(K_P*SCALING_FACTOR,K_I*SCALING_FACTOR,K_D*SCALING_FACTOR, & pidData); 
0874:  CLRF   54
0875:  MOVLW  C0
0876:  MOVWF  53
0877:  CLRF   56
0878:  CLRF   55
0879:  CLRF   58
087A:  MOVLW  19
087B:  MOVWF  57
087C:  MOVLW  2F
087D:  MOVWF  59
087E:  BCF    0A.3
087F:  GOTO   13C
0880:  BSF    0A.3
....................    delay_ms(3000); 
0881:  MOVLW  0C
0882:  MOVWF  53
0883:  MOVLW  FA
0884:  MOVWF  54
0885:  BCF    0A.3
0886:  CALL   22B
0887:  BSF    0A.3
0888:  DECFSZ 53,F
0889:  GOTO   083
....................    current_servo_position =right_position-800; 
088A:  MOVLW  14
088B:  MOVWF  42
088C:  MOVLW  B4
088D:  MOVWF  41
....................    delay_ms(2000); 
088E:  MOVLW  08
088F:  MOVWF  53
0890:  MOVLW  FA
0891:  MOVWF  54
0892:  BCF    0A.3
0893:  CALL   22B
0894:  BSF    0A.3
0895:  DECFSZ 53,F
0896:  GOTO   090
....................    current_servo_position =right_position; 
0897:  MOVLW  17
0898:  MOVWF  42
0899:  MOVLW  D4
089A:  MOVWF  41
....................    //write_dac(1000); 
....................    //delay_ms(10000); 
....................    //output_high(Contactor_Switch); 
....................    //output_high(brake_pin); 
....................    //output_high(Electric_Controller_Switch); 
....................    while(TRUE) { 
....................        
....................       //GET INPUTS 
....................       //Vspeedhappens in interrupts 
....................       set_adc_channel(Acaps_channel); 
089B:  MOVLW  08
089C:  MOVWF  21
089D:  MOVF   1F,W
089E:  ANDLW  C7
089F:  IORWF  21,W
08A0:  MOVWF  1F
....................       ADC_DELAY; 
08A1:  MOVLW  21
08A2:  MOVWF  20
08A3:  DECFSZ 20,F
08A4:  GOTO   0A3
....................       Acaps = read_adc(); 
08A5:  BSF    1F.2
08A6:  BTFSC  1F.2
08A7:  GOTO   0A6
08A8:  BSF    03.5
08A9:  MOVF   1E,W
08AA:  BCF    03.5
08AB:  MOVWF  4E
08AC:  MOVF   1E,W
08AD:  MOVWF  4F
....................        
....................       set_adc_channel(Athrottle_channel); 
08AE:  MOVLW  00
08AF:  MOVWF  21
08B0:  MOVF   1F,W
08B1:  ANDLW  C7
08B2:  IORWF  21,W
08B3:  MOVWF  1F
....................       ADC_DELAY; 
08B4:  MOVLW  21
08B5:  MOVWF  20
08B6:  DECFSZ 20,F
08B7:  GOTO   0B6
....................       Athrottle = read_adc(); 
08B8:  BSF    1F.2
08B9:  BTFSC  1F.2
08BA:  GOTO   0B9
08BB:  BSF    03.5
08BC:  MOVF   1E,W
08BD:  BCF    03.5
08BE:  MOVWF  4C
08BF:  MOVF   1E,W
08C0:  MOVWF  4D
....................       if (Athrottle<Athrottle_Min){ 
08C1:  MOVF   4D,W
08C2:  SUBLW  01
08C3:  BTFSS  03.0
08C4:  GOTO   0CF
08C5:  BTFSS  03.2
08C6:  GOTO   0CB
08C7:  MOVF   4C,W
08C8:  SUBLW  3B
08C9:  BTFSS  03.0
08CA:  GOTO   0CF
....................          Athrottle=Athrottle_Min; 
08CB:  MOVLW  01
08CC:  MOVWF  4D
08CD:  MOVLW  3C
08CE:  MOVWF  4C
....................       } 
....................       //SET THE STATE 
....................       if (Acaps> (A_CAPS_MAX +10)){ 
08CF:  MOVF   4F,W
08D0:  SUBLW  01
08D1:  BTFSC  03.0
08D2:  GOTO   0E7
08D3:  XORLW  FF
08D4:  BTFSS  03.2
08D5:  GOTO   0DA
08D6:  MOVF   4E,W
08D7:  SUBLW  DF
08D8:  BTFSC  03.0
08D9:  GOTO   0E7
....................          //FREAK OUT 
....................          //printf("State: Freak Out \n"); 
....................          output_low(Electric_Controller_Switch); 
08DA:  BSF    03.5
08DB:  BCF    06.0
08DC:  BCF    03.5
08DD:  BCF    06.0
....................          write_dac(0); 
08DE:  CLRF   58
08DF:  CLRF   57
08E0:  BCF    0A.3
08E1:  CALL   0E0
08E2:  BSF    0A.3
....................          //ICE_ON = FALSE; 
....................          ICEthrottle = 0; 
08E3:  CLRF   4B
08E4:  CLRF   4A
....................          //output_high(Contactor_Switch); 
....................          CHARGING_STATE =EVERYTHING_OFF; 
08E5:  CLRF   52
....................         //return; 
....................         //break; 
....................       } 
....................       else if (Athrottle<(Athrottle_Min+5)){ 
08E6:  GOTO   160
08E7:  MOVF   4D,W
08E8:  SUBLW  01
08E9:  BTFSS  03.0
08EA:  GOTO   0F9
08EB:  BTFSS  03.2
08EC:  GOTO   0F1
08ED:  MOVF   4C,W
08EE:  SUBLW  40
08EF:  BTFSS  03.0
08F0:  GOTO   0F9
....................          CHARGING_STATE = USER_INPUT_OFF; 
08F1:  MOVLW  06
08F2:  MOVWF  52
....................          #ifdef DEBUG 
....................             printf("State: Throttle Off \n");   
....................          #else 
....................             delay_ms(250); 
08F3:  MOVLW  FA
08F4:  MOVWF  54
08F5:  BCF    0A.3
08F6:  CALL   22B
08F7:  BSF    0A.3
....................          #endif 
....................           
....................          } 
....................       else if (ICE_ON&&(vSpeed<V_SPEED_REGEN_MIN)){ 
08F8:  GOTO   160
08F9:  BTFSS  43.1
08FA:  GOTO   10A
08FB:  MOVF   47,F
08FC:  BTFSS  03.2
08FD:  GOTO   10A
08FE:  MOVF   46,W
08FF:  SUBLW  31
0900:  BTFSS  03.0
0901:  GOTO   10A
....................          #ifdef DEBUG 
....................             printf("State: Speed To Low %ld \n",vSpeed);   
....................          #else 
....................             delay_ms(250); 
0902:  MOVLW  FA
0903:  MOVWF  54
0904:  BCF    0A.3
0905:  CALL   22B
0906:  BSF    0A.3
....................          #endif 
....................          CHARGING_STATE=SPEED_TO_LOW_ICE_DIRECT; 
0907:  MOVLW  01
0908:  MOVWF  52
....................       } 
....................       else if (checkRunnaway(& pidData)){// INSUFFICIENT_BRAKING_RUNNAWAY_ERROR){ 
0909:  GOTO   160
090A:  MOVLW  2F
090B:  MOVWF  53
090C:  BCF    0A.3
090D:  GOTO   23E
090E:  BSF    0A.3
090F:  MOVF   21,F
0910:  BTFSC  03.2
0911:  GOTO   11B
....................          #ifdef DEBUG 
....................             printf("State: RUNNAWAY \n");   
....................          #else 
....................             delay_ms(250); 
0912:  MOVLW  FA
0913:  MOVWF  54
0914:  BCF    0A.3
0915:  CALL   22B
0916:  BSF    0A.3
....................          #endif 
....................          ICE_ON=TRUE; 
0917:  BSF    43.1
....................          CHARGING_STATE=INSUFFICIENT_BRAKING_RUNAWAY; 
0918:  MOVLW  05
0919:  MOVWF  52
....................       } 
....................       else if ((Acaps > A_CAPS_MAX)&&(CHARGING_STATE==CHARGING_ALLOWED||CHARGING_STATE==CHARGING_AND_DISCHARING_ALLOWED)){ 
091A:  GOTO   160
091B:  MOVF   4F,W
091C:  SUBLW  01
091D:  BTFSC  03.0
091E:  GOTO   137
091F:  XORLW  FF
0920:  BTFSS  03.2
0921:  GOTO   126
0922:  MOVF   4E,W
0923:  SUBLW  D5
0924:  BTFSC  03.0
0925:  GOTO   137
0926:  MOVF   52,W
0927:  SUBLW  02
0928:  BTFSC  03.2
0929:  GOTO   12E
092A:  MOVF   52,W
092B:  SUBLW  04
092C:  BTFSS  03.2
092D:  GOTO   137
....................          //Stop Charging they are full 
....................           
....................          #ifdef DEBUG 
....................             printf("State: Caps Full \n");   
....................          #else 
....................             delay_ms(250); 
092E:  MOVLW  FA
092F:  MOVWF  54
0930:  BCF    0A.3
0931:  CALL   22B
0932:  BSF    0A.3
....................          #endif 
....................           
....................         ICE_ON=FALSE; 
0933:  BCF    43.1
....................         CHARGING_STATE=DISCHARGING_ALLOWED; 
0934:  MOVLW  03
0935:  MOVWF  52
....................       } 
....................       else if ((Acaps < A_CAPS_MIN)&& CHARGING_STATE!=CHARGING_ALLOWED){ 
0936:  GOTO   160
0937:  MOVF   4F,W
0938:  SUBLW  01
0939:  BTFSS  03.0
093A:  GOTO   14E
093B:  BTFSS  03.2
093C:  GOTO   141
093D:  MOVF   4E,W
093E:  SUBLW  4E
093F:  BTFSS  03.0
0940:  GOTO   14E
0941:  MOVF   52,W
0942:  SUBLW  02
0943:  BTFSC  03.2
0944:  GOTO   14E
....................          //Stop running electric, the caps are almost empty 
....................          
....................         #ifdef DEBUG 
....................             printf("State: Caps Empty \n");   
....................          #else 
....................             delay_ms(250); 
0945:  MOVLW  FA
0946:  MOVWF  54
0947:  BCF    0A.3
0948:  CALL   22B
0949:  BSF    0A.3
....................          #endif 
....................  
....................         ICE_ON=TRUE; 
094A:  BSF    43.1
....................         CHARGING_STATE=CHARGING_ALLOWED; 
094B:  MOVLW  02
094C:  MOVWF  52
....................       } 
....................      else if (A_CAPS_MID_LOW < Acaps < A_CAPS_MID_HIGH){ 
094D:  GOTO   160
094E:  MOVF   4F,W
094F:  SUBLW  00
0950:  BTFSC  03.0
0951:  GOTO   158
0952:  XORLW  FF
0953:  BTFSS  03.2
0954:  GOTO   159
0955:  MOVF   4E,W
0956:  SUBLW  B3
0957:  BTFSC  03.0
0958:  MOVLW  00
....................         #ifdef DEBUG 
....................             printf("State: Normal \n");   
....................          #else 
....................             delay_ms(250); 
0959:  MOVLW  FA
095A:  MOVWF  54
095B:  BCF    0A.3
095C:  CALL   22B
095D:  BSF    0A.3
....................          #endif 
....................          CHARGING_STATE=CHARGING_AND_DISCHARING_ALLOWED; 
095E:  MOVLW  04
095F:  MOVWF  52
....................      } 
....................       
....................       
.................... //PID CONTROLLER 
....................       //Servo to mirror Athrottle ->  
....................       //current_servo_position=right_position-(Athrottle-Athrottle_Min)*Athrottle_servo_factor;//(Athrottle/Athrottle_Full)*servo_difference;//(vSpeed/65536.0)*(2500); 
....................       ////printf("Analog Cap %d Analog Throttle %Lu\n",(int) Acaps,Athrottle); 
....................       //current_servo_position =right_position-vSpeed+200; 
....................       ////printf("Speed %lu \n",speeder); 
....................       //SET OUTPUTS  
....................       //The writing of the ICEThrottle happens in interupts and all that is 
....................       //required is updating ICEthrottle 
....................        
....................       returnedValue = pid_Controller((Athrottle-AThrottle_Min),vSpeed,& pidData); 
0960:  MOVLW  3C
0961:  SUBWF  4C,W
0962:  MOVWF  53
0963:  MOVF   4D,W
0964:  MOVWF  54
0965:  MOVLW  01
0966:  BTFSS  03.0
0967:  MOVLW  02
0968:  SUBWF  54,F
0969:  MOVF   54,W
096A:  MOVWF  56
096B:  MOVF   53,W
096C:  MOVWF  55
096D:  MOVF   47,W
096E:  MOVWF  58
096F:  MOVF   46,W
0970:  MOVWF  57
0971:  MOVLW  2F
0972:  MOVWF  59
0973:  BCF    0A.3
0974:  GOTO   242
0975:  BSF    0A.3
0976:  MOVF   22,W
0977:  MOVWF  51
0978:  MOVF   21,W
0979:  MOVWF  50
....................       ELECthrottle = ELECthrottle+returnedValue; 
097A:  MOVF   50,W
097B:  ADDWF  48,F
097C:  MOVF   51,W
097D:  BTFSC  03.0
097E:  INCFSZ 51,W
097F:  ADDWF  49,F
....................       //printf("Throttle %ld and electhrottle %ld \n",Athrottle,ELECthrottle); 
....................        
....................       
....................       if (ELECthrottle>2500){ 
0980:  BTFSC  49.7
0981:  GOTO   192
0982:  MOVF   49,W
0983:  SUBLW  08
0984:  BTFSC  03.0
0985:  GOTO   192
0986:  XORLW  FF
0987:  BTFSS  03.2
0988:  GOTO   18D
0989:  MOVF   48,W
098A:  SUBLW  C4
098B:  BTFSC  03.0
098C:  GOTO   192
....................          ELECthrottle=2500; 
098D:  MOVLW  09
098E:  MOVWF  49
098F:  MOVLW  C4
0990:  MOVWF  48
....................       } 
....................       else if (ELECthrottle<-1500){ 
0991:  GOTO   1A2
0992:  BTFSS  49.7
0993:  GOTO   1A2
0994:  MOVF   49,W
0995:  SUBLW  FA
0996:  BTFSS  03.0
0997:  GOTO   1A2
0998:  BTFSS  03.2
0999:  GOTO   19E
099A:  MOVF   48,W
099B:  SUBLW  23
099C:  BTFSS  03.0
099D:  GOTO   1A2
....................          ELECthrottle = -1500; 
099E:  MOVLW  FA
099F:  MOVWF  49
09A0:  MOVLW  24
09A1:  MOVWF  48
....................       } 
....................        
....................        
....................       //SET OUTPUTS 
....................       if (CHARGING_STATE==EVERYTHING_OFF||CHARGING_STATE==USER_INPUT_OFF){ 
09A2:  MOVF   52,F
09A3:  BTFSC  03.2
09A4:  GOTO   1A9
09A5:  MOVF   52,W
09A6:  SUBLW  06
09A7:  BTFSS  03.2
09A8:  GOTO   1B6
....................          ICEthrottle = 0; 
09A9:  CLRF   4B
09AA:  CLRF   4A
....................          ICE_ON = FALSE; 
09AB:  BCF    43.1
....................          current_servo_position =right_position; 
09AC:  MOVLW  17
09AD:  MOVWF  42
09AE:  MOVLW  D4
09AF:  MOVWF  41
....................          write_dac(0); 
09B0:  CLRF   58
09B1:  CLRF   57
09B2:  BCF    0A.3
09B3:  CALL   0E0
09B4:  BSF    0A.3
....................       } 
....................       else if (CHARGING_STATE==SPEED_TO_LOW_ICE_DIRECT || CHARGING_STATE==INSUFFICIENT_BRAKING_RUNAWAY){ 
09B5:  GOTO   262
09B6:  DECFSZ 52,W
09B7:  GOTO   1B9
09B8:  GOTO   1BD
09B9:  MOVF   52,W
09BA:  SUBLW  05
09BB:  BTFSS  03.2
09BC:  GOTO   1DF
....................          if (ELECthrottle>0){ 
09BD:  BTFSC  49.7
09BE:  GOTO   1D4
09BF:  MOVF   49,F
09C0:  BTFSS  03.2
09C1:  GOTO   1C6
09C2:  MOVF   48,W
09C3:  SUBLW  00
09C4:  BTFSC  03.0
09C5:  GOTO   1D4
....................             current_servo_position =right_position- (ELECthrottle); 
09C6:  MOVF   48,W
09C7:  SUBLW  D4
09C8:  MOVWF  20
09C9:  MOVLW  17
09CA:  MOVWF  23
09CB:  MOVF   49,W
09CC:  BTFSS  03.0
09CD:  INCFSZ 49,W
09CE:  SUBWF  23,F
09CF:  MOVF   20,W
09D0:  MOVWF  41
09D1:  MOVF   23,W
09D2:  MOVWF  42
....................          } 
....................          else{ 
09D3:  GOTO   1D8
....................             current_servo_position =right_position; 
09D4:  MOVLW  17
09D5:  MOVWF  42
09D6:  MOVLW  D4
09D7:  MOVWF  41
....................          } 
....................          ICE_ON = TRUE; 
09D8:  BSF    43.1
....................          write_dac(0); 
09D9:  CLRF   58
09DA:  CLRF   57
09DB:  BCF    0A.3
09DC:  CALL   0E0
09DD:  BSF    0A.3
....................       } 
....................       else{ 
09DE:  GOTO   262
....................       if (ELECthrottle<0){ 
09DF:  BTFSS  49.7
09E0:  GOTO   21F
....................         if (CHARGING_STATE==CHARGING_ALLOWED || CHARGING_STATE ==CHARGING_AND_DISCHARING_ALLOWED){ 
09E1:  MOVF   52,W
09E2:  SUBLW  02
09E3:  BTFSC  03.2
09E4:  GOTO   1E9
09E5:  MOVF   52,W
09E6:  SUBLW  04
09E7:  BTFSS  03.2
09E8:  GOTO   219
....................              if (CURRENTLY_CHARGING==1){ 
09E9:  BTFSS  43.2
09EA:  GOTO   1EE
....................                 trickBreaking(); 
09EB:  BCF    0A.3
09EC:  GOTO   61E
09ED:  BSF    0A.3
....................              } 
....................              //ELECthrottle = 300; 
....................              CURRENTLY_CHARGING=0; 
09EE:  BCF    43.2
....................              output_high(brake_pin); 
09EF:  BSF    03.5
09F0:  BCF    06.4
09F1:  BCF    03.5
09F2:  BSF    06.4
....................              output_high(Electric_Controller_Switch); 
09F3:  BSF    03.5
09F4:  BCF    06.0
09F5:  BCF    03.5
09F6:  BSF    06.0
....................              //printf("BREAKING \n"); 
....................              write_dac((abs(ELECthrottle)+ELEC_CONTROLLER_OFFSET)); 
09F7:  MOVF   49,W
09F8:  MOVWF  23
09F9:  MOVF   48,W
09FA:  BTFSS  49.7
09FB:  GOTO   205
09FC:  MOVF   48,W
09FD:  SUBLW  00
09FE:  MOVWF  20
09FF:  CLRF   23
0A00:  MOVF   49,W
0A01:  BTFSS  03.0
0A02:  INCFSZ 49,W
0A03:  SUBWF  23,F
0A04:  MOVF   20,W
0A05:  MOVWF  53
0A06:  MOVF   23,W
0A07:  MOVWF  54
0A08:  MOVLW  84
0A09:  ADDWF  53,W
0A0A:  MOVWF  55
0A0B:  MOVF   54,W
0A0C:  MOVWF  56
0A0D:  MOVLW  03
0A0E:  BTFSC  03.0
0A0F:  MOVLW  04
0A10:  ADDWF  56,F
0A11:  MOVF   56,W
0A12:  MOVWF  58
0A13:  MOVF   55,W
0A14:  MOVWF  57
0A15:  BCF    0A.3
0A16:  CALL   0E0
0A17:  BSF    0A.3
....................         } 
....................         else{ 
0A18:  GOTO   21E
....................            //Decrease ICE throttle 
....................            write_dac(0); 
0A19:  CLRF   58
0A1A:  CLRF   57
0A1B:  BCF    0A.3
0A1C:  CALL   0E0
0A1D:  BSF    0A.3
....................        
....................         } 
....................       } 
....................       else { 
0A1E:  GOTO   257
....................         if (CHARGING_STATE==DISCHARGING_ALLOWED || CHARGING_STATE ==CHARGING_AND_DISCHARING_ALLOWED){ 
0A1F:  MOVF   52,W
0A20:  SUBLW  03
0A21:  BTFSC  03.2
0A22:  GOTO   227
0A23:  MOVF   52,W
0A24:  SUBLW  04
0A25:  BTFSS  03.2
0A26:  GOTO   252
....................              CURRENTLY_CHARGING=1; 
0A27:  BSF    43.2
....................              output_low(brake_pin); 
0A28:  BSF    03.5
0A29:  BCF    06.4
0A2A:  BCF    03.5
0A2B:  BCF    06.4
....................              output_low(Electric_Controller_Switch); 
0A2C:  BSF    03.5
0A2D:  BCF    06.0
0A2E:  BCF    03.5
0A2F:  BCF    06.0
....................              //printf("ACCELERATING \n"); 
....................              write_dac((abs(ELECthrottle)+ELEC_CONTROLLER_OFFSET)); 
0A30:  MOVF   49,W
0A31:  MOVWF  23
0A32:  MOVF   48,W
0A33:  BTFSS  49.7
0A34:  GOTO   23E
0A35:  MOVF   48,W
0A36:  SUBLW  00
0A37:  MOVWF  20
0A38:  CLRF   23
0A39:  MOVF   49,W
0A3A:  BTFSS  03.0
0A3B:  INCFSZ 49,W
0A3C:  SUBWF  23,F
0A3D:  MOVF   20,W
0A3E:  MOVWF  53
0A3F:  MOVF   23,W
0A40:  MOVWF  54
0A41:  MOVLW  84
0A42:  ADDWF  53,W
0A43:  MOVWF  55
0A44:  MOVF   54,W
0A45:  MOVWF  56
0A46:  MOVLW  03
0A47:  BTFSC  03.0
0A48:  MOVLW  04
0A49:  ADDWF  56,F
0A4A:  MOVF   56,W
0A4B:  MOVWF  58
0A4C:  MOVF   55,W
0A4D:  MOVWF  57
0A4E:  BCF    0A.3
0A4F:  CALL   0E0
0A50:  BSF    0A.3
....................         } 
....................         else{ 
0A51:  GOTO   257
....................            //Increase ICE throttle 
....................            write_dac(0); 
0A52:  CLRF   58
0A53:  CLRF   57
0A54:  BCF    0A.3
0A55:  CALL   0E0
0A56:  BSF    0A.3
....................        
....................         } 
....................           
....................       } 
....................       if (ICE_ON){ 
0A57:  BTFSS  43.1
0A58:  GOTO   25E
....................          //printf("ICE NORMAL \n"); 
....................          current_servo_position =right_position-1000; 
0A59:  MOVLW  13
0A5A:  MOVWF  42
0A5B:  MOVLW  EC
0A5C:  MOVWF  41
....................       } 
....................       else{ 
0A5D:  GOTO   262
....................          current_servo_position =right_position; 
0A5E:  MOVLW  17
0A5F:  MOVWF  42
0A60:  MOVLW  D4
0A61:  MOVWF  41
....................          //printf("ICE OFF \n"); 
....................       } 
....................       } 
....................             
....................    } 
0A62:  GOTO   09B
....................     
....................  
.................... } 
....................  
.................... #endif 
....................  
.................... boolean checkRunnaway(struct PID_DATA *pid) 
.................... { 
0A63:  SLEEP
.................... //return (pid->sumError > INSUFFICIENT_BRAKING_RUNNAWAY_ERROR); 
.................... return FALSE; 
*
023E:  MOVLW  00
023F:  MOVWF  21
.................... } 
0240:  BSF    0A.3
0241:  GOTO   10E (RETURN)
....................  
.................... /*! \brief Initialisation of PID controller parameters. 
....................  * 
....................  *  Initialise the variables used by the PID algorithm. 
....................  * 
....................  *  \param p_factor  Proportional term. 
....................  *  \param i_factor  Integral term. 
....................  *  \param d_factor  Derivate term. 
....................  *  \param pid  Struct with PID status. 
....................  */ 
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid) 
.................... // Set up PID controller parameters 
.................... { 
....................   // Start values for PID controller 
....................   pid->sumError = 0; 
*
013C:  MOVLW  02
013D:  ADDWF  59,W
013E:  MOVWF  04
013F:  INCF   04,F
0140:  INCF   04,F
0141:  INCF   04,F
0142:  CLRF   00
0143:  DECF   04,F
0144:  CLRF   00
0145:  DECF   04,F
0146:  CLRF   00
0147:  DECF   04,F
0148:  CLRF   00
....................   pid->lastProcessValue = 0; 
0149:  MOVF   59,W
014A:  MOVWF  04
014B:  INCF   04,F
014C:  CLRF   00
014D:  DECF   04,F
014E:  CLRF   00
....................   // Tuning constants for PID loop 
....................   pid->P_Factor = p_factor; 
014F:  MOVLW  06
0150:  ADDWF  59,W
0151:  MOVWF  04
0152:  INCF   04,F
0153:  MOVF   54,W
0154:  MOVWF  00
0155:  DECF   04,F
0156:  MOVF   53,W
0157:  MOVWF  00
....................   pid->I_Factor = i_factor; 
0158:  MOVLW  08
0159:  ADDWF  59,W
015A:  MOVWF  04
015B:  INCF   04,F
015C:  MOVF   56,W
015D:  MOVWF  00
015E:  DECF   04,F
015F:  MOVF   55,W
0160:  MOVWF  00
....................   pid->D_Factor = d_factor; 
0161:  MOVLW  0A
0162:  ADDWF  59,W
0163:  MOVWF  04
0164:  INCF   04,F
0165:  MOVF   58,W
0166:  MOVWF  00
0167:  DECF   04,F
0168:  MOVF   57,W
0169:  MOVWF  00
....................   // Limits to avoid overflow 
....................   pid->maxError = MAX_INT / (pid->P_Factor + 1); 
016A:  MOVLW  0C
016B:  ADDWF  59,W
016C:  MOVWF  5A
016D:  MOVLW  06
016E:  ADDWF  59,W
016F:  MOVWF  04
0170:  INCF   04,F
0171:  MOVF   00,W
0172:  MOVWF  5C
0173:  DECF   04,F
0174:  MOVF   00,W
0175:  MOVWF  5B
0176:  MOVLW  01
0177:  ADDWF  5B,W
0178:  MOVWF  21
0179:  MOVF   5C,W
017A:  MOVWF  23
017B:  BTFSC  03.0
017C:  INCF   23,F
017D:  MOVF   21,W
017E:  MOVWF  5D
017F:  MOVF   23,W
0180:  MOVWF  5E
0181:  MOVLW  7F
0182:  MOVWF  60
0183:  MOVLW  FF
0184:  MOVWF  5F
0185:  MOVF   5E,W
0186:  MOVWF  62
0187:  MOVF   5D,W
0188:  MOVWF  61
*
01AD:  MOVF   5A,W
01AE:  MOVWF  04
01AF:  INCF   04,F
01B0:  MOVF   22,W
01B1:  MOVWF  00
01B2:  DECF   04,F
01B3:  MOVF   21,W
01B4:  MOVWF  00
....................   ////printf("Max %ld factor %ld and pid %ld",MAX_INT,pid->I_Factor,pid->maxError); 
....................   pid->maxSumError = MAX_I_TERM / (pid->I_Factor + 1); 
01B5:  MOVLW  0E
01B6:  ADDWF  59,W
01B7:  MOVWF  5A
01B8:  MOVLW  08
01B9:  ADDWF  59,W
01BA:  MOVWF  04
01BB:  INCF   04,F
01BC:  MOVF   00,W
01BD:  MOVWF  5C
01BE:  DECF   04,F
01BF:  MOVF   00,W
01C0:  MOVWF  5B
01C1:  MOVLW  01
01C2:  ADDWF  5B,W
01C3:  MOVWF  21
01C4:  MOVF   5C,W
01C5:  MOVWF  23
01C6:  BTFSC  03.0
01C7:  INCF   23,F
01C8:  MOVF   21,W
01C9:  MOVWF  5D
01CA:  MOVF   23,W
01CB:  MOVWF  5E
01CC:  MOVF   04,W
01CD:  MOVWF  5F
01CE:  MOVLW  3F
01CF:  MOVWF  63
01D0:  MOVLW  FF
01D1:  MOVWF  62
01D2:  MOVWF  61
01D3:  MOVWF  60
01D4:  CLRF   67
01D5:  CLRF   66
01D6:  MOVF   5E,W
01D7:  MOVWF  65
01D8:  MOVF   5D,W
01D9:  MOVWF  64
*
021A:  MOVF   5F,W
021B:  MOVWF  04
021C:  MOVF   5A,W
021D:  MOVWF  04
021E:  MOVF   20,W
021F:  MOVWF  00
0220:  INCF   04,F
0221:  MOVF   21,W
0222:  MOVWF  00
0223:  INCF   04,F
0224:  MOVF   22,W
0225:  MOVWF  00
0226:  INCF   04,F
0227:  MOVF   23,W
0228:  MOVWF  00
.................... } 
0229:  BSF    0A.3
022A:  GOTO   080 (RETURN)
....................  
....................  
.................... /*! \brief PID control algorithm. 
....................  * 
....................  *  Calculates output from setpoint, process value and PID status. 
....................  * 
....................  *  \param setPoint  Desired value. 
....................  *  \param processValue  Measured value. 
....................  *  \param pid_st  PID status struct. 
....................  */ 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st) 
.................... { 
....................   signed int16 error, p_term, d_term; 
....................   signed int32 i_term, ret, temp; 
....................     processValue=processValue/4; 
*
0242:  RRF    58,F
0243:  RRF    57,F
0244:  RRF    58,F
0245:  RRF    57,F
0246:  MOVLW  3F
0247:  ANDWF  58,F
....................   ////printf("input %ld speed %ld ",setPoint,processValue); 
....................   error = setPoint - processValue; 
0248:  MOVF   57,W
0249:  SUBWF  55,W
024A:  MOVWF  20
024B:  MOVF   56,W
024C:  MOVWF  23
024D:  MOVF   58,W
024E:  BTFSS  03.0
024F:  INCFSZ 58,W
0250:  SUBWF  23,F
0251:  MOVF   20,W
0252:  MOVWF  5A
0253:  MOVF   23,W
0254:  MOVWF  5B
....................    
....................   // Calculate Pterm and limit error overflow 
....................    
....................   if (error > (signed int16) pid_st->maxError){ 
0255:  MOVLW  0C
0256:  ADDWF  59,W
0257:  MOVWF  04
0258:  INCF   04,F
0259:  MOVF   00,W
025A:  MOVWF  23
025B:  DECF   04,F
025C:  MOVF   00,W
025D:  MOVWF  21
025E:  BTFSS  23.7
025F:  GOTO   263
0260:  BTFSS  5B.7
0261:  GOTO   26F
0262:  GOTO   265
0263:  BTFSC  5B.7
0264:  GOTO   274
0265:  MOVF   23,W
0266:  SUBWF  5B,W
0267:  BTFSS  03.0
0268:  GOTO   274
0269:  BTFSS  03.2
026A:  GOTO   26F
026B:  MOVF   5A,W
026C:  SUBWF  21,W
026D:  BTFSC  03.0
026E:  GOTO   274
....................     p_term = MAX_INT; 
026F:  MOVLW  7F
0270:  MOVWF  5D
0271:  MOVLW  FF
0272:  MOVWF  5C
....................     ////printf("p greater error %ld a %ld p %ld",error,pid_st->maxError,p_term); 
....................  
....................   } 
....................   else if (error < (signed int16) -pid_st->maxError){ 
0273:  GOTO   3A5
0274:  MOVLW  0C
0275:  ADDWF  59,W
0276:  MOVWF  04
0277:  INCF   04,F
0278:  MOVF   00,W
0279:  MOVWF  23
027A:  DECF   04,F
027B:  MOVF   00,W
027C:  SUBLW  00
027D:  MOVWF  20
027E:  MOVF   23,W
027F:  BTFSS  03.0
0280:  INCFSZ 23,W
0281:  GOTO   284
0282:  MOVLW  00
0283:  GOTO   285
0284:  SUBLW  00
0285:  MOVWF  23
0286:  MOVF   20,W
0287:  MOVWF  21
0288:  BTFSS  5B.7
0289:  GOTO   28D
028A:  BTFSS  23.7
028B:  GOTO   299
028C:  GOTO   28F
028D:  BTFSC  23.7
028E:  GOTO   29E
028F:  MOVF   5B,W
0290:  SUBWF  23,W
0291:  BTFSS  03.0
0292:  GOTO   29E
0293:  BTFSS  03.2
0294:  GOTO   299
0295:  MOVF   21,W
0296:  SUBWF  5A,W
0297:  BTFSC  03.0
0298:  GOTO   29E
....................     p_term = -MAX_INT; 
0299:  MOVLW  80
029A:  MOVWF  5D
029B:  MOVLW  01
029C:  MOVWF  5C
....................     ////printf("p less error %ld a %ld p %ld",error,-pid_st->maxError,p_term); 
....................  
....................   } 
....................   else{ 
029D:  GOTO   3A5
....................     p_term = (signed int16) (pid_st->P_Factor * (float) error); 
029E:  MOVLW  06
029F:  ADDWF  59,W
02A0:  MOVWF  04
02A1:  INCF   04,F
02A2:  MOVF   00,W
02A3:  MOVWF  6D
02A4:  DECF   04,F
02A5:  MOVF   00,W
02A6:  MOVWF  6C
02A7:  MOVF   5B,W
02A8:  MOVWF  6F
02A9:  MOVF   5A,W
02AA:  MOVWF  6E
*
02CF:  MOVF   20,W
02D0:  MOVWF  6E
02D1:  MOVF   21,W
02D2:  MOVWF  6F
02D3:  MOVF   22,W
02D4:  MOVWF  70
02D5:  MOVF   23,W
02D6:  MOVWF  71
02D7:  MOVF   6D,W
02D8:  MOVWF  73
02D9:  MOVF   6C,W
02DA:  MOVWF  72
*
02F7:  MOVF   23,W
02F8:  MOVWF  75
02F9:  MOVF   22,W
02FA:  MOVWF  74
02FB:  MOVF   21,W
02FC:  MOVWF  73
02FD:  MOVF   20,W
02FE:  MOVWF  72
02FF:  MOVF   71,W
0300:  MOVWF  79
0301:  MOVF   70,W
0302:  MOVWF  78
0303:  MOVF   6F,W
0304:  MOVWF  77
0305:  MOVF   6E,W
0306:  MOVWF  76
*
037B:  MOVF   23,W
037C:  MOVWF  75
037D:  MOVF   22,W
037E:  MOVWF  74
037F:  MOVF   21,W
0380:  MOVWF  73
0381:  MOVF   20,W
0382:  MOVWF  72
*
03A1:  MOVF   22,W
03A2:  MOVWF  5D
03A3:  MOVF   21,W
03A4:  MOVWF  5C
....................     ////printf("error %ld a %ld p %ld",error,pid_st->maxError,p_term); 
....................   } 
....................    
....................   // Calculate Iterm and limit integral runaway 
....................   temp = pid_st->sumError + error; 
03A5:  MOVLW  02
03A6:  ADDWF  59,W
03A7:  MOVWF  04
03A8:  MOVF   00,W
03A9:  MOVWF  6C
03AA:  INCF   04,F
03AB:  MOVF   00,W
03AC:  MOVWF  6D
03AD:  INCF   04,F
03AE:  MOVF   00,W
03AF:  MOVWF  6E
03B0:  INCF   04,F
03B1:  MOVF   00,W
03B2:  MOVWF  6F
03B3:  MOVF   5A,W
03B4:  MOVWF  20
03B5:  MOVF   5B,W
03B6:  MOVWF  21
03B7:  CLRF   22
03B8:  CLRF   23
03B9:  BTFSS  5B.7
03BA:  GOTO   3BD
03BB:  DECF   22,F
03BC:  DECF   23,F
03BD:  MOVF   20,W
03BE:  ADDWF  6C,W
03BF:  MOVWF  68
03C0:  MOVF   6D,W
03C1:  MOVWF  69
03C2:  MOVF   21,W
03C3:  BTFSC  03.0
03C4:  INCFSZ 21,W
03C5:  ADDWF  69,F
03C6:  MOVF   6E,W
03C7:  MOVWF  6A
03C8:  MOVF   22,W
03C9:  BTFSC  03.0
03CA:  INCFSZ 22,W
03CB:  ADDWF  6A,F
03CC:  MOVF   6F,W
03CD:  MOVWF  6B
03CE:  MOVF   23,W
03CF:  BTFSC  03.0
03D0:  INCFSZ 23,W
03D1:  ADDWF  6B,F
....................   if(temp > (signed int32)pid_st->maxSumError){ 
03D2:  MOVLW  0E
03D3:  ADDWF  59,W
03D4:  MOVWF  04
03D5:  MOVF   00,W
03D6:  MOVWF  20
03D7:  INCF   04,F
03D8:  MOVF   00,W
03D9:  MOVWF  21
03DA:  INCF   04,F
03DB:  MOVF   00,W
03DC:  MOVWF  22
03DD:  INCF   04,F
03DE:  MOVF   00,W
03DF:  MOVWF  23
03E0:  BTFSS  23.7
03E1:  GOTO   3E5
03E2:  BTFSS  6B.7
03E3:  GOTO   3FD
03E4:  GOTO   3E7
03E5:  BTFSC  6B.7
03E6:  GOTO   422
03E7:  MOVF   23,W
03E8:  SUBWF  6B,W
03E9:  BTFSS  03.0
03EA:  GOTO   422
03EB:  BTFSS  03.2
03EC:  GOTO   3FD
03ED:  MOVF   22,W
03EE:  SUBWF  6A,W
03EF:  BTFSS  03.0
03F0:  GOTO   422
03F1:  BTFSS  03.2
03F2:  GOTO   3FD
03F3:  MOVF   21,W
03F4:  SUBWF  69,W
03F5:  BTFSS  03.0
03F6:  GOTO   422
03F7:  BTFSS  03.2
03F8:  GOTO   3FD
03F9:  MOVF   68,W
03FA:  SUBWF  20,W
03FB:  BTFSC  03.0
03FC:  GOTO   422
....................     i_term = MAX_I_TERM; 
03FD:  MOVLW  3F
03FE:  MOVWF  63
03FF:  MOVLW  FF
0400:  MOVWF  62
0401:  MOVWF  61
0402:  MOVWF  60
....................     pid_st->sumError = pid_st->maxSumError; 
0403:  MOVLW  02
0404:  ADDWF  59,W
0405:  MOVWF  6C
0406:  MOVLW  0E
0407:  ADDWF  59,W
0408:  MOVWF  04
0409:  MOVF   00,W
040A:  MOVWF  20
040B:  INCF   04,F
040C:  MOVF   00,W
040D:  MOVWF  21
040E:  INCF   04,F
040F:  MOVF   00,W
0410:  MOVWF  22
0411:  INCF   04,F
0412:  MOVF   00,W
0413:  MOVWF  23
0414:  MOVF   6C,W
0415:  MOVWF  04
0416:  MOVF   20,W
0417:  MOVWF  00
0418:  INCF   04,F
0419:  MOVF   21,W
041A:  MOVWF  00
041B:  INCF   04,F
041C:  MOVF   22,W
041D:  MOVWF  00
041E:  INCF   04,F
041F:  MOVF   23,W
0420:  MOVWF  00
....................     ////printf("\n greater temp %ld a %ld sum %ld",temp,pid_st->maxSumError,pid_st->sumError); 
....................  
....................  } 
....................   else if(temp < (signed int32)-pid_st->maxSumError){ 
0421:  GOTO   536
0422:  MOVLW  0E
0423:  ADDWF  59,W
0424:  MOVWF  04
0425:  MOVF   00,W
0426:  MOVWF  20
0427:  INCF   04,F
0428:  MOVF   00,W
0429:  MOVWF  21
042A:  INCF   04,F
042B:  MOVF   00,W
042C:  MOVWF  22
042D:  INCF   04,F
042E:  MOVF   00,W
042F:  MOVWF  23
0430:  MOVLW  FD
0431:  ADDWF  04,F
0432:  MOVF   20,W
0433:  SUBLW  00
0434:  MOVWF  20
0435:  MOVF   21,W
0436:  BTFSS  03.0
0437:  INCFSZ 21,W
0438:  GOTO   43B
0439:  MOVLW  00
043A:  GOTO   43C
043B:  SUBLW  00
043C:  MOVWF  21
043D:  MOVF   22,W
043E:  BTFSS  03.0
043F:  INCFSZ 22,W
0440:  GOTO   443
0441:  MOVLW  00
0442:  GOTO   444
0443:  SUBLW  00
0444:  MOVWF  22
0445:  MOVF   23,W
0446:  BTFSS  03.0
0447:  INCFSZ 23,W
0448:  GOTO   44B
0449:  MOVLW  00
044A:  GOTO   44C
044B:  SUBLW  00
044C:  MOVWF  23
044D:  BTFSS  6B.7
044E:  GOTO   452
044F:  BTFSS  23.7
0450:  GOTO   46A
0451:  GOTO   454
0452:  BTFSC  23.7
0453:  GOTO   4AD
0454:  MOVF   6B,W
0455:  SUBWF  23,W
0456:  BTFSS  03.0
0457:  GOTO   4AD
0458:  BTFSS  03.2
0459:  GOTO   46A
045A:  MOVF   6A,W
045B:  SUBWF  22,W
045C:  BTFSS  03.0
045D:  GOTO   4AD
045E:  BTFSS  03.2
045F:  GOTO   46A
0460:  MOVF   69,W
0461:  SUBWF  21,W
0462:  BTFSS  03.0
0463:  GOTO   4AD
0464:  BTFSS  03.2
0465:  GOTO   46A
0466:  MOVF   20,W
0467:  SUBWF  68,W
0468:  BTFSC  03.0
0469:  GOTO   4AD
....................     i_term = -MAX_I_TERM; 
046A:  MOVLW  C0
046B:  MOVWF  63
046C:  CLRF   62
046D:  CLRF   61
046E:  MOVLW  01
046F:  MOVWF  60
....................     pid_st->sumError = -pid_st->maxSumError; 
0470:  MOVLW  02
0471:  ADDWF  59,W
0472:  MOVWF  6C
0473:  MOVLW  0E
0474:  ADDWF  59,W
0475:  MOVWF  04
0476:  MOVF   00,W
0477:  MOVWF  20
0478:  INCF   04,F
0479:  MOVF   00,W
047A:  MOVWF  21
047B:  INCF   04,F
047C:  MOVF   00,W
047D:  MOVWF  22
047E:  INCF   04,F
047F:  MOVF   00,W
0480:  MOVWF  23
0481:  MOVLW  FD
0482:  ADDWF  04,F
0483:  MOVF   20,W
0484:  SUBLW  00
0485:  MOVWF  20
0486:  MOVF   21,W
0487:  BTFSS  03.0
0488:  INCFSZ 21,W
0489:  GOTO   48C
048A:  MOVLW  00
048B:  GOTO   48D
048C:  SUBLW  00
048D:  MOVWF  21
048E:  MOVF   22,W
048F:  BTFSS  03.0
0490:  INCFSZ 22,W
0491:  GOTO   494
0492:  MOVLW  00
0493:  GOTO   495
0494:  SUBLW  00
0495:  MOVWF  22
0496:  MOVF   23,W
0497:  BTFSS  03.0
0498:  INCFSZ 23,W
0499:  GOTO   49C
049A:  MOVLW  00
049B:  GOTO   49D
049C:  SUBLW  00
049D:  MOVWF  23
049E:  MOVWF  70
049F:  MOVF   6C,W
04A0:  MOVWF  04
04A1:  MOVF   20,W
04A2:  MOVWF  00
04A3:  INCF   04,F
04A4:  MOVF   21,W
04A5:  MOVWF  00
04A6:  INCF   04,F
04A7:  MOVF   22,W
04A8:  MOVWF  00
04A9:  INCF   04,F
04AA:  MOVF   70,W
04AB:  MOVWF  00
....................     ////printf("\n less temp %ld a %ld sum %ld",temp,pid_st->maxSumError,pid_st->sumError); 
....................  
....................   } 
....................   else{ 
04AC:  GOTO   536
....................     pid_st->sumError = temp; 
04AD:  MOVLW  02
04AE:  ADDWF  59,W
04AF:  MOVWF  04
04B0:  MOVF   68,W
04B1:  MOVWF  00
04B2:  INCF   04,F
04B3:  MOVF   69,W
04B4:  MOVWF  00
04B5:  INCF   04,F
04B6:  MOVF   6A,W
04B7:  MOVWF  00
04B8:  INCF   04,F
04B9:  MOVF   6B,W
04BA:  MOVWF  00
....................     i_term = pid_st->I_Factor * pid_st->sumError; 
04BB:  MOVLW  08
04BC:  ADDWF  59,W
04BD:  MOVWF  04
04BE:  INCF   04,F
04BF:  MOVF   00,W
04C0:  MOVWF  6D
04C1:  DECF   04,F
04C2:  MOVF   00,W
04C3:  MOVWF  6C
04C4:  MOVLW  02
04C5:  ADDWF  59,W
04C6:  MOVWF  04
04C7:  MOVF   00,W
04C8:  MOVWF  20
04C9:  INCF   04,F
04CA:  MOVF   00,W
04CB:  MOVWF  21
04CC:  INCF   04,F
04CD:  MOVF   00,W
04CE:  MOVWF  22
04CF:  INCF   04,F
04D0:  MOVF   00,W
04D1:  MOVWF  23
04D2:  MOVLW  FD
04D3:  ADDWF  04,F
04D4:  MOVF   23,W
04D5:  MOVWF  71
04D6:  MOVF   22,W
04D7:  MOVWF  70
04D8:  MOVF   21,W
04D9:  MOVWF  6F
04DA:  MOVF   20,W
04DB:  MOVWF  6E
04DC:  MOVF   04,W
04DD:  MOVWF  72
04DE:  CLRF   76
04DF:  CLRF   75
04E0:  MOVF   6D,W
04E1:  MOVWF  74
04E2:  MOVF   6C,W
04E3:  MOVWF  73
04E4:  MOVF   71,W
04E5:  MOVWF  7A
04E6:  MOVF   70,W
04E7:  MOVWF  79
04E8:  MOVF   6F,W
04E9:  MOVWF  78
04EA:  MOVF   6E,W
04EB:  MOVWF  77
*
052B:  BCF    03.5
052C:  MOVF   72,W
052D:  MOVWF  04
052E:  MOVF   23,W
052F:  MOVWF  63
0530:  MOVF   22,W
0531:  MOVWF  62
0532:  MOVF   21,W
0533:  MOVWF  61
0534:  MOVF   20,W
0535:  MOVWF  60
....................     ////printf("\n eror temp %ld i_term %ld sum %ld error %ld ",temp,i_term,pid_st->sumError,error); 
....................  
....................   } 
....................  
....................   // Calculate Dterm 
....................   d_term = pid_st->D_Factor * (pid_st->lastProcessValue - processValue); 
0536:  MOVLW  0A
0537:  ADDWF  59,W
0538:  MOVWF  04
0539:  INCF   04,F
053A:  MOVF   00,W
053B:  MOVWF  6D
053C:  DECF   04,F
053D:  MOVF   00,W
053E:  MOVWF  6C
053F:  MOVF   59,W
0540:  MOVWF  04
0541:  INCF   04,F
0542:  MOVF   00,W
0543:  MOVWF  6F
0544:  DECF   04,F
0545:  MOVF   00,W
0546:  MOVWF  6E
0547:  MOVF   57,W
0548:  SUBWF  6E,W
0549:  MOVWF  20
054A:  MOVF   6F,W
054B:  MOVWF  23
054C:  MOVF   58,W
054D:  BTFSS  03.0
054E:  INCFSZ 58,W
054F:  SUBWF  23,F
0550:  MOVF   20,W
0551:  MOVWF  70
0552:  MOVF   23,W
0553:  MOVWF  71
0554:  MOVF   6D,W
0555:  MOVWF  73
0556:  MOVF   6C,W
0557:  MOVWF  72
0558:  MOVF   71,W
0559:  MOVWF  75
055A:  MOVF   70,W
055B:  MOVWF  74
*
0570:  MOVF   21,W
0571:  MOVWF  5E
0572:  MOVF   22,W
0573:  MOVWF  5F
.................... ////printf("\n p_term %ld d_term %ld i_term %ld",p_term,d_term,i_term); 
....................   pid_st->lastProcessValue = processValue; 
0574:  MOVF   59,W
0575:  MOVWF  04
0576:  INCF   04,F
0577:  MOVF   58,W
0578:  MOVWF  00
0579:  DECF   04,F
057A:  MOVF   57,W
057B:  MOVWF  00
....................  
....................   //ret = (p_term + i_term + d_term) / SCALING_FACTOR; 
....................    ret = (p_term+d_term+(signed int16)i_term) / SCALING_FACTOR; 
057C:  MOVF   5E,W
057D:  ADDWF  5C,W
057E:  MOVWF  6C
057F:  MOVF   5D,W
0580:  MOVWF  6D
0581:  MOVF   5F,W
0582:  BTFSC  03.0
0583:  INCFSZ 5F,W
0584:  ADDWF  6D,F
0585:  MOVF   60,W
0586:  ADDWF  6C,W
0587:  MOVWF  6E
0588:  MOVF   6D,W
0589:  MOVWF  6F
058A:  MOVF   61,W
058B:  BTFSC  03.0
058C:  INCFSZ 61,W
058D:  ADDWF  6F,F
058E:  MOVF   6F,W
058F:  MOVWF  71
0590:  MOVF   6E,W
0591:  MOVWF  70
0592:  CLRF   73
0593:  MOVLW  80
0594:  MOVWF  72
*
05D2:  MOVF   22,W
05D3:  MOVWF  23
05D4:  MOVF   21,W
05D5:  MOVWF  20
05D6:  MOVF   22,W
05D7:  MOVWF  21
05D8:  CLRF   22
05D9:  CLRF   23
05DA:  BTFSS  21.7
05DB:  GOTO   5DE
05DC:  DECF   22,F
05DD:  DECF   23,F
05DE:  MOVF   23,W
05DF:  MOVWF  67
05E0:  MOVF   22,W
05E1:  MOVWF  66
05E2:  MOVF   21,W
05E3:  MOVWF  65
05E4:  MOVF   20,W
05E5:  MOVWF  64
....................   if(ret > MAX_INT){ 
05E6:  BTFSC  67.7
05E7:  GOTO   5F9
05E8:  MOVF   67,F
05E9:  BTFSS  03.2
05EA:  GOTO   5F2
05EB:  MOVF   66,F
05EC:  BTFSS  03.2
05ED:  GOTO   5F2
05EE:  MOVF   65,W
05EF:  SUBLW  7F
05F0:  BTFSC  03.0
05F1:  GOTO   5F9
....................     ret = MAX_INT; 
05F2:  CLRF   67
05F3:  CLRF   66
05F4:  MOVLW  7F
05F5:  MOVWF  65
05F6:  MOVLW  FF
05F7:  MOVWF  64
....................   } 
....................   else if(ret < -MAX_INT){ 
05F8:  GOTO   618
05F9:  BTFSS  67.7
05FA:  GOTO   618
05FB:  MOVF   67,W
05FC:  SUBLW  FF
05FD:  BTFSS  03.0
05FE:  GOTO   618
05FF:  BTFSS  03.2
0600:  GOTO   611
0601:  MOVF   66,W
0602:  SUBLW  FF
0603:  BTFSS  03.0
0604:  GOTO   618
0605:  BTFSS  03.2
0606:  GOTO   611
0607:  MOVF   65,W
0608:  SUBLW  80
0609:  BTFSS  03.0
060A:  GOTO   618
060B:  BTFSS  03.2
060C:  GOTO   611
060D:  MOVF   64,W
060E:  SUBLW  00
060F:  BTFSS  03.0
0610:  GOTO   618
....................     ret = -MAX_INT; 
0611:  MOVLW  FF
0612:  MOVWF  67
0613:  MOVWF  66
0614:  MOVLW  80
0615:  MOVWF  65
0616:  MOVLW  01
0617:  MOVWF  64
....................   } 
....................  
....................   return((signed int16)ret); 
0618:  MOVF   64,W
0619:  MOVWF  21
061A:  MOVF   65,W
061B:  MOVWF  22
.................... } 
061C:  BSF    0A.3
061D:  GOTO   175 (RETURN)
....................  
.................... /*! \brief Resets the integrator. 
....................  * 
....................  *  Calling this function will reset the integrator in the PID regulator. 
....................  */ 
.................... void pid_Reset_Integrator(pidData_t *pid_st) 
.................... { 
....................   pid_st->sumError = 0; 
.................... } 
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
