<<<<<<< HEAD
CCS PCM C Compiler, Version 4.084, 46530               02-Feb-13 15:09

               Filename: HondaHybrid.lst

               ROM used: 1104 words (29%)
                         Largest free fragment is 1788
               RAM used: 61 (34%) at main() level
                         74 (41%) worst case
=======
CCS PCM C Compiler, Version 4.084, 46530               24-Nov-12 20:05

               Filename: HondaHybrid.lst

               ROM used: 708 words (18%)
                         Largest free fragment is 1788
               RAM used: 60 (34%) at main() level
                         86 (48%) worst case
>>>>>>> Addng brake switch
               Stack:    2 worst case (1 in main + 1 for interrupts)

*
0000:  NOP
0001:  MOVLW  00
0002:  MOVWF  0A
<<<<<<< HEAD
0003:  GOTO   328
=======
0003:  GOTO   20B
>>>>>>> Addng brake switch
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  26
0008:  MOVF   7F,W
0009:  MOVWF  25
000A:  MOVF   0A,W
000B:  MOVWF  2D
000C:  CLRF   0A
000D:  SWAPF  25,F
000E:  MOVF   04,W
000F:  MOVWF  27
0010:  MOVF   20,W
0011:  MOVWF  28
0012:  MOVF   21,W
0013:  MOVWF  29
0014:  MOVF   22,W
0015:  MOVWF  2A
0016:  MOVF   23,W
0017:  MOVWF  2B
0018:  MOVF   24,W
0019:  MOVWF  2C
001A:  BCF    03.7
001B:  BCF    03.5
001C:  MOVLW  8C
001D:  MOVWF  04
001E:  BTFSS  00.0
001F:  GOTO   022
0020:  BTFSC  0C.0
0021:  GOTO   03F
0022:  MOVLW  8D
0023:  MOVWF  04
0024:  BTFSS  00.0
0025:  GOTO   028
0026:  BTFSC  0D.0
0027:  GOTO   041
0028:  BTFSS  0B.5
0029:  GOTO   02C
002A:  BTFSC  0B.2
002B:  GOTO   043
002C:  MOVF   27,W
002D:  MOVWF  04
002E:  MOVF   28,W
002F:  MOVWF  20
0030:  MOVF   29,W
0031:  MOVWF  21
0032:  MOVF   2A,W
0033:  MOVWF  22
0034:  MOVF   2B,W
0035:  MOVWF  23
0036:  MOVF   2C,W
0037:  MOVWF  24
0038:  MOVF   2D,W
0039:  MOVWF  0A
003A:  SWAPF  26,W
003B:  MOVWF  03
003C:  SWAPF  7F,F
003D:  SWAPF  7F,W
003E:  RETFIE
003F:  BCF    0A.3
<<<<<<< HEAD
0040:  GOTO   053
0041:  BCF    0A.3
0042:  GOTO   09B
=======
0040:  GOTO   055
0041:  BCF    0A.3
0042:  GOTO   09C
>>>>>>> Addng brake switch
0043:  BCF    0A.3
0044:  GOTO   045
.................... #include "HondaHybrid.h" 
.................... #include <16F873A.h> 
.................... //////// Standard Header file for the PIC16F873A device //////////////// 
.................... #device PIC16F873A 
.................... #list 
....................  
....................  
.................... //#include <16F737.h> 
.................... #device ICD=TRUE 
.................... #device adc=10 
.................... //#device adc=8 
.................... #use delay(clock=20000000) 
<<<<<<< HEAD
*
0123:  MOVLW  55
0124:  MOVWF  04
0125:  MOVF   00,W
0126:  BTFSC  03.2
0127:  GOTO   135
0128:  MOVLW  06
0129:  MOVWF  21
012A:  CLRF   20
012B:  DECFSZ 20,F
012C:  GOTO   12B
012D:  DECFSZ 21,F
012E:  GOTO   12A
012F:  MOVLW  7B
0130:  MOVWF  20
0131:  DECFSZ 20,F
0132:  GOTO   131
0133:  DECFSZ 00,F
0134:  GOTO   128
0135:  BCF    0A.3
0136:  GOTO   3A2 (RETURN)
=======
>>>>>>> Addng brake switch
.................... #fuses HS,PUT,NOWDT 
.................... #use rs232 (DEBUGGER) 
.................... #include <mcp4921.c> 
.................... //////////////// Driver for MCP4921 D/A Converter /////////////////////// 
.................... ////                                                                 //// 
.................... ////  init_dac()    Call this before using a MCP4921 DAC             //// 
.................... ////                                                                 //// 
.................... ////  write_dac( long int )   Writes command and 12 bit resolution   //// 
.................... ////                          to the MCP4921 which converts it to a  //// 
.................... ////                          voltage                                //// 
.................... ////                          0-4095 input represents 0-vref V out.  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SELECT 
....................  
.................... #define DAC_CS     PIN_C4 
.................... #define DAC_CLK    PIN_C3 
.................... #define DAC_DI     PIN_C5 
.................... #define DAC_LDAC   PIN_B5 
....................  
.................... #endif 
....................  
.................... void init_dac() 
.................... { 
....................    output_high(DAC_CS); 
*
<<<<<<< HEAD
00AF:  BCF    2E.4
00B0:  MOVF   2E,W
00B1:  BSF    03.5
00B2:  MOVWF  07
00B3:  BCF    03.5
00B4:  BSF    07.4
....................    output_high(DAC_LDAC); 
00B5:  BSF    03.5
00B6:  BCF    06.5
00B7:  BCF    03.5
00B8:  BSF    06.5
....................    output_high(DAC_CLK); 
00B9:  BCF    2E.3
00BA:  MOVF   2E,W
00BB:  BSF    03.5
00BC:  MOVWF  07
00BD:  BCF    03.5
00BE:  BSF    07.3
....................    output_high(DAC_DI); 
00BF:  BCF    2E.5
00C0:  MOVF   2E,W
00C1:  BSF    03.5
00C2:  MOVWF  07
00C3:  BCF    03.5
00C4:  BSF    07.5
.................... } 
00C5:  BCF    0A.3
00C6:  GOTO   375 (RETURN)
=======
00A7:  BCF    2E.4
00A8:  MOVF   2E,W
00A9:  BSF    03.5
00AA:  MOVWF  07
00AB:  BCF    03.5
00AC:  BSF    07.4
....................    output_high(DAC_LDAC); 
00AD:  BSF    03.5
00AE:  BCF    06.4
00AF:  BCF    03.5
00B0:  BSF    06.4
....................    output_high(DAC_CLK); 
00B1:  BCF    2E.3
00B2:  MOVF   2E,W
00B3:  BSF    03.5
00B4:  MOVWF  07
00B5:  BCF    03.5
00B6:  BSF    07.3
....................    output_high(DAC_DI); 
00B7:  BCF    2E.5
00B8:  MOVF   2E,W
00B9:  BSF    03.5
00BA:  MOVWF  07
00BB:  BCF    03.5
00BC:  BSF    07.5
.................... } 
00BD:  BCF    0A.3
00BE:  GOTO   264 (RETURN)
>>>>>>> Addng brake switch
....................  
.................... void write_dac(int16 data) { 
....................    BYTE cmd[3]; 
....................    BYTE i; 
....................  
....................    cmd[0]=data; 
<<<<<<< HEAD
00C7:  MOVF   5C,W
00C8:  MOVWF  5E
....................    cmd[1]=(data>>8); 
00C9:  MOVF   5D,W
00CA:  MOVWF  5F
....................    cmd[2]=0x03;                            
00CB:  MOVLW  03
00CC:  MOVWF  60
....................     
....................    output_high(DAC_LDAC); 
00CD:  BSF    03.5
00CE:  BCF    06.5
00CF:  BCF    03.5
00D0:  BSF    06.5
....................    output_low(DAC_CLK); 
00D1:  BCF    2E.3
00D2:  MOVF   2E,W
00D3:  BSF    03.5
00D4:  MOVWF  07
00D5:  BCF    03.5
00D6:  BCF    07.3
....................    output_low(DAC_CS); 
00D7:  BCF    2E.4
00D8:  MOVF   2E,W
00D9:  BSF    03.5
00DA:  MOVWF  07
00DB:  BCF    03.5
00DC:  BCF    07.4
....................  
....................    for(i=0; i<=23; ++i) 
00DD:  CLRF   61
00DE:  MOVF   61,W
00DF:  SUBLW  17
00E0:  BTFSS  03.0
00E1:  GOTO   10F
....................    { 
....................       if(i<4 || (i>7 && i<12)) 
00E2:  MOVF   61,W
00E3:  SUBLW  03
00E4:  BTFSC  03.0
00E5:  GOTO   0EE
00E6:  MOVF   61,W
00E7:  SUBLW  07
00E8:  BTFSC  03.0
00E9:  GOTO   0F3
00EA:  MOVF   61,W
00EB:  SUBLW  0B
00EC:  BTFSS  03.0
00ED:  GOTO   0F3
....................          shift_left(cmd,3,0); 
00EE:  BCF    03.0
00EF:  RLF    5E,F
00F0:  RLF    5F,F
00F1:  RLF    60,F
....................       else 
00F2:  GOTO   10D
....................       { 
....................          output_bit(DAC_DI, shift_left(cmd,3,0)); 
00F3:  BCF    03.0
00F4:  RLF    5E,F
00F5:  RLF    5F,F
00F6:  RLF    60,F
00F7:  BTFSC  03.0
00F8:  GOTO   0FB
00F9:  BCF    07.5
00FA:  GOTO   0FC
00FB:  BSF    07.5
00FC:  BCF    2E.5
00FD:  MOVF   2E,W
00FE:  BSF    03.5
00FF:  MOVWF  07
....................  
....................          output_high(DAC_CLK); 
0100:  BCF    03.5
0101:  BCF    2E.3
0102:  MOVF   2E,W
0103:  BSF    03.5
0104:  MOVWF  07
0105:  BCF    03.5
0106:  BSF    07.3
....................          output_low(DAC_CLK); 
0107:  BCF    2E.3
0108:  MOVF   2E,W
0109:  BSF    03.5
010A:  MOVWF  07
010B:  BCF    03.5
010C:  BCF    07.3
....................       } 
....................    } 
010D:  INCF   61,F
010E:  GOTO   0DE
....................    output_high(DAC_CS); 
010F:  BCF    2E.4
0110:  MOVF   2E,W
0111:  BSF    03.5
0112:  MOVWF  07
0113:  BCF    03.5
0114:  BSF    07.4
....................  
....................    output_low(DAC_LDAC); 
0115:  BSF    03.5
0116:  BCF    06.5
0117:  BCF    03.5
0118:  BCF    06.5
....................    delay_us(10); 
0119:  MOVLW  10
011A:  MOVWF  20
011B:  DECFSZ 20,F
011C:  GOTO   11B
011D:  NOP
....................     
....................    output_HIGH(DAC_LDAC); 
011E:  BSF    03.5
011F:  BCF    06.5
0120:  BCF    03.5
0121:  BSF    06.5
.................... } 
0122:  RETLW  00
=======
*
01AE:  MOVF   5B,W
01AF:  MOVWF  5D
....................    cmd[1]=(data>>8); 
01B0:  MOVF   5C,W
01B1:  MOVWF  5E
....................    cmd[2]=0x03;                            
01B2:  MOVLW  03
01B3:  MOVWF  5F
....................     
....................    output_high(DAC_LDAC); 
01B4:  BSF    03.5
01B5:  BCF    06.4
01B6:  BCF    03.5
01B7:  BSF    06.4
....................    output_low(DAC_CLK); 
01B8:  BCF    2E.3
01B9:  MOVF   2E,W
01BA:  BSF    03.5
01BB:  MOVWF  07
01BC:  BCF    03.5
01BD:  BCF    07.3
....................    output_low(DAC_CS); 
01BE:  BCF    2E.4
01BF:  MOVF   2E,W
01C0:  BSF    03.5
01C1:  MOVWF  07
01C2:  BCF    03.5
01C3:  BCF    07.4
....................  
....................    for(i=0; i<=23; ++i) 
01C4:  CLRF   60
01C5:  MOVF   60,W
01C6:  SUBLW  17
01C7:  BTFSS  03.0
01C8:  GOTO   1F6
....................    { 
....................       if(i<4 || (i>7 && i<12)) 
01C9:  MOVF   60,W
01CA:  SUBLW  03
01CB:  BTFSC  03.0
01CC:  GOTO   1D5
01CD:  MOVF   60,W
01CE:  SUBLW  07
01CF:  BTFSC  03.0
01D0:  GOTO   1DA
01D1:  MOVF   60,W
01D2:  SUBLW  0B
01D3:  BTFSS  03.0
01D4:  GOTO   1DA
....................          shift_left(cmd,3,0); 
01D5:  BCF    03.0
01D6:  RLF    5D,F
01D7:  RLF    5E,F
01D8:  RLF    5F,F
....................       else 
01D9:  GOTO   1F4
....................       { 
....................          output_bit(DAC_DI, shift_left(cmd,3,0)); 
01DA:  BCF    03.0
01DB:  RLF    5D,F
01DC:  RLF    5E,F
01DD:  RLF    5F,F
01DE:  BTFSC  03.0
01DF:  GOTO   1E2
01E0:  BCF    07.5
01E1:  GOTO   1E3
01E2:  BSF    07.5
01E3:  BCF    2E.5
01E4:  MOVF   2E,W
01E5:  BSF    03.5
01E6:  MOVWF  07
....................  
....................          output_high(DAC_CLK); 
01E7:  BCF    03.5
01E8:  BCF    2E.3
01E9:  MOVF   2E,W
01EA:  BSF    03.5
01EB:  MOVWF  07
01EC:  BCF    03.5
01ED:  BSF    07.3
....................          output_low(DAC_CLK); 
01EE:  BCF    2E.3
01EF:  MOVF   2E,W
01F0:  BSF    03.5
01F1:  MOVWF  07
01F2:  BCF    03.5
01F3:  BCF    07.3
....................       } 
....................    } 
01F4:  INCF   60,F
01F5:  GOTO   1C5
....................    output_high(DAC_CS); 
01F6:  BCF    2E.4
01F7:  MOVF   2E,W
01F8:  BSF    03.5
01F9:  MOVWF  07
01FA:  BCF    03.5
01FB:  BSF    07.4
....................  
....................    output_low(DAC_LDAC); 
01FC:  BSF    03.5
01FD:  BCF    06.4
01FE:  BCF    03.5
01FF:  BCF    06.4
....................    delay_us(10); 
0200:  MOVLW  10
0201:  MOVWF  20
0202:  DECFSZ 20,F
0203:  GOTO   202
0204:  NOP
....................     
....................    output_HIGH(DAC_LDAC); 
0205:  BSF    03.5
0206:  BCF    06.4
0207:  BCF    03.5
0208:  BSF    06.4
.................... } 
0209:  BCF    0A.3
020A:  GOTO   2C2 (RETURN)
>>>>>>> Addng brake switch
....................  
....................  
....................  
.................... #include "pid.h" 
.................... /*This file has been prepared for Doxygen automatic documentation generation.*/ 
.................... /*! \file ********************************************************************* 
....................  * 
....................  * \brief Header file for pid.c. 
....................  * 
....................  * - File:               pid.h 
....................  * - Compiler:           IAR EWAAVR 4.11A 
....................  * - Supported devices:  All AVR devices can be used. 
....................  * - AppNote:            AVR221 - Discrete PID controller 
....................  * 
....................  * \author               Atmel Corporation: http://www.atmel.com \n 
....................  *                       Support email: avr@atmel.com 
....................  * 
....................  * $Name$ 
....................  * $Revision: 456 $ 
....................  * $RCSfile$ 
....................  * $Date: 2006-02-16 12:46:13 +0100 (to, 16 feb 2006) $ 
....................  *****************************************************************************/ 
....................  
.................... #ifndef PID_H 
.................... #define PID_H 
....................  
.................... //#include "stdint.h" 
.................... #define INT16_MAX 32767 
.................... #define INT32_MAX 2147483647 
.................... #define SCALING_FACTOR  128 
....................  
.................... /*! \brief PID Status 
....................  * 
....................  * Setpoints and data used by the PID control algorithm 
....................  */ 
.................... typedef struct PID_DATA{ 
....................   //! Last process value, used to find derivative of process value. 
....................   int16 lastProcessValue; 
....................   //! Summation of errors, used for integrate calculations 
....................   int32 sumError; 
....................   //! The Proportional tuning constant, multiplied with SCALING_FACTOR 
....................   int16 P_Factor; 
....................   //! The Integral tuning constant, multiplied with SCALING_FACTOR 
....................   int16 I_Factor; 
....................   //! The Derivative tuning constant, multiplied with SCALING_FACTOR 
....................   int16 D_Factor; 
....................   //! Maximum allowed error, avoid overflow 
....................   int16 maxError; 
....................   //! Maximum allowed sumerror, avoid overflow 
....................   int32 maxSumError; 
.................... } pidData_t; 
....................  
.................... /*! \brief Maximum values 
....................  * 
....................  * Needed to avoid sign/overflow problems 
....................  */ 
.................... // Maximum value of variables 
.................... #define MAX_INT         INT16_MAX 
.................... #define MAX_LONG        INT32_MAX 
.................... #define MAX_I_TERM      (MAX_LONG / 2) 
....................  
.................... // Boolean values 
.................... #define FALSE           0 
.................... #define TRUE            1 
....................  
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid); 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st); 
.................... void pid_Reset_Integrator(pidData_t *pid_st); 
....................  
.................... #endif 
....................  
.................... /* 
.................... This is the main controller for the super capacitor hybrid scooter a.k.a RED 
.................... B2 close contactor 
.................... CONTROL BOX INPUTS 
.................... Athrottle- A0 - analog input representing the users input for speed, 10 bit 
.................... Vspeed - CCp2-a 16 bit representation of the speed of the vehicle 
.................... Acaps- A1 - analog input representing the current voltage of the supercapacitors, 10 bit 
....................  
.................... CONTROL BOX OUTPUT 
.................... ICEthrottle- B1 - a 16 bit number sent to the internal combustion engine(ICE) throttle  
.................... ELECthrottle-  - a 16 bit number sent as analog value representing the demanded electric power 
....................  
.................... SPECIFICS OF I/O 
....................  
.................... Athrottle - the electric throttle is a 3 wire unit with a 5 volt,ground, and analog out 
....................    representing how far throttle is turned. Pin AN0 is the input. 
....................     
.................... Vspeed - There is a encoder in the rear wheel/electric motor that is used by the electric 
....................    power controller. Tapping in to this this Main Controller receives a 5 Volt square wave 
....................    with 42 pulses. There are two options for measuring speed. The first is to measure the  
....................    length of the pulses. The second is to measure the rate of pulses. This controller currently 
....................    uses the rate method. The int_ccp2 interupt is called on each falling edge and stores the  
....................    Vspeed value as the max number of 16bit (65535-timer0_since_last_reset).  
....................     
....................    The RED scooter has a circumpherence of 16.3*2*pi = 102.4 
....................    X m/h * 63360 inch/mile * 1/3600 h/sec * 1/(102.4 inch/rev) = .171875* X 
....................    Examples 50 mph is 8.9 ms 1 overflow of timer0 
....................    Example 5 mph is 89 ms or 13 time overflow 
....................     
....................    #int_timer0 increments the counter number_of_overflows each time it overflows 
....................    On int ccp2 we multiply number_of_overflows * 256 + timer0 to get timer0_since_last_reset 
....................     
.................... Acaps - the analog voltage which is the 5volt representation of the voltage in the caps which 
....................    have a value of between 0-48v. The voltages are factored so that the voltage on AN1 goes 
....................    from 0 - 4.8 volts (TODO check this factor, think its 1/11 not 1/10) 
....................     
.................... ICEthrottle -  #int_timer1 is set to make sure the period follows the required below 
....................    The period for the servo is .020 seconds which is 50,000 operations 
....................    The leftmost position of the server is .001 seconds which is 2,500 
....................    The rightmost position of the server is .002 seconds which is 5,000 
....................     
....................    The output pin is pin_B1.-> 
....................  
.................... ELECthrottle 
....................    The electric power controller takes an analog voltage as input. The output voltage 
....................    is set by the DAC. The pins used are C3,C4,C5. if CHARGING_STATE is true then  
....................     
.................... ALGORITHM 
....................    The algorithm is basically a PID controller. In broad terms we are trying to set the 
....................    ICEthrottle and ICEelectric to maximize the use of electric and accelerate to meet the 
....................    requirements set by the rider with the Athrottle signal. When the demanded power is  
....................    less than the power output possible by the ICE and the caps are in the CHARGING_STATE  
....................    then the ICE is turned up to the max and the ELECthrottle is set to regen to 
....................    charge the capacitors.If CHARGING_STATE is false then the caps are supplying the drivig power 
....................    and the ICE is set to "off", the caps supply the power. Unless the user requested supply 
....................    is enough to require both power sources. 
....................     
....................    If CHARGING_STATE is true. Then pin_b2 is set as high which will close the brake number 
....................    for the electric power controller.  
....................     
....................    If CHARGING_STATE is false then the pin_b2 is set low which opens brake. 
....................     
....................     
....................  
....................  
.................... The encoder has 42 on and offs per rotation, i.e. 21 steps 
....................  
.................... Number of operations per second is CLOCK/4/Timer Divisions 
.................... Number of operations per second is 20,000,000/4/128 = 39062.5  
.................... Each operation takes 1/39062.5 = .256 micro (x10^-6) seconds 
.................... Seconds to Overflow timer0 8bit timer = .256x10^-6 * 256 = 6.55ms 
....................  
....................  
....................  
.................... */ 
.................... #define servo_pin PIN_B1  //Setting servo out pin to be hardware pin b1 
<<<<<<< HEAD
.................... #define brake_pin PIN_B4 
=======
.................... #define brake_pin PIN_B4 // SET LOW to enable 
>>>>>>> Addng brake switch
.................... #define ADC_DELAY delay_us(20) 
.................... #define Acaps_pin PIN_A1 
.................... #define Acaps_channel 1 
.................... #define Athrottle_pin PIN_A0 
.................... #define Athrottle_channel 0 
.................... #define Electric_Controller_Switch PIN_B0 
.................... #define Contactor_Switch PIN_B2 
....................  
.................... //PID Values 
.................... #define K_P 1.00 
.................... #define K_I 1.00 
.................... #define K_D 0.00 
....................  
.................... int1 pid_Timer = 0; 
*
<<<<<<< HEAD
0339:  BCF    2F.0
.................... struct PID_DATA pidData; 
.................... #define TIME_INTERVAL 157 //TODO replace 
....................  
.................... #define left_position 3950 
.................... #define right_position 4800 
.................... #define servo_difference  right_position-left_position 
.................... const float Athrottle_servo_factor = ((float) servo_difference)/((float) Athrottle_FULL); 
.................... #define servo_period   65356-50000 
.................... unsigned int16 current_servo_position=right_position; 
033A:  MOVLW  C0
033B:  MOVWF  42
033C:  MOVLW  12
033D:  MOVWF  43
.................... int1 SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0; 
033E:  BCF    2F.1
.................... int1 test_boolean = 0; 
033F:  BCF    2F.2
....................  
.................... int1 test_switch = 0; 
0340:  BCF    2F.3
.................... unsigned int16 test_counter = 0; 
0341:  CLRF   44
0342:  CLRF   45
....................  
.................... unsigned int16 number_of_timer0_interupts_since_reset =0; 
0343:  CLRF   46
0344:  CLRF   47
.................... unsigned int16 timer0_since_last_reset= 0; 
0345:  CLRF   48
0346:  CLRF   49
.................... unsigned int16 vSpeed= 0; 
0347:  CLRF   4A
0348:  CLRF   4B
.................... unsigned int16 ELECthrottle = 0; 
0349:  CLRF   4C
034A:  CLRF   4D
.................... unsigned int16 ICEthrottle = 0; 
034B:  CLRF   4E
034C:  CLRF   4F
.................... unsigned int16 Athrottle = 0; 
034D:  CLRF   50
034E:  CLRF   51
.................... unsigned int16 Acaps = 0; 
034F:  CLRF   52
0350:  CLRF   53
.................... int1 CURRENTLY_CHARGING = 0; 
0351:  BCF    2F.4
=======
021C:  BCF    2F.0
.................... struct PID_DATA pidData; 
.................... #define TIME_INTERVAL 157 //TODO replace 
....................  
.................... static int16 left_position = 2500; 
021D:  MOVLW  C4
021E:  MOVWF  42
021F:  MOVLW  09
0220:  MOVWF  43
.................... static int16 right_position = 5000; 
0221:  MOVLW  88
0222:  MOVWF  44
0223:  MOVLW  13
0224:  MOVWF  45
.................... static int16 servo_period   = 65356-50000; 
0225:  MOVLW  FC
0226:  MOVWF  46
0227:  MOVLW  3B
0228:  MOVWF  47
.................... unsigned int16 current_servo_position=2500; 
0229:  MOVLW  C4
022A:  MOVWF  48
022B:  MOVLW  09
022C:  MOVWF  49
.................... int1 SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0; 
022D:  BCF    2F.1
.................... int1 test_boolean = 0; 
022E:  BCF    2F.2
....................  
.................... int1 test_switch = 0; 
022F:  BCF    2F.3
.................... unsigned int16 test_counter = 0; 
0230:  CLRF   4A
0231:  CLRF   4B
....................  
.................... unsigned int8 number_of_timer0_interupts_since_reset =0; 
0232:  CLRF   4C
.................... unsigned int16 timer0_since_last_reset= 0; 
0233:  CLRF   4D
0234:  CLRF   4E
.................... unsigned int16 vSpeed= 255; 
0235:  MOVLW  FF
0236:  MOVWF  4F
0237:  CLRF   50
.................... unsigned int16 ELECthrottle = 0; 
0238:  CLRF   51
0239:  CLRF   52
.................... unsigned int16 ICEthrottle = 0; 
023A:  CLRF   53
023B:  CLRF   54
.................... unsigned int16 Athrottle = 0; 
023C:  CLRF   55
023D:  CLRF   56
.................... unsigned int16 Acaps = 0; 
023E:  CLRF   57
023F:  CLRF   58
.................... int1 CURRENTLY_CHARGING = 0; 
0240:  BCF    2F.4
>>>>>>> Addng brake switch
....................  
.................... /* 
.................... The #int_timer0 interupt is triggered on each timer0 8bit interupt 
.................... the function simply increments a overflow counter to be used by the ccp2 
.................... interupt to calculate speed 
.................... NUMBER OF OPERATIONS =  
.................... */ 
.................... #int_timer0 
.................... void timer0_isr(){ 
....................     
....................       number_of_timer0_interupts_since_reset=number_of_timer0_interupts_since_reset+256; 
*
<<<<<<< HEAD
0045:  MOVLW  01
0046:  ADDWF  47,F
....................       //current_servo_position=current_servo_position+1; 
....................        
....................     
....................    if (number_of_timer0_interupts_since_reset>=1024){ 
0047:  MOVF   47,W
0048:  SUBLW  03
0049:  BTFSC  03.0
004A:  GOTO   050
....................       vSpeed = 1024; 
004B:  MOVLW  04
004C:  MOVWF  4B
004D:  CLRF   4A
....................       number_of_timer0_interupts_since_reset=1024; 
004E:  MOVWF  47
004F:  CLRF   46
....................        
=======
0045:  INCFSZ 4C,W
0046:  GOTO   048
0047:  GOTO   04A
....................       number_of_timer0_interupts_since_reset++; 
0048:  INCF   4C,F
....................        
....................        
....................    } 
....................    else { 
0049:  GOTO   052
....................       vSpeed = 255; 
004A:  CLRF   50
004B:  MOVLW  FF
004C:  MOVWF  4F
....................       number_of_timer0_interupts_since_reset=0; 
004D:  CLRF   4C
....................       current_servo_position=current_servo_position+100; 
004E:  MOVLW  64
004F:  ADDWF  48,F
0050:  BTFSC  03.0
0051:  INCF   49,F
>>>>>>> Addng brake switch
....................        
....................    } 
.................... } 
....................  
.................... /* 
.................... #int_timer1 is used by the ICEservo throttle to regulate the timing pulses. The  
.................... timer is setup for a pulsetrain of 20ms period. This is done as follows, 
....................  
.................... Period is 1/(CLOCK/4opsperclock)*(startingPostionOfClock) = 20 ms 
.................... for this setup 1/(20000000/4)*(50000) = 20 ms 
....................  
.................... The timer1 starts at 0 and counts up. So we set the beggining of the clock at 
.................... servo_period which is 65356-50000 so that the total time is 20ms. 
.................... */ 
<<<<<<< HEAD
0050:  BCF    0B.2
0051:  BCF    0A.3
0052:  GOTO   02C
=======
0052:  BCF    0B.2
0053:  BCF    0A.3
0054:  GOTO   02C
>>>>>>> Addng brake switch
.................... #int_timer1 
.................... void isr() 
.................... { 
....................  
.................... //Make sure that the position is within the left and right positions of the servo 
....................    if (current_servo_position<left_position){ 
<<<<<<< HEAD
0053:  MOVF   43,W
0054:  SUBLW  0F
0055:  BTFSS  03.0
0056:  GOTO   062
0057:  BTFSS  03.2
0058:  GOTO   05D
0059:  MOVF   42,W
005A:  SUBLW  6D
005B:  BTFSS  03.0
005C:  GOTO   062
....................       current_servo_position = left_position; 
005D:  MOVLW  0F
005E:  MOVWF  43
005F:  MOVLW  6E
0060:  MOVWF  42
....................    } 
....................    else if (current_servo_position > right_position){ 
0061:  GOTO   071
0062:  MOVF   43,W
0063:  SUBLW  11
0064:  BTFSC  03.0
0065:  GOTO   071
0066:  XORLW  FF
0067:  BTFSS  03.2
0068:  GOTO   06D
0069:  MOVF   42,W
006A:  SUBLW  C0
006B:  BTFSC  03.0
006C:  GOTO   071
....................       current_servo_position = right_position; 
006D:  MOVLW  12
006E:  MOVWF  43
006F:  MOVLW  C0
0070:  MOVWF  42
....................    } 
....................  
....................    if(SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER) 
0071:  BTFSS  2F.1
0072:  GOTO   086
....................       {  
....................          output_high(servo_pin);        //Set the servo control pin to high  
0073:  BSF    03.5
0074:  BCF    06.1
0075:  BCF    03.5
0076:  BSF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0;  
0077:  BCF    2F.1
....................          set_timer1(65356-current_servo_position); //Set timer for the position high pulse 
0078:  MOVF   42,W
0079:  SUBLW  4C
007A:  MOVWF  67
007B:  MOVLW  FF
007C:  MOVWF  68
007D:  MOVF   43,W
007E:  BTFSS  03.0
007F:  INCFSZ 43,W
0080:  SUBWF  68,F
0081:  MOVF   68,W
0082:  MOVWF  0F
0083:  MOVF   67,W
0084:  MOVWF  0E
....................       }  
....................    else  
0085:  GOTO   098
....................       {  
....................          output_low(servo_pin);                      // Set the servo control pin to low   
0086:  BSF    03.5
0087:  BCF    06.1
0088:  BCF    03.5
0089:  BCF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 1;  
008A:  BSF    2F.1
....................          set_timer1(servo_period+current_servo_position);          //Set timer for the low position the length is the difference between  
008B:  MOVLW  FC
008C:  ADDWF  42,W
008D:  MOVWF  67
008E:  MOVF   43,W
008F:  MOVWF  68
0090:  MOVLW  3B
0091:  BTFSC  03.0
0092:  MOVLW  3C
0093:  ADDWF  68,F
0094:  MOVF   68,W
0095:  MOVWF  0F
0096:  MOVF   67,W
0097:  MOVWF  0E
=======
0055:  MOVF   49,W
0056:  SUBWF  43,W
0057:  BTFSS  03.0
0058:  GOTO   064
0059:  BTFSS  03.2
005A:  GOTO   05F
005B:  MOVF   42,W
005C:  SUBWF  48,W
005D:  BTFSC  03.0
005E:  GOTO   064
....................       current_servo_position = left_position; 
005F:  MOVF   43,W
0060:  MOVWF  49
0061:  MOVF   42,W
0062:  MOVWF  48
....................    } 
....................    else if (current_servo_position > right_position){ 
0063:  GOTO   072
0064:  MOVF   45,W
0065:  SUBWF  49,W
0066:  BTFSS  03.0
0067:  GOTO   072
0068:  BTFSS  03.2
0069:  GOTO   06E
006A:  MOVF   48,W
006B:  SUBWF  44,W
006C:  BTFSC  03.0
006D:  GOTO   072
....................       current_servo_position = left_position; 
006E:  MOVF   43,W
006F:  MOVWF  49
0070:  MOVF   42,W
0071:  MOVWF  48
....................    } 
....................  
....................    if(SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER) 
0072:  BTFSS  2F.1
0073:  GOTO   087
....................       {  
....................          output_high(servo_pin);        //Set the servo control pin to high  
0074:  BSF    03.5
0075:  BCF    06.1
0076:  BCF    03.5
0077:  BSF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0;  
0078:  BCF    2F.1
....................          set_timer1(65356-current_servo_position); //Set timer for the position high pulse 
0079:  MOVF   48,W
007A:  SUBLW  4C
007B:  MOVWF  73
007C:  MOVLW  FF
007D:  MOVWF  74
007E:  MOVF   49,W
007F:  BTFSS  03.0
0080:  INCFSZ 49,W
0081:  SUBWF  74,F
0082:  MOVF   74,W
0083:  MOVWF  0F
0084:  MOVF   73,W
0085:  MOVWF  0E
....................       }  
....................    else  
0086:  GOTO   099
....................       {  
....................          output_low(servo_pin);                      // Set the servo control pin to low   
0087:  BSF    03.5
0088:  BCF    06.1
0089:  BCF    03.5
008A:  BCF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 1;  
008B:  BSF    2F.1
....................          set_timer1(servo_period+current_servo_position);          //Set timer for the low position the length is the difference between  
008C:  MOVF   48,W
008D:  ADDWF  46,W
008E:  MOVWF  73
008F:  MOVF   47,W
0090:  MOVWF  74
0091:  MOVF   49,W
0092:  BTFSC  03.0
0093:  INCFSZ 49,W
0094:  ADDWF  74,F
0095:  MOVF   74,W
0096:  MOVWF  0F
0097:  MOVF   73,W
0098:  MOVWF  0E
>>>>>>> Addng brake switch
....................                                                      //the total int16 lenght - high pulse length 
....................       }   
.................... } 
....................  
....................  
.................... /* 
.................... #int_ccp2 is called on the falling edge of the encoder pulse. We calculate the time 
.................... between pulses.  
.................... TODO will have to put some kind of smoothing mechanism 
.................... */ 
<<<<<<< HEAD
0098:  BCF    0C.0
0099:  BCF    0A.3
009A:  GOTO   02C
.................... #int_ccp2 
.................... void isr2() 
.................... { 
.................... if (number_of_timer0_interupts_since_reset>10){ 
009B:  MOVF   47,F
009C:  BTFSS  03.2
009D:  GOTO   0A2
009E:  MOVF   46,W
009F:  SUBLW  0A
00A0:  BTFSC  03.0
00A1:  GOTO   0AC
.................... vSpeed  = (number_of_timer0_interupts_since_reset+get_timer0()); 
00A2:  MOVF   01,W
00A3:  ADDWF  46,W
00A4:  MOVWF  4A
00A5:  MOVF   47,W
00A6:  MOVWF  4B
00A7:  BTFSC  03.0
00A8:  INCF   4B,F
.................... //vSpeed  = -(get_timer0()); 
.................... set_timer0(0); 
00A9:  CLRF   01
.................... number_of_timer0_interupts_since_reset = 0; 
00AA:  CLRF   47
00AB:  CLRF   46
=======
0099:  BCF    0C.0
009A:  BCF    0A.3
009B:  GOTO   02C
.................... #int_ccp2 
.................... void isr2() 
.................... { 
.................... if (number_of_timer0_interupts_since_reset>20){ 
009C:  MOVF   4C,W
009D:  SUBLW  14
009E:  BTFSC  03.0
009F:  GOTO   0A4
.................... vSpeed  = number_of_timer0_interupts_since_reset; 
00A0:  CLRF   50
00A1:  MOVF   4C,W
00A2:  MOVWF  4F
.................... number_of_timer0_interupts_since_reset = 0; 
00A3:  CLRF   4C
>>>>>>> Addng brake switch
.................... } 
.................... } 
....................  
....................  
....................  
....................  
<<<<<<< HEAD
00AC:  BCF    0D.0
00AD:  BCF    0A.3
00AE:  GOTO   02C
.................... void main() 
.................... {   
*
0328:  CLRF   04
0329:  MOVLW  1F
032A:  ANDWF  03,F
032B:  BSF    03.5
032C:  BCF    06.3
032D:  BCF    03.5
032E:  BSF    06.3
032F:  BSF    03.5
0330:  BSF    1F.0
0331:  BSF    1F.1
0332:  BSF    1F.2
0333:  BCF    1F.3
0334:  MOVLW  07
0335:  MOVWF  1C
....................     
....................    setup_adc_ports(NO_ANALOGS); 
*
0352:  BSF    03.5
0353:  BSF    1F.0
0354:  BSF    1F.1
0355:  BSF    1F.2
0356:  BCF    1F.3
....................    setup_adc(ADC_OFF); 
0357:  BCF    03.5
0358:  BCF    1F.0
....................    setup_spi(FALSE); 
0359:  CLRF   14
....................     
....................    setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
035A:  BSF    03.5
035B:  MOVF   01,W
035C:  ANDLW  C0
035D:  IORLW  00
035E:  MOVWF  01
035F:  CLRWDT
....................    setup_timer_1(T1_DISABLED); 
0360:  BCF    03.5
0361:  CLRF   10
....................    setup_timer_2(T2_DISABLED,0,1); 
0362:  MOVLW  00
0363:  MOVWF  21
0364:  MOVWF  12
0365:  MOVLW  00
0366:  BSF    03.5
0367:  MOVWF  12
....................    setup_port_a(ALL_ANALOG); 
0368:  BCF    1F.0
0369:  BCF    1F.1
036A:  BCF    1F.2
036B:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
036C:  BCF    1F.6
036D:  BCF    03.5
036E:  BSF    1F.6
036F:  BSF    1F.7
0370:  BSF    03.5
0371:  BSF    1F.7
0372:  BCF    03.5
0373:  BSF    1F.0
....................     
....................    init_dac(); 
0374:  GOTO   0AF
....................   
....................    setup_timer_1(T1_DIV_BY_2| T1_INTERNAL);  
0375:  MOVLW  95
0376:  MOVWF  10
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_128); 
0377:  BSF    03.5
0378:  MOVF   01,W
0379:  ANDLW  C0
037A:  IORLW  06
037B:  MOVWF  01
....................    setup_ccp2(CCP_CAPTURE_RE);    // Configure CCP2 to capture fall 
037C:  BCF    03.5
037D:  BSF    2E.1
037E:  MOVF   2E,W
037F:  BSF    03.5
0380:  MOVWF  07
0381:  BCF    03.5
0382:  CLRF   1D
0383:  MOVLW  05
0384:  MOVWF  1D
....................    enable_interrupts(INT_CCP2);   // Setup interrupt on falling edge 
0385:  BSF    03.5
0386:  BSF    0D.0
....................    enable_interrupts(INT_TIMER0); 
0387:  BCF    03.5
0388:  BSF    0B.5
....................    enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
0389:  BSF    03.5
038A:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
038B:  MOVLW  C0
038C:  BCF    03.5
038D:  IORWF  0B,F
....................    output_low(Electric_Controller_Switch); 
038E:  BSF    03.5
038F:  BCF    06.0
0390:  BCF    03.5
0391:  BCF    06.0
....................    write_dac(0); 
0392:  CLRF   5D
0393:  CLRF   5C
0394:  CALL   0C7
....................    output_high(Contactor_Switch); 
0395:  BSF    03.5
0396:  BCF    06.2
0397:  BCF    03.5
0398:  BSF    06.2
....................    output_low(brake_pin); 
0399:  BSF    03.5
039A:  BCF    06.4
039B:  BCF    03.5
039C:  BCF    06.4
....................    //pid_Init(K_P * SCALING_FACTOR,K_I*SCALING_FACTOR,K_D*SCALING_FACTOR, & pidData); 
....................     
....................    delay_ms(3000); 
039D:  MOVLW  0C
039E:  MOVWF  54
039F:  MOVLW  FA
03A0:  MOVWF  55
03A1:  GOTO   123
03A2:  DECFSZ 54,F
03A3:  GOTO   39F
....................    //write_dac(1000); 
....................    //delay_ms(10000); 
....................    //output_high(Contactor_Switch); 
....................    //output_high(brake_pin); 
....................    //output_high(Electric_Controller_Switch); 
=======
00A4:  BCF    0D.0
00A5:  BCF    0A.3
00A6:  GOTO   02C
.................... void main() 
.................... {   
*
020B:  CLRF   04
020C:  MOVLW  1F
020D:  ANDWF  03,F
020E:  BSF    03.5
020F:  BCF    06.3
0210:  BCF    03.5
0211:  BSF    06.3
0212:  BSF    03.5
0213:  BSF    1F.0
0214:  BSF    1F.1
0215:  BSF    1F.2
0216:  BCF    1F.3
0217:  MOVLW  07
0218:  MOVWF  1C
....................     
....................    setup_adc_ports(NO_ANALOGS); 
*
0241:  BSF    03.5
0242:  BSF    1F.0
0243:  BSF    1F.1
0244:  BSF    1F.2
0245:  BCF    1F.3
....................    setup_adc(ADC_OFF); 
0246:  BCF    03.5
0247:  BCF    1F.0
....................    setup_spi(FALSE); 
0248:  CLRF   14
....................     
....................    setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
0249:  BSF    03.5
024A:  MOVF   01,W
024B:  ANDLW  C0
024C:  IORLW  00
024D:  MOVWF  01
024E:  CLRWDT
....................    setup_timer_1(T1_DISABLED); 
024F:  BCF    03.5
0250:  CLRF   10
....................    setup_timer_2(T2_DISABLED,0,1); 
0251:  MOVLW  00
0252:  MOVWF  21
0253:  MOVWF  12
0254:  MOVLW  00
0255:  BSF    03.5
0256:  MOVWF  12
....................    setup_port_a(ALL_ANALOG); 
0257:  BCF    1F.0
0258:  BCF    1F.1
0259:  BCF    1F.2
025A:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
025B:  BCF    1F.6
025C:  BCF    03.5
025D:  BSF    1F.6
025E:  BSF    1F.7
025F:  BSF    03.5
0260:  BSF    1F.7
0261:  BCF    03.5
0262:  BSF    1F.0
....................     
....................    init_dac(); 
0263:  GOTO   0A7
....................   
....................    setup_timer_1(T1_DIV_BY_2| T1_INTERNAL);  
0264:  MOVLW  95
0265:  MOVWF  10
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_128); 
0266:  BSF    03.5
0267:  MOVF   01,W
0268:  ANDLW  C0
0269:  IORLW  06
026A:  MOVWF  01
....................    setup_ccp2(CCP_CAPTURE_RE);    // Configure CCP2 to capture fall 
026B:  BCF    03.5
026C:  BSF    2E.1
026D:  MOVF   2E,W
026E:  BSF    03.5
026F:  MOVWF  07
0270:  BCF    03.5
0271:  CLRF   1D
0272:  MOVLW  05
0273:  MOVWF  1D
....................    enable_interrupts(INT_CCP2);   // Setup interrupt on falling edge 
0274:  BSF    03.5
0275:  BSF    0D.0
....................    enable_interrupts(INT_TIMER0); 
0276:  BCF    03.5
0277:  BSF    0B.5
....................    enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
0278:  BSF    03.5
0279:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
027A:  MOVLW  C0
027B:  BCF    03.5
027C:  IORWF  0B,F
....................    output_high(Electric_Controller_Switch); 
027D:  BSF    03.5
027E:  BCF    06.0
027F:  BCF    03.5
0280:  BSF    06.0
....................    output_low(Contactor_Switch); 
0281:  BSF    03.5
0282:  BCF    06.2
0283:  BCF    03.5
0284:  BCF    06.2
....................     
....................    pid_Init(K_P * SCALING_FACTOR,K_I*SCALING_FACTOR,K_D*SCALING_FACTOR, & pidData); 
0285:  CLRF   5A
0286:  MOVLW  80
0287:  MOVWF  59
0288:  CLRF   5C
0289:  MOVWF  5B
028A:  CLRF   5E
028B:  CLRF   5D
028C:  MOVLW  30
028D:  MOVWF  5F
028E:  GOTO   0BF
....................     
....................     
>>>>>>> Addng brake switch
....................    while(TRUE) { 
....................        
....................       //GET INPUTS 
....................       //Vspeedhappens in interrupts 
....................        
....................       set_adc_channel(Acaps_channel); 
<<<<<<< HEAD
03A4:  MOVLW  08
03A5:  MOVWF  21
03A6:  MOVF   1F,W
03A7:  ANDLW  C7
03A8:  IORWF  21,W
03A9:  MOVWF  1F
....................       ADC_DELAY; 
03AA:  MOVLW  21
03AB:  MOVWF  20
03AC:  DECFSZ 20,F
03AD:  GOTO   3AC
....................       Acaps = read_adc(); 
03AE:  BSF    1F.2
03AF:  BTFSC  1F.2
03B0:  GOTO   3AF
03B1:  BSF    03.5
03B2:  MOVF   1E,W
03B3:  BCF    03.5
03B4:  MOVWF  52
03B5:  MOVF   1E,W
03B6:  MOVWF  53
....................        
....................       set_adc_channel(Athrottle_channel); 
03B7:  MOVLW  00
03B8:  MOVWF  21
03B9:  MOVF   1F,W
03BA:  ANDLW  C7
03BB:  IORWF  21,W
03BC:  MOVWF  1F
....................       ADC_DELAY; 
03BD:  MOVLW  21
03BE:  MOVWF  20
03BF:  DECFSZ 20,F
03C0:  GOTO   3BF
....................       Athrottle = read_adc(); 
03C1:  BSF    1F.2
03C2:  BTFSC  1F.2
03C3:  GOTO   3C2
03C4:  BSF    03.5
03C5:  MOVF   1E,W
03C6:  BCF    03.5
03C7:  MOVWF  50
03C8:  MOVF   1E,W
03C9:  MOVWF  51
=======
028F:  MOVLW  08
0290:  MOVWF  21
0291:  MOVF   1F,W
0292:  ANDLW  C7
0293:  IORWF  21,W
0294:  MOVWF  1F
....................       ADC_DELAY; 
0295:  MOVLW  21
0296:  MOVWF  20
0297:  DECFSZ 20,F
0298:  GOTO   297
....................       Acaps = read_adc(); 
0299:  BSF    1F.2
029A:  BTFSC  1F.2
029B:  GOTO   29A
029C:  BSF    03.5
029D:  MOVF   1E,W
029E:  BCF    03.5
029F:  MOVWF  57
02A0:  MOVF   1E,W
02A1:  MOVWF  58
....................        
....................       set_adc_channel(Athrottle_channel); 
02A2:  MOVLW  00
02A3:  MOVWF  21
02A4:  MOVF   1F,W
02A5:  ANDLW  C7
02A6:  IORWF  21,W
02A7:  MOVWF  1F
....................       ADC_DELAY; 
02A8:  MOVLW  21
02A9:  MOVWF  20
02AA:  DECFSZ 20,F
02AB:  GOTO   2AA
....................       Athrottle = read_adc(); 
02AC:  BSF    1F.2
02AD:  BTFSC  1F.2
02AE:  GOTO   2AD
02AF:  BSF    03.5
02B0:  MOVF   1E,W
02B1:  BCF    03.5
02B2:  MOVWF  55
02B3:  MOVF   1E,W
02B4:  MOVWF  56
>>>>>>> Addng brake switch
....................  
....................       //CONTROL BOX 
....................  
....................        
<<<<<<< HEAD
....................       //current_servo_position=left_position+((Athrottle-Athrottle_Min)/Athrottle_Full)*servo_difference;//(vSpeed/65536.0)*(2500); 
....................       if (Athrottle<Athrottle_Min){ 
03CA:  MOVF   51,W
03CB:  SUBLW  01
03CC:  BTFSS  03.0
03CD:  GOTO   3D8
03CE:  BTFSS  03.2
03CF:  GOTO   3D4
03D0:  MOVF   50,W
03D1:  SUBLW  31
03D2:  BTFSS  03.0
03D3:  GOTO   3D8
....................          Athrottle=Athrottle_Min; 
03D4:  MOVLW  01
03D5:  MOVWF  51
03D6:  MOVLW  32
03D7:  MOVWF  50
....................       } 
....................       //current_servo_position=right_position-(Athrottle-Athrottle_Min)*Athrottle_servo_factor;//(Athrottle/Athrottle_Full)*servo_difference;//(vSpeed/65536.0)*(2500); 
=======
....................       //current_servo_position=left_position+(Athrottle/1024.0)*2500;//(vSpeed/65536.0)*(2500); 
>>>>>>> Addng brake switch
....................       //printf("Analog Cap %d Analog Throttle %d\n",(int) Acaps, (int) Athrottle); 
....................       current_servo_position =right_position-vSpeed+200; 
03D8:  MOVF   4A,W
03D9:  SUBLW  C0
03DA:  MOVWF  54
03DB:  MOVLW  12
03DC:  MOVWF  55
03DD:  MOVF   4B,W
03DE:  BTFSS  03.0
03DF:  INCFSZ 4B,W
03E0:  SUBWF  55,F
03E1:  MOVLW  C8
03E2:  ADDWF  54,W
03E3:  MOVWF  42
03E4:  MOVF   55,W
03E5:  MOVWF  43
03E6:  BTFSC  03.0
03E7:  INCF   43,F
....................     
....................       //SET OUTPUTS  
....................       //The writing of the ICEThrottle happens in interupts and all that is 
....................       //required is updating ICEthrottle 
....................        
<<<<<<< HEAD
....................       write_dac((right_position-(right_position-(Athrottle-Athrottle_Min)*Athrottle_servo_factor))*4); 
03E8:  MOVLW  32
03E9:  SUBWF  50,W
03EA:  MOVWF  54
03EB:  MOVF   51,W
03EC:  MOVWF  55
03ED:  MOVLW  01
03EE:  BTFSS  03.0
03EF:  MOVLW  02
03F0:  SUBWF  55,F
03F1:  MOVF   55,W
03F2:  MOVWF  57
03F3:  MOVF   54,W
03F4:  MOVWF  56
03F5:  GOTO   137
03F6:  MOVF   23,W
03F7:  MOVWF  5D
03F8:  MOVF   22,W
03F9:  MOVWF  5C
03FA:  MOVF   21,W
03FB:  MOVWF  5B
03FC:  MOVF   20,W
03FD:  MOVWF  5A
03FE:  MOVLW  74
03FF:  MOVWF  61
0400:  MOVLW  48
0401:  MOVWF  60
0402:  MOVLW  4D
0403:  MOVWF  5F
0404:  MOVLW  7F
0405:  MOVWF  5E
0406:  CALL   155
0407:  BSF    03.1
0408:  CLRF   59
0409:  CLRF   58
040A:  MOVLW  16
040B:  MOVWF  57
040C:  MOVLW  8B
040D:  MOVWF  56
040E:  MOVF   23,W
040F:  MOVWF  5D
0410:  MOVF   22,W
0411:  MOVWF  5C
0412:  MOVF   21,W
0413:  MOVWF  5B
0414:  MOVF   20,W
0415:  MOVWF  5A
0416:  CALL   1CA
0417:  BSF    03.1
0418:  CLRF   59
0419:  CLRF   58
041A:  MOVLW  16
041B:  MOVWF  57
041C:  MOVLW  8B
041D:  MOVWF  56
041E:  MOVF   23,W
041F:  MOVWF  5D
0420:  MOVF   22,W
0421:  MOVWF  5C
0422:  MOVF   21,W
0423:  MOVWF  5B
0424:  MOVF   20,W
0425:  MOVWF  5A
0426:  CALL   1CA
0427:  MOVF   20,W
0428:  MOVWF  56
0429:  MOVF   21,W
042A:  MOVWF  57
042B:  MOVF   22,W
042C:  MOVWF  58
042D:  MOVF   23,W
042E:  MOVWF  59
042F:  MOVWF  5D
0430:  MOVF   22,W
0431:  MOVWF  5C
0432:  MOVF   21,W
0433:  MOVWF  5B
0434:  MOVF   20,W
0435:  MOVWF  5A
0436:  CLRF   61
0437:  CLRF   60
0438:  CLRF   5F
0439:  MOVLW  81
043A:  MOVWF  5E
043B:  CALL   155
043C:  MOVF   23,W
043D:  MOVWF  5D
043E:  MOVF   22,W
043F:  MOVWF  5C
0440:  MOVF   21,W
0441:  MOVWF  5B
0442:  MOVF   20,W
0443:  MOVWF  5A
0444:  GOTO   308
0445:  MOVF   22,W
0446:  MOVWF  5B
0447:  MOVF   21,W
0448:  MOVWF  5A
0449:  MOVF   22,W
044A:  MOVWF  5D
044B:  MOVF   21,W
044C:  MOVWF  5C
044D:  CALL   0C7
....................       //write_dac((right_position-current_servo_position)*4); 
....................    } 
044E:  GOTO   3A4
=======
....................       write_dac(current_servo_position*4); 
02B5:  RLF    48,W
02B6:  MOVWF  59
02B7:  RLF    49,W
02B8:  MOVWF  5A
02B9:  RLF    59,F
02BA:  RLF    5A,F
02BB:  MOVLW  FC
02BC:  ANDWF  59,F
02BD:  MOVF   5A,W
02BE:  MOVWF  5C
02BF:  MOVF   59,W
02C0:  MOVWF  5B
02C1:  GOTO   1AE
....................    } 
02C2:  GOTO   28F
>>>>>>> Addng brake switch
....................     
....................  
.................... } 
....................  
.................... /*! \brief Initialisation of PID controller parameters. 
....................  * 
....................  *  Initialise the variables used by the PID algorithm. 
....................  * 
....................  *  \param p_factor  Proportional term. 
....................  *  \param i_factor  Integral term. 
....................  *  \param d_factor  Derivate term. 
....................  *  \param pid  Struct with PID status. 
....................  */ 
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid) 
.................... // Set up PID controller parameters 
<<<<<<< HEAD
044F:  GOTO   44F
.................... { 
....................   // Start values for PID controller 
....................   pid->sumError = 0; 
....................   pid->lastProcessValue = 0; 
....................   // Tuning constants for PID loop 
....................   pid->P_Factor = p_factor; 
....................   pid->I_Factor = i_factor; 
....................   pid->D_Factor = d_factor; 
....................   // Limits to avoid overflow 
....................   pid->maxError = MAX_INT / (pid->P_Factor + 1); 
....................   pid->maxSumError = MAX_I_TERM / (pid->I_Factor + 1); 
.................... } 
=======
02C3:  GOTO   2C3
.................... { 
....................   // Start values for PID controller 
....................   pid->sumError = 0; 
*
00BF:  MOVLW  02
00C0:  ADDWF  5F,W
00C1:  MOVWF  04
00C2:  INCF   04,F
00C3:  INCF   04,F
00C4:  INCF   04,F
00C5:  CLRF   00
00C6:  DECF   04,F
00C7:  CLRF   00
00C8:  DECF   04,F
00C9:  CLRF   00
00CA:  DECF   04,F
00CB:  CLRF   00
....................   pid->lastProcessValue = 0; 
00CC:  MOVF   5F,W
00CD:  MOVWF  04
00CE:  INCF   04,F
00CF:  CLRF   00
00D0:  DECF   04,F
00D1:  CLRF   00
....................   // Tuning constants for PID loop 
....................   pid->P_Factor = p_factor; 
00D2:  MOVLW  06
00D3:  ADDWF  5F,W
00D4:  MOVWF  04
00D5:  INCF   04,F
00D6:  MOVF   5A,W
00D7:  MOVWF  00
00D8:  DECF   04,F
00D9:  MOVF   59,W
00DA:  MOVWF  00
....................   pid->I_Factor = i_factor; 
00DB:  MOVLW  08
00DC:  ADDWF  5F,W
00DD:  MOVWF  04
00DE:  INCF   04,F
00DF:  MOVF   5C,W
00E0:  MOVWF  00
00E1:  DECF   04,F
00E2:  MOVF   5B,W
00E3:  MOVWF  00
....................   pid->D_Factor = d_factor; 
00E4:  MOVLW  0A
00E5:  ADDWF  5F,W
00E6:  MOVWF  04
00E7:  INCF   04,F
00E8:  MOVF   5E,W
00E9:  MOVWF  00
00EA:  DECF   04,F
00EB:  MOVF   5D,W
00EC:  MOVWF  00
....................   // Limits to avoid overflow 
....................   pid->maxError = MAX_INT / (pid->P_Factor + 1); 
00ED:  MOVLW  0C
00EE:  ADDWF  5F,W
00EF:  MOVWF  60
00F0:  MOVLW  06
00F1:  ADDWF  5F,W
00F2:  MOVWF  04
00F3:  INCF   04,F
00F4:  MOVF   00,W
00F5:  MOVWF  62
00F6:  DECF   04,F
00F7:  MOVF   00,W
00F8:  MOVWF  61
00F9:  MOVLW  01
00FA:  ADDWF  61,W
00FB:  MOVWF  21
00FC:  MOVF   62,W
00FD:  MOVWF  23
00FE:  BTFSC  03.0
00FF:  INCF   23,F
0100:  MOVF   21,W
0101:  MOVWF  63
0102:  MOVF   23,W
0103:  MOVWF  64
0104:  MOVLW  7F
0105:  MOVWF  66
0106:  MOVLW  FF
0107:  MOVWF  65
0108:  MOVF   64,W
0109:  MOVWF  68
010A:  MOVF   63,W
010B:  MOVWF  67
*
0130:  MOVF   60,W
0131:  MOVWF  04
0132:  INCF   04,F
0133:  MOVF   22,W
0134:  MOVWF  00
0135:  DECF   04,F
0136:  MOVF   21,W
0137:  MOVWF  00
....................   pid->maxSumError = MAX_I_TERM / (pid->I_Factor + 1); 
0138:  MOVLW  0E
0139:  ADDWF  5F,W
013A:  MOVWF  60
013B:  MOVLW  08
013C:  ADDWF  5F,W
013D:  MOVWF  04
013E:  INCF   04,F
013F:  MOVF   00,W
0140:  MOVWF  62
0141:  DECF   04,F
0142:  MOVF   00,W
0143:  MOVWF  61
0144:  MOVLW  01
0145:  ADDWF  61,W
0146:  MOVWF  21
0147:  MOVF   62,W
0148:  MOVWF  23
0149:  BTFSC  03.0
014A:  INCF   23,F
014B:  MOVF   21,W
014C:  MOVWF  63
014D:  MOVF   23,W
014E:  MOVWF  64
014F:  MOVF   04,W
0150:  MOVWF  65
0151:  MOVLW  3F
0152:  MOVWF  69
0153:  MOVLW  FF
0154:  MOVWF  68
0155:  MOVWF  67
0156:  MOVWF  66
0157:  CLRF   6D
0158:  CLRF   6C
0159:  MOVF   64,W
015A:  MOVWF  6B
015B:  MOVF   63,W
015C:  MOVWF  6A
*
019D:  MOVF   65,W
019E:  MOVWF  04
019F:  MOVF   60,W
01A0:  MOVWF  04
01A1:  MOVF   20,W
01A2:  MOVWF  00
01A3:  INCF   04,F
01A4:  MOVF   21,W
01A5:  MOVWF  00
01A6:  INCF   04,F
01A7:  MOVF   22,W
01A8:  MOVWF  00
01A9:  INCF   04,F
01AA:  MOVF   23,W
01AB:  MOVWF  00
.................... } 
01AC:  BCF    0A.3
01AD:  GOTO   28F (RETURN)
>>>>>>> Addng brake switch
....................  
....................  
.................... /*! \brief PID control algorithm. 
....................  * 
....................  *  Calculates output from setpoint, process value and PID status. 
....................  * 
....................  *  \param setPoint  Desired value. 
....................  *  \param processValue  Measured value. 
....................  *  \param pid_st  PID status struct. 
....................  */ 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st) 
.................... { 
....................   int16 error, p_term, d_term; 
....................   int32 i_term, ret, temp; 
....................  
....................   error = setPoint - processValue; 
....................  
....................   // Calculate Pterm and limit error overflow 
....................   if (error > pid_st->maxError){ 
....................     p_term = MAX_INT; 
....................   } 
....................   else if (error < -pid_st->maxError){ 
....................     p_term = -MAX_INT; 
....................   } 
....................   else{ 
....................     p_term = pid_st->P_Factor * error; 
....................   } 
....................  
....................   // Calculate Iterm and limit integral runaway 
....................   temp = pid_st->sumError + error; 
....................   if(temp > pid_st->maxSumError){ 
....................     i_term = MAX_I_TERM; 
....................     pid_st->sumError = pid_st->maxSumError; 
....................   } 
....................   else if(temp < -pid_st->maxSumError){ 
....................     i_term = -MAX_I_TERM; 
....................     pid_st->sumError = -pid_st->maxSumError; 
....................   } 
....................   else{ 
....................     pid_st->sumError = temp; 
....................     i_term = pid_st->I_Factor * pid_st->sumError; 
....................   } 
....................  
....................   // Calculate Dterm 
....................   d_term = pid_st->D_Factor * (pid_st->lastProcessValue - processValue); 
....................  
....................   pid_st->lastProcessValue = processValue; 
....................  
....................   ret = (p_term + i_term + d_term) / SCALING_FACTOR; 
....................   if(ret > MAX_INT){ 
....................     ret = MAX_INT; 
....................   } 
....................   else if(ret < -MAX_INT){ 
....................     ret = -MAX_INT; 
....................   } 
....................  
....................   return((int16)ret); 
.................... } 
....................  
.................... /*! \brief Resets the integrator. 
....................  * 
....................  *  Calling this function will reset the integrator in the PID regulator. 
....................  */ 
.................... void pid_Reset_Integrator(pidData_t *pid_st) 
.................... { 
....................   pid_st->sumError = 0; 
.................... } 
....................  
....................  
.................... void pid_element_controller(){ 
.................... } 
....................  

Configuration Fuses:
   Word  1: 373A   HS NOWDT NOPUT DEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
