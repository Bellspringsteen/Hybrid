CCS PCM C Compiler, Version 4.084, 46530               11-May-13 12:38

               Filename: HondaHybrid.lst

               ROM used: 1028 words (27%)
                         Largest free fragment is 1788
               RAM used: 61 (34%) at main() level
                         83 (46%) worst case
               Stack:    4 worst case (3 in main + 1 for interrupts)

*
0000:  NOP
0001:  MOVLW  00
0002:  MOVWF  0A
0003:  GOTO   30A
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  26
0008:  MOVF   7F,W
0009:  MOVWF  25
000A:  MOVF   0A,W
000B:  MOVWF  2D
000C:  CLRF   0A
000D:  SWAPF  25,F
000E:  MOVF   04,W
000F:  MOVWF  27
0010:  MOVF   20,W
0011:  MOVWF  28
0012:  MOVF   21,W
0013:  MOVWF  29
0014:  MOVF   22,W
0015:  MOVWF  2A
0016:  MOVF   23,W
0017:  MOVWF  2B
0018:  MOVF   24,W
0019:  MOVWF  2C
001A:  BCF    03.7
001B:  BCF    03.5
001C:  MOVLW  8C
001D:  MOVWF  04
001E:  BTFSS  00.0
001F:  GOTO   022
0020:  BTFSC  0C.0
0021:  GOTO   03F
0022:  MOVLW  8D
0023:  MOVWF  04
0024:  BTFSS  00.0
0025:  GOTO   028
0026:  BTFSC  0D.0
0027:  GOTO   041
0028:  BTFSS  0B.5
0029:  GOTO   02C
002A:  BTFSC  0B.2
002B:  GOTO   043
002C:  MOVF   27,W
002D:  MOVWF  04
002E:  MOVF   28,W
002F:  MOVWF  20
0030:  MOVF   29,W
0031:  MOVWF  21
0032:  MOVF   2A,W
0033:  MOVWF  22
0034:  MOVF   2B,W
0035:  MOVWF  23
0036:  MOVF   2C,W
0037:  MOVWF  24
0038:  MOVF   2D,W
0039:  MOVWF  0A
003A:  SWAPF  26,W
003B:  MOVWF  03
003C:  SWAPF  7F,F
003D:  SWAPF  7F,W
003E:  RETFIE
003F:  BCF    0A.3
0040:  GOTO   086
0041:  BCF    0A.3
0042:  GOTO   089
0043:  BCF    0A.3
0044:  GOTO   077
.................... #include "HondaHybrid.h" 
.................... #include <16F873A.h> 
.................... //////// Standard Header file for the PIC16F873A device //////////////// 
.................... #device PIC16F873A 
.................... #list 
....................  
....................  
.................... //#include <16F737.h> 
.................... #device ICD=TRUE 
.................... #device adc=10 
.................... //#device adc=8 
.................... #use delay(clock=20000000) 
*
02E9:  MOVLW  59
02EA:  MOVWF  04
02EB:  MOVF   00,W
02EC:  BTFSC  03.2
02ED:  GOTO   2FB
02EE:  MOVLW  06
02EF:  MOVWF  21
02F0:  CLRF   20
02F1:  DECFSZ 20,F
02F2:  GOTO   2F1
02F3:  DECFSZ 21,F
02F4:  GOTO   2F0
02F5:  MOVLW  7B
02F6:  MOVWF  20
02F7:  DECFSZ 20,F
02F8:  GOTO   2F7
02F9:  DECFSZ 00,F
02FA:  GOTO   2EE
02FB:  RETLW  00
.................... #fuses HS,PUT,NOWDT 
.................... #use rs232 (DEBUGGER) 
*
0111:  BSF    03.5
0112:  BCF    06.3
0113:  BCF    03.5
0114:  BCF    06.3
0115:  MOVLW  08
0116:  MOVWF  21
0117:  GOTO   118
0118:  NOP
0119:  BSF    21.7
011A:  GOTO   129
011B:  BCF    21.7
011C:  RRF    6E,F
011D:  BTFSC  03.0
011E:  BSF    06.3
011F:  BTFSS  03.0
0120:  BCF    06.3
0121:  BSF    21.6
0122:  GOTO   129
0123:  BCF    21.6
0124:  DECFSZ 21,F
0125:  GOTO   11C
0126:  GOTO   127
0127:  NOP
0128:  BSF    06.3
0129:  MOVLW  02
012A:  MOVWF  20
012B:  CLRF   04
012C:  DECFSZ 04,F
012D:  GOTO   12C
012E:  DECFSZ 20,F
012F:  GOTO   12B
0130:  MOVLW  AD
0131:  MOVWF  04
0132:  DECFSZ 04,F
0133:  GOTO   132
0134:  GOTO   135
0135:  NOP
0136:  BTFSC  21.7
0137:  GOTO   11B
0138:  BTFSC  21.6
0139:  GOTO   123
013A:  RETLW  00
.................... #include <mcp4921.c> 
.................... //////////////// Driver for MCP4921 D/A Converter /////////////////////// 
.................... ////                                                                 //// 
.................... ////  init_dac()    Call this before using a MCP4921 DAC             //// 
.................... ////                                                                 //// 
.................... ////  write_dac( long int )   Writes command and 12 bit resolution   //// 
.................... ////                          to the MCP4921 which converts it to a  //// 
.................... ////                          voltage                                //// 
.................... ////                          0-4095 input represents 0-vref V out.  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SELECT 
....................  
.................... #define DAC_CS     PIN_C4 
.................... #define DAC_CLK    PIN_C3 
.................... #define DAC_DI     PIN_C5 
.................... #define DAC_LDAC   PIN_B5 
....................  
.................... #endif 
....................  
.................... void init_dac() 
.................... { 
....................    output_high(DAC_CS); 
*
009D:  BCF    2E.4
009E:  MOVF   2E,W
009F:  BSF    03.5
00A0:  MOVWF  07
00A1:  BCF    03.5
00A2:  BSF    07.4
....................    output_high(DAC_LDAC); 
00A3:  BSF    03.5
00A4:  BCF    06.5
00A5:  BCF    03.5
00A6:  BSF    06.5
....................    output_high(DAC_CLK); 
00A7:  BCF    2E.3
00A8:  MOVF   2E,W
00A9:  BSF    03.5
00AA:  MOVWF  07
00AB:  BCF    03.5
00AC:  BSF    07.3
....................    output_high(DAC_DI); 
00AD:  BCF    2E.5
00AE:  MOVF   2E,W
00AF:  BSF    03.5
00B0:  MOVWF  07
00B1:  BCF    03.5
00B2:  BSF    07.5
.................... } 
00B3:  BCF    0A.3
00B4:  GOTO   35B (RETURN)
....................  
.................... void write_dac(int16 data) { 
....................    BYTE cmd[3]; 
....................    BYTE i; 
....................  
....................    cmd[0]=data; 
00B5:  MOVF   5C,W
00B6:  MOVWF  5E
....................    cmd[1]=(data>>8); 
00B7:  MOVF   5D,W
00B8:  MOVWF  5F
....................    cmd[2]=0x03;                            
00B9:  MOVLW  03
00BA:  MOVWF  60
....................     
....................    output_high(DAC_LDAC); 
00BB:  BSF    03.5
00BC:  BCF    06.5
00BD:  BCF    03.5
00BE:  BSF    06.5
....................    output_low(DAC_CLK); 
00BF:  BCF    2E.3
00C0:  MOVF   2E,W
00C1:  BSF    03.5
00C2:  MOVWF  07
00C3:  BCF    03.5
00C4:  BCF    07.3
....................    output_low(DAC_CS); 
00C5:  BCF    2E.4
00C6:  MOVF   2E,W
00C7:  BSF    03.5
00C8:  MOVWF  07
00C9:  BCF    03.5
00CA:  BCF    07.4
....................  
....................    for(i=0; i<=23; ++i) 
00CB:  CLRF   61
00CC:  MOVF   61,W
00CD:  SUBLW  17
00CE:  BTFSS  03.0
00CF:  GOTO   0FD
....................    { 
....................       if(i<4 || (i>7 && i<12)) 
00D0:  MOVF   61,W
00D1:  SUBLW  03
00D2:  BTFSC  03.0
00D3:  GOTO   0DC
00D4:  MOVF   61,W
00D5:  SUBLW  07
00D6:  BTFSC  03.0
00D7:  GOTO   0E1
00D8:  MOVF   61,W
00D9:  SUBLW  0B
00DA:  BTFSS  03.0
00DB:  GOTO   0E1
....................          shift_left(cmd,3,0); 
00DC:  BCF    03.0
00DD:  RLF    5E,F
00DE:  RLF    5F,F
00DF:  RLF    60,F
....................       else 
00E0:  GOTO   0FB
....................       { 
....................          output_bit(DAC_DI, shift_left(cmd,3,0)); 
00E1:  BCF    03.0
00E2:  RLF    5E,F
00E3:  RLF    5F,F
00E4:  RLF    60,F
00E5:  BTFSC  03.0
00E6:  GOTO   0E9
00E7:  BCF    07.5
00E8:  GOTO   0EA
00E9:  BSF    07.5
00EA:  BCF    2E.5
00EB:  MOVF   2E,W
00EC:  BSF    03.5
00ED:  MOVWF  07
....................  
....................          output_high(DAC_CLK); 
00EE:  BCF    03.5
00EF:  BCF    2E.3
00F0:  MOVF   2E,W
00F1:  BSF    03.5
00F2:  MOVWF  07
00F3:  BCF    03.5
00F4:  BSF    07.3
....................          output_low(DAC_CLK); 
00F5:  BCF    2E.3
00F6:  MOVF   2E,W
00F7:  BSF    03.5
00F8:  MOVWF  07
00F9:  BCF    03.5
00FA:  BCF    07.3
....................       } 
....................    } 
00FB:  INCF   61,F
00FC:  GOTO   0CC
....................    output_high(DAC_CS); 
00FD:  BCF    2E.4
00FE:  MOVF   2E,W
00FF:  BSF    03.5
0100:  MOVWF  07
0101:  BCF    03.5
0102:  BSF    07.4
....................  
....................    output_low(DAC_LDAC); 
0103:  BSF    03.5
0104:  BCF    06.5
0105:  BCF    03.5
0106:  BCF    06.5
....................    delay_us(10); 
0107:  MOVLW  10
0108:  MOVWF  20
0109:  DECFSZ 20,F
010A:  GOTO   109
010B:  NOP
....................     
....................    output_HIGH(DAC_LDAC); 
010C:  BSF    03.5
010D:  BCF    06.5
010E:  BCF    03.5
010F:  BSF    06.5
.................... } 
0110:  RETLW  00
....................  
....................  
....................  
.................... #include "pid.h" 
.................... /*This file has been prepared for Doxygen automatic documentation generation.*/ 
.................... /*! \file ********************************************************************* 
....................  * 
....................  * \brief Header file for pid.c. 
....................  * 
....................  * - File:               pid.h 
....................  * - Compiler:           IAR EWAAVR 4.11A 
....................  * - Supported devices:  All AVR devices can be used. 
....................  * - AppNote:            AVR221 - Discrete PID controller 
....................  * 
....................  * \author               Atmel Corporation: http://www.atmel.com \n 
....................  *                       Support email: avr@atmel.com 
....................  * 
....................  * $Name$ 
....................  * $Revision: 456 $ 
....................  * $RCSfile$ 
....................  * $Date: 2006-02-16 12:46:13 +0100 (to, 16 feb 2006) $ 
....................  *****************************************************************************/ 
....................  
.................... #ifndef PID_H 
.................... #define PID_H 
....................  
.................... //#include "stdint.h" 
.................... #define INT16_MAX 32767 
.................... #define INT32_MAX 2147483647 
.................... #define SCALING_FACTOR  128 
....................  
.................... /*! \brief PID Status 
....................  * 
....................  * Setpoints and data used by the PID control algorithm 
....................  */ 
.................... typedef struct PID_DATA{ 
....................   //! Last process value, used to find derivative of process value. 
....................   int16 lastProcessValue; 
....................   //! Summation of errors, used for integrate calculations 
....................   int32 sumError; 
....................   //! The Proportional tuning constant, multiplied with SCALING_FACTOR 
....................   int16 P_Factor; 
....................   //! The Integral tuning constant, multiplied with SCALING_FACTOR 
....................   int16 I_Factor; 
....................   //! The Derivative tuning constant, multiplied with SCALING_FACTOR 
....................   int16 D_Factor; 
....................   //! Maximum allowed error, avoid overflow 
....................   int16 maxError; 
....................   //! Maximum allowed sumerror, avoid overflow 
....................   int32 maxSumError; 
.................... } pidData_t; 
....................  
.................... /*! \brief Maximum values 
....................  * 
....................  * Needed to avoid sign/overflow problems 
....................  */ 
.................... // Maximum value of variables 
.................... #define MAX_INT         INT16_MAX 
.................... #define MAX_LONG        INT32_MAX 
.................... #define MAX_I_TERM      (MAX_LONG / 2) 
....................  
.................... // Boolean values 
.................... //#define FALSE           0 
.................... //#define TRUE            1 
....................  
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid); 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st); 
.................... void pid_Reset_Integrator(pidData_t *pid_st); 
....................  
.................... #endif 
....................  
.................... /* 
.................... This is the main controller for the super capacitor hybrid scooter a.k.a RED 
.................... B2 close contactor 
.................... CONTROL BOX INPUTS 
.................... Athrottle- A0 - analog input representing the users input for speed, 10 bit 
.................... Vspeed - CCp2-a 16 bit representation of the speed of the vehicle 
.................... Acaps- A1 - analog input representing the current voltage of the supercapacitors, 10 bit 
....................  
.................... CONTROL BOX OUTPUT 
.................... ICEthrottle- B1 - a 16 bit number sent to the internal combustion engine(ICE) throttle  
.................... ELECthrottle-  - a 16 bit number sent as analog value representing the demanded electric power 
....................  
.................... SPECIFICS OF I/O 
....................  
.................... Athrottle - the electric throttle is a 3 wire unit with a 5 volt,ground, and analog out 
....................    representing how far throttle is turned. Pin AN0 is the input. 
....................     
.................... Vspeed - There is a encoder in the rear wheel/electric motor that is used by the electric 
....................    power controller. Tapping in to this this Main Controller receives a 5 Volt square wave 
....................    with 42 pulses. There are two options for measuring speed. The first is to measure the  
....................    length of the pulses. The second is to measure the rate of pulses. This controller currently 
....................    uses the rate method. The int_ccp2 interupt is called on each falling edge and stores the  
....................    Vspeed value as the max number of 16bit (65535-timer0_since_last_reset).  
....................     
....................    The RED scooter has a circumpherence of 16.3*2*pi = 102.4 
....................    X m/h * 63360 inch/mile * 1/3600 h/sec * 1/(102.4 inch/rev) = .171875* X 
....................    Examples 50 mph is 8.9 ms 1 overflow of timer0 
....................    Example 5 mph is 89 ms or 13 time overflow 
....................     
....................    #int_timer0 increments the counter number_of_overflows each time it overflows 
....................    On int ccp2 we multiply number_of_overflows * 256 + timer0 to get timer0_since_last_reset 
....................     
.................... Acaps - the analog voltage which is the 5volt representation of the voltage in the caps which 
....................    have a value of between 0-48v. The voltages are factored so that the voltage on AN1 goes 
....................    from 0 - 4.8 volts (TODO check this factor, think its 1/11 not 1/10) 
....................     
.................... ICEthrottle -  #int_timer1 is set to make sure the period follows the required below 
....................    The period for the servo is .020 seconds which is 50,000 operations 
....................    The leftmost position of the server is .001 seconds which is 2,500 
....................    The rightmost position of the server is .002 seconds which is 5,000 
....................     
....................    The output pin is pin_B1.-> 
....................  
.................... ELECthrottle 
....................    The electric power controller takes an analog voltage as input. The output voltage 
....................    is set by the DAC. The pins used are C3,C4,C5. if CHARGING_STATE is true then  
....................     
.................... ALGORITHM 
....................    The algorithm is basically a PID controller. In broad terms we are trying to set the 
....................    ICEthrottle and ICEelectric to maximize the use of electric and accelerate to meet the 
....................    requirements set by the rider with the Athrottle signal. When the demanded power is  
....................    less than the power output possible by the ICE and the caps are in the CHARGING_STATE  
....................    then the ICE is turned up to the max and the ELECthrottle is set to regen to 
....................    charge the capacitors.If CHARGING_STATE is false then the caps are supplying the drivig power 
....................    and the ICE is set to "off", the caps supply the power. Unless the user requested supply 
....................    is enough to require both power sources. 
....................     
....................    If CHARGING_STATE is true. Then pin_b2 is set as high which will close the brake number 
....................    for the electric power controller.  
....................     
....................    If CHARGING_STATE is false then the pin_b2 is set low which opens brake. 
....................     
....................     
....................  
....................  
.................... The encoder has 42 on and offs per rotation, i.e. 21 steps 
....................  
.................... Number of operations per second is CLOCK/4/Timer Divisions 
.................... Number of operations per second is 20,000,000/4/128 = 39062.5  
.................... Each operation takes 1/39062.5 = .256 micro (x10^-6) seconds 
.................... Seconds to Overflow timer0 8bit timer = .256x10^-6 * 256 = 6.55ms 
....................  
....................  
....................  
.................... */ 
.................... #define servo_pin PIN_B1  //Setting servo out pin to be hardware pin b1 
.................... #define brake_pin PIN_B4 
.................... #define ADC_DELAY delay_us(20) 
.................... #define Acaps_pin PIN_A1 
.................... #define Acaps_channel 1 
.................... #define Athrottle_pin PIN_A0  //Voltage goes from 1.5 (306)to 4.1(836) 
.................... #define Athrottle_Min 316 
.................... #define Athrottle_Max 860 
.................... #define Athrottle_Full Athrottle_Max-Athrottle_Min 
.................... #define Athrottle_channel 0 
.................... #define Electric_Controller_Switch PIN_B0 
.................... #define Contactor_Switch PIN_B2 
....................  
.................... //PID Values 
.................... #define K_P 1.00 
.................... #define K_I 0.00 
.................... #define K_D 0.00 
....................  
.................... int1 pid_Timer = 0; 
*
031B:  BCF    2F.0
.................... struct PID_DATA pidData; 
.................... #define TIME_INTERVAL 157 //TODO replace 
....................  
.................... #define left_position 4450 
.................... #define right_position 5300 
.................... #define servo_difference  right_position-left_position 
.................... #define ELEC_CONTROLLER_OFFSET 900 
.................... const float Athrottle_servo_factor = ((float) servo_difference)/((float) Athrottle_FULL); 
.................... #define servo_period   65356-50000 
.................... unsigned int16 current_servo_position=right_position; 
031C:  MOVLW  B4
031D:  MOVWF  42
031E:  MOVLW  14
031F:  MOVWF  43
.................... int1 SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0; 
0320:  BCF    2F.1
.................... int1 test_boolean = 0; 
0321:  BCF    2F.2
....................  
.................... int1 test_switch = 0; 
0322:  BCF    2F.3
.................... unsigned int16 test_counter = 0; 
0323:  CLRF   44
0324:  CLRF   45
.................... //int16 returnedValue = 0; 
....................  
.................... unsigned int16 number_of_timer0_interupts_since_reset =0; 
0325:  CLRF   46
0326:  CLRF   47
.................... unsigned int16 timer0_since_last_reset= 0; 
0327:  CLRF   48
0328:  CLRF   49
.................... unsigned int16 vSpeed= 0; 
0329:  CLRF   4A
032A:  CLRF   4B
.................... signed int16 ELECthrottle = 0; 
032B:  CLRF   4C
032C:  CLRF   4D
.................... unsigned int16 ICEthrottle = 0; 
032D:  CLRF   4E
032E:  CLRF   4F
.................... unsigned int16 Athrottle = 0; 
032F:  CLRF   50
0330:  CLRF   51
.................... unsigned int16 Acaps = 0; 
0331:  CLRF   52
0332:  CLRF   53
.................... int1 CURRENTLY_CHARGING = 0; 
0333:  BCF    2F.4
.................... signed int16 returnedValue =0; 
0334:  CLRF   54
0335:  CLRF   55
.................... int16 speeder = 0;  
0336:  CLRF   56
0337:  CLRF   57
.................... /* 
.................... The #int_timer0 interupt is triggered on each timer0 8bit interupt 
.................... the function simply increments a overflow counter to be used by the ccp2 
.................... interupt to calculate speed 
.................... NUMBER OF OPERATIONS =  
.................... */ 
.................... #int_timer0 
.................... void timer0_isr(){ 
....................     
....................       number_of_timer0_interupts_since_reset=number_of_timer0_interupts_since_reset+256; 
*
0077:  MOVLW  01
0078:  ADDWF  47,F
....................       //current_servo_position=current_servo_position+1; 
....................        
....................     
....................    if (number_of_timer0_interupts_since_reset>=1024){ 
0079:  MOVF   47,W
007A:  SUBLW  03
007B:  BTFSC  03.0
007C:  GOTO   083
....................       vSpeed = 1280; 
007D:  MOVLW  05
007E:  MOVWF  4B
007F:  CLRF   4A
....................       number_of_timer0_interupts_since_reset=1024; 
0080:  MOVLW  04
0081:  MOVWF  47
0082:  CLRF   46
....................        
....................        
....................    } 
.................... } 
....................  
.................... /* 
.................... #int_timer1 is used by the ICEservo throttle to regulate the timing pulses. The  
.................... timer is setup for a pulsetrain of 20ms period. This is done as follows, 
....................  
.................... Period is 1/(CLOCK/4opsperclock)*(startingPostionOfClock) = 20 ms 
.................... for this setup 1/(20000000/4)*(50000) = 20 ms 
....................  
.................... The timer1 starts at 0 and counts up. So we set the beggining of the clock at 
.................... servo_period which is 65356-50000 so that the total time is 20ms. 
.................... */ 
0083:  BCF    0B.2
0084:  BCF    0A.3
0085:  GOTO   02C
.................... #int_timer1 
.................... void isr() 
.................... { 
.................... /* 
.................... //Make sure that the position is within the left and right positions of the servo 
....................    if (current_servo_position<left_position){ 
....................       current_servo_position = left_position; 
....................    } 
....................    else if (current_servo_position > right_position){ 
....................       current_servo_position = right_position; 
....................    } 
....................  
....................    if(SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER) 
....................       {  
....................          output_high(servo_pin);        //Set the servo control pin to high  
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0;  
....................          set_timer1(65356-current_servo_position); //Set timer for the position high pulse 
....................       }  
....................    else  
....................       {  
....................          output_low(servo_pin);                      // Set the servo control pin to low   
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 1;  
....................          set_timer1(servo_period+current_servo_position);          //Set timer for the low position the length is the difference between  
....................                                                      //the total int16 lenght - high pulse length 
....................       }   
.................... */ 
.................... } 
....................  
....................  
.................... /* 
.................... #int_ccp2 is called on the falling edge of the encoder pulse. We calculate the time 
.................... between pulses.  
.................... TODO will have to put some kind of smoothing mechanism 
.................... */ 
0086:  BCF    0C.0
0087:  BCF    0A.3
0088:  GOTO   02C
.................... #int_ccp2 
.................... void isr2() 
.................... { 
.................... if (number_of_timer0_interupts_since_reset>10){ 
0089:  MOVF   47,F
008A:  BTFSS  03.2
008B:  GOTO   090
008C:  MOVF   46,W
008D:  SUBLW  0A
008E:  BTFSC  03.0
008F:  GOTO   09A
.................... vSpeed  = (number_of_timer0_interupts_since_reset+get_timer0()); 
0090:  MOVF   01,W
0091:  ADDWF  46,W
0092:  MOVWF  4A
0093:  MOVF   47,W
0094:  MOVWF  4B
0095:  BTFSC  03.0
0096:  INCF   4B,F
.................... //vSpeed  = -(get_timer0()); 
.................... set_timer0(0); 
0097:  CLRF   01
.................... number_of_timer0_interupts_since_reset = 0; 
0098:  CLRF   47
0099:  CLRF   46
.................... } 
.................... } 
....................  
009A:  BCF    0D.0
009B:  BCF    0A.3
009C:  GOTO   02C
.................... void trickBreaking(){ 
.................... write_dac((unsigned int16) 400+ELEC_CONTROLLER_OFFSET); 
*
02FC:  MOVLW  05
02FD:  MOVWF  5D
02FE:  MOVLW  14
02FF:  MOVWF  5C
0300:  CALL   0B5
.................... delay_ms(1000);       
0301:  MOVLW  04
0302:  MOVWF  58
0303:  MOVLW  FA
0304:  MOVWF  59
0305:  CALL   2E9
0306:  DECFSZ 58,F
0307:  GOTO   303
.................... } 
0308:  BCF    0A.3
0309:  GOTO   395 (RETURN)
....................  
.................... void main() 
.................... {   
030A:  CLRF   04
030B:  MOVLW  1F
030C:  ANDWF  03,F
030D:  BSF    03.5
030E:  BCF    06.3
030F:  BCF    03.5
0310:  BSF    06.3
0311:  BSF    03.5
0312:  BSF    1F.0
0313:  BSF    1F.1
0314:  BSF    1F.2
0315:  BCF    1F.3
0316:  MOVLW  07
0317:  MOVWF  1C
....................     
....................    setup_adc_ports(NO_ANALOGS); 
*
0338:  BSF    03.5
0339:  BSF    1F.0
033A:  BSF    1F.1
033B:  BSF    1F.2
033C:  BCF    1F.3
....................    setup_adc(ADC_OFF); 
033D:  BCF    03.5
033E:  BCF    1F.0
....................    setup_spi(FALSE); 
033F:  CLRF   14
....................     
....................    setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
0340:  BSF    03.5
0341:  MOVF   01,W
0342:  ANDLW  C0
0343:  IORLW  00
0344:  MOVWF  01
0345:  CLRWDT
....................    setup_timer_1(T1_DISABLED); 
0346:  BCF    03.5
0347:  CLRF   10
....................    setup_timer_2(T2_DISABLED,0,1); 
0348:  MOVLW  00
0349:  MOVWF  21
034A:  MOVWF  12
034B:  MOVLW  00
034C:  BSF    03.5
034D:  MOVWF  12
....................    setup_port_a(ALL_ANALOG); 
034E:  BCF    1F.0
034F:  BCF    1F.1
0350:  BCF    1F.2
0351:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
0352:  BCF    1F.6
0353:  BCF    03.5
0354:  BSF    1F.6
0355:  BSF    1F.7
0356:  BSF    03.5
0357:  BSF    1F.7
0358:  BCF    03.5
0359:  BSF    1F.0
....................     
....................    init_dac(); 
035A:  GOTO   09D
....................   
....................    setup_timer_1(T1_DIV_BY_2| T1_INTERNAL);  
035B:  MOVLW  95
035C:  MOVWF  10
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_128); 
035D:  BSF    03.5
035E:  MOVF   01,W
035F:  ANDLW  C0
0360:  IORLW  06
0361:  MOVWF  01
....................    setup_ccp2(CCP_CAPTURE_RE);    // Configure CCP2 to capture fall 
0362:  BCF    03.5
0363:  BSF    2E.1
0364:  MOVF   2E,W
0365:  BSF    03.5
0366:  MOVWF  07
0367:  BCF    03.5
0368:  CLRF   1D
0369:  MOVLW  05
036A:  MOVWF  1D
....................    enable_interrupts(INT_CCP2);   // Setup interrupt on falling edge 
036B:  BSF    03.5
036C:  BSF    0D.0
....................    enable_interrupts(INT_TIMER0); 
036D:  BCF    03.5
036E:  BSF    0B.5
....................    enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
036F:  BSF    03.5
0370:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
0371:  MOVLW  C0
0372:  BCF    03.5
0373:  IORWF  0B,F
....................    output_low(Electric_Controller_Switch); 
0374:  BSF    03.5
0375:  BCF    06.0
0376:  BCF    03.5
0377:  BCF    06.0
....................    write_dac(0); 
0378:  CLRF   5D
0379:  CLRF   5C
037A:  CALL   0B5
....................    output_high(Contactor_Switch); 
037B:  BSF    03.5
037C:  BCF    06.2
037D:  BCF    03.5
037E:  BSF    06.2
....................    output_low(brake_pin); 
037F:  BSF    03.5
0380:  BCF    06.4
0381:  BCF    03.5
0382:  BCF    06.4
....................    pid_Init(K_P*SCALING_FACTOR,K_I*SCALING_FACTOR,K_D*SCALING_FACTOR, & pidData); 
0383:  CLRF   59
0384:  MOVLW  80
0385:  MOVWF  58
0386:  CLRF   5B
0387:  CLRF   5A
0388:  CLRF   5D
0389:  CLRF   5C
038A:  MOVLW  30
038B:  MOVWF  5E
038C:  GOTO   1B0
....................     
....................    delay_ms(3000); 
038D:  MOVLW  0C
038E:  MOVWF  58
038F:  MOVLW  FA
0390:  MOVWF  59
0391:  CALL   2E9
0392:  DECFSZ 58,F
0393:  GOTO   38F
....................    //write_dac(1000); 
....................    //delay_ms(10000); 
....................    //output_high(Contactor_Switch); 
....................    //output_high(brake_pin); 
....................    //output_high(Electric_Controller_Switch); 
....................    trickBreaking(); 
0394:  GOTO   2FC
....................    while(TRUE) { 
....................  
....................       //GET INPUTS 
....................       //Vspeedhappens in interrupts 
....................        
....................       set_adc_channel(Acaps_channel); 
0395:  MOVLW  08
0396:  MOVWF  21
0397:  MOVF   1F,W
0398:  ANDLW  C7
0399:  IORWF  21,W
039A:  MOVWF  1F
....................       ADC_DELAY; 
039B:  MOVLW  21
039C:  MOVWF  20
039D:  DECFSZ 20,F
039E:  GOTO   39D
....................       Acaps = read_adc(); 
039F:  BSF    1F.2
03A0:  BTFSC  1F.2
03A1:  GOTO   3A0
03A2:  BSF    03.5
03A3:  MOVF   1E,W
03A4:  BCF    03.5
03A5:  MOVWF  52
03A6:  MOVF   1E,W
03A7:  MOVWF  53
....................        
....................       set_adc_channel(Athrottle_channel); 
03A8:  MOVLW  00
03A9:  MOVWF  21
03AA:  MOVF   1F,W
03AB:  ANDLW  C7
03AC:  IORWF  21,W
03AD:  MOVWF  1F
....................       ADC_DELAY; 
03AE:  MOVLW  21
03AF:  MOVWF  20
03B0:  DECFSZ 20,F
03B1:  GOTO   3B0
....................       Athrottle = read_adc(); 
03B2:  BSF    1F.2
03B3:  BTFSC  1F.2
03B4:  GOTO   3B3
03B5:  BSF    03.5
03B6:  MOVF   1E,W
03B7:  BCF    03.5
03B8:  MOVWF  50
03B9:  MOVF   1E,W
03BA:  MOVWF  51
....................  
....................       //CONTROL BOX 
....................  
....................        
....................       if (Athrottle<Athrottle_Min){ 
03BB:  MOVF   51,W
03BC:  SUBLW  01
03BD:  BTFSS  03.0
03BE:  GOTO   3C9
03BF:  BTFSS  03.2
03C0:  GOTO   3C5
03C1:  MOVF   50,W
03C2:  SUBLW  3B
03C3:  BTFSS  03.0
03C4:  GOTO   3C9
....................          Athrottle=Athrottle_Min; 
03C5:  MOVLW  01
03C6:  MOVWF  51
03C7:  MOVLW  3C
03C8:  MOVWF  50
....................       } 
....................       //Servo to mirror Athrottle ->  
.................... //      current_servo_position=right_position-(Athrottle-Athrottle_Min)*Athrottle_servo_factor;//(Athrottle/Athrottle_Full)*servo_difference;//(vSpeed/65536.0)*(2500); 
....................       //printf("Analog Cap %d Analog Throttle %Lu\n",(int) Acaps,Athrottle); 
....................       //current_servo_position =right_position-vSpeed+200; 
....................       speeder = vSpeed; 
03C9:  MOVF   4B,W
03CA:  MOVWF  57
03CB:  MOVF   4A,W
03CC:  MOVWF  56
....................       //printf("Speed %lu \n",speeder); 
....................       //SET OUTPUTS  
....................       //The writing of the ICEThrottle happens in interupts and all that is 
....................       //required is updating ICEthrottle 
....................       //printf("speed before %ld \n",vSpeed); 
....................        
....................       /* 
....................       returnedValue = pid_Controller((Athrottle-AThrottle_Min),(1280-speeder),& pidData); 
....................       ELECthrottle = ELECthrottle+returnedValue; 
....................       if (ELECthrottle>2500){ 
....................          ELECthrottle=2500; 
....................       } 
....................       else if (ELECthrottle<-300){ 
....................          ELECthrottle = -50; 
....................       } 
....................       if (ELECthrottle<0){ 
....................          //if (CURRENTLY_CHARGING==1){ 
....................          //   trickBreaking(); 
....................          //} 
....................          CURRENTLY_CHARGING=0; 
....................          output_high(brake_pin); 
....................          output_high(Electric_Controller_Switch); 
....................          printf("BREAKING \n"); 
....................       } 
....................       else { 
....................          CURRENTLY_CHARGING=1; 
....................          output_low(brake_pin); 
....................          output_low(Electric_Controller_Switch); 
....................          printf("ACCELERATING \n"); 
....................       } 
....................       printf("input %ld r %lu speed %ld throttle %ld \n",Athrottle-Athrottle_Min,((unsigned int16) returnedValue),1280-speeder,ELECthrottle); 
....................       */ 
....................        
....................       output_high(brake_pin); 
03CD:  BSF    03.5
03CE:  BCF    06.4
03CF:  BCF    03.5
03D0:  BSF    06.4
....................       output_high(Electric_Controller_Switch); 
03D1:  BSF    03.5
03D2:  BCF    06.0
03D3:  BCF    03.5
03D4:  BSF    06.0
....................       printf("BREAKING \n"); 
03D5:  CLRF   58
03D6:  MOVF   58,W
03D7:  CALL   045
03D8:  INCF   58,F
03D9:  MOVWF  20
03DA:  MOVWF  6E
03DB:  CALL   111
03DC:  MOVLW  0A
03DD:  SUBWF  58,W
03DE:  BTFSS  03.2
03DF:  GOTO   3D6
....................       ELECthrottle =200; 
03E0:  CLRF   4D
03E1:  MOVLW  C8
03E2:  MOVWF  4C
....................       write_dac((unsigned int16) abs(ELECthrottle)+ELEC_CONTROLLER_OFFSET); 
03E3:  MOVF   4D,W
03E4:  MOVWF  23
03E5:  MOVF   4C,W
03E6:  BTFSS  4D.7
03E7:  GOTO   3F1
03E8:  MOVF   4C,W
03E9:  SUBLW  00
03EA:  MOVWF  20
03EB:  CLRF   23
03EC:  MOVF   4D,W
03ED:  BTFSS  03.0
03EE:  INCFSZ 4D,W
03EF:  SUBWF  23,F
03F0:  MOVF   20,W
03F1:  MOVWF  58
03F2:  MOVF   23,W
03F3:  MOVWF  59
03F4:  MOVLW  84
03F5:  ADDWF  20,W
03F6:  MOVWF  5A
03F7:  MOVF   23,W
03F8:  MOVWF  5B
03F9:  MOVLW  03
03FA:  BTFSC  03.0
03FB:  MOVLW  04
03FC:  ADDWF  5B,F
03FD:  MOVF   5B,W
03FE:  MOVWF  5D
03FF:  MOVF   5A,W
0400:  MOVWF  5C
0401:  CALL   0B5
....................       //Next we want to set the ICE throttle. Which should be as high as possible unless 
....................       //a)It is charging (throttle <0) and the voltage of the cap pack is at Full 
....................       //b)Throttle is at max braking and speed still increasing (delta increasing??) 
....................        
....................       //If a) then switch to electric only mode 
....................       //if b) then decrease the ICE throttle by a factor of the increasing delta 
....................        
....................        
....................       //write_dac((right_position-(right_position-(Athrottle-Athrottle_Min)*Athrottle_servo_factor))*4); 
....................       //write_dac(((Athrottle-AThrottle_Min)*2)+950); 
....................  
....................       //write_dac((right_position-current_servo_position)*4); 
....................    } 
0402:  GOTO   395
....................     
....................  
.................... } 
....................  
.................... /*! \brief Initialisation of PID controller parameters. 
....................  * 
....................  *  Initialise the variables used by the PID algorithm. 
....................  * 
....................  *  \param p_factor  Proportional term. 
....................  *  \param i_factor  Integral term. 
....................  *  \param d_factor  Derivate term. 
....................  *  \param pid  Struct with PID status. 
....................  */ 
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid) 
.................... // Set up PID controller parameters 
0403:  GOTO   403
.................... { 
....................   // Start values for PID controller 
....................   pid->sumError = 0; 
*
01B0:  MOVLW  02
01B1:  ADDWF  5E,W
01B2:  MOVWF  04
01B3:  INCF   04,F
01B4:  INCF   04,F
01B5:  INCF   04,F
01B6:  CLRF   00
01B7:  DECF   04,F
01B8:  CLRF   00
01B9:  DECF   04,F
01BA:  CLRF   00
01BB:  DECF   04,F
01BC:  CLRF   00
....................   pid->lastProcessValue = 0; 
01BD:  MOVF   5E,W
01BE:  MOVWF  04
01BF:  INCF   04,F
01C0:  CLRF   00
01C1:  DECF   04,F
01C2:  CLRF   00
....................   // Tuning constants for PID loop 
....................   pid->P_Factor = p_factor; 
01C3:  MOVLW  06
01C4:  ADDWF  5E,W
01C5:  MOVWF  04
01C6:  INCF   04,F
01C7:  MOVF   59,W
01C8:  MOVWF  00
01C9:  DECF   04,F
01CA:  MOVF   58,W
01CB:  MOVWF  00
....................   pid->I_Factor = i_factor; 
01CC:  MOVLW  08
01CD:  ADDWF  5E,W
01CE:  MOVWF  04
01CF:  INCF   04,F
01D0:  MOVF   5B,W
01D1:  MOVWF  00
01D2:  DECF   04,F
01D3:  MOVF   5A,W
01D4:  MOVWF  00
....................   pid->D_Factor = d_factor; 
01D5:  MOVLW  0A
01D6:  ADDWF  5E,W
01D7:  MOVWF  04
01D8:  INCF   04,F
01D9:  MOVF   5D,W
01DA:  MOVWF  00
01DB:  DECF   04,F
01DC:  MOVF   5C,W
01DD:  MOVWF  00
....................   // Limits to avoid overflow 
....................   pid->maxError = MAX_INT / (pid->P_Factor + 1); 
01DE:  MOVLW  0C
01DF:  ADDWF  5E,W
01E0:  MOVWF  5F
01E1:  MOVLW  06
01E2:  ADDWF  5E,W
01E3:  MOVWF  04
01E4:  INCF   04,F
01E5:  MOVF   00,W
01E6:  MOVWF  61
01E7:  DECF   04,F
01E8:  MOVF   00,W
01E9:  MOVWF  60
01EA:  MOVLW  01
01EB:  ADDWF  60,W
01EC:  MOVWF  21
01ED:  MOVF   61,W
01EE:  MOVWF  23
01EF:  BTFSC  03.0
01F0:  INCF   23,F
01F1:  MOVF   21,W
01F2:  MOVWF  62
01F3:  MOVF   23,W
01F4:  MOVWF  63
01F5:  MOVLW  7F
01F6:  MOVWF  65
01F7:  MOVLW  FF
01F8:  MOVWF  64
01F9:  MOVF   63,W
01FA:  MOVWF  67
01FB:  MOVF   62,W
01FC:  MOVWF  66
*
0221:  MOVF   5F,W
0222:  MOVWF  04
0223:  INCF   04,F
0224:  MOVF   22,W
0225:  MOVWF  00
0226:  DECF   04,F
0227:  MOVF   21,W
0228:  MOVWF  00
....................   printf("Max %ld factor %ld and pid %ld",MAX_INT,pid->I_Factor,pid->maxError); 
0229:  MOVLW  08
022A:  ADDWF  5E,W
022B:  MOVWF  04
022C:  INCF   04,F
022D:  MOVF   00,W
022E:  MOVWF  60
022F:  DECF   04,F
0230:  MOVF   00,W
0231:  MOVWF  5F
0232:  MOVLW  0C
0233:  ADDWF  5E,W
0234:  MOVWF  04
0235:  INCF   04,F
0236:  MOVF   00,W
0237:  MOVWF  62
0238:  DECF   04,F
0239:  MOVF   00,W
023A:  MOVWF  61
023B:  CLRF   63
023C:  MOVF   63,W
023D:  CALL   054
023E:  INCF   63,F
023F:  MOVWF  20
0240:  MOVWF  6E
0241:  CALL   111
0242:  MOVLW  04
0243:  SUBWF  63,W
0244:  BTFSS  03.2
0245:  GOTO   23C
0246:  MOVLW  10
0247:  MOVWF  04
0248:  MOVLW  7F
0249:  MOVWF  67
024A:  MOVLW  FF
024B:  MOVWF  66
024C:  CALL   13B
024D:  MOVLW  07
024E:  MOVWF  64
024F:  MOVF   64,W
0250:  CALL   054
0251:  INCF   64,F
0252:  MOVWF  20
0253:  MOVWF  6E
0254:  CALL   111
0255:  MOVLW  0F
0256:  SUBWF  64,W
0257:  BTFSS  03.2
0258:  GOTO   24F
0259:  MOVLW  10
025A:  MOVWF  04
025B:  MOVF   60,W
025C:  MOVWF  67
025D:  MOVF   5F,W
025E:  MOVWF  66
025F:  CALL   13B
0260:  MOVLW  12
0261:  MOVWF  65
0262:  MOVF   65,W
0263:  CALL   054
0264:  INCF   65,F
0265:  MOVWF  20
0266:  MOVWF  6E
0267:  CALL   111
0268:  MOVLW  1B
0269:  SUBWF  65,W
026A:  BTFSS  03.2
026B:  GOTO   262
026C:  MOVLW  10
026D:  MOVWF  04
026E:  MOVF   62,W
026F:  MOVWF  67
0270:  MOVF   61,W
0271:  MOVWF  66
0272:  CALL   13B
....................   pid->maxSumError = MAX_I_TERM / (pid->I_Factor + 1); 
0273:  MOVLW  0E
0274:  ADDWF  5E,W
0275:  MOVWF  5F
0276:  MOVLW  08
0277:  ADDWF  5E,W
0278:  MOVWF  04
0279:  INCF   04,F
027A:  MOVF   00,W
027B:  MOVWF  61
027C:  DECF   04,F
027D:  MOVF   00,W
027E:  MOVWF  60
027F:  MOVLW  01
0280:  ADDWF  60,W
0281:  MOVWF  21
0282:  MOVF   61,W
0283:  MOVWF  23
0284:  BTFSC  03.0
0285:  INCF   23,F
0286:  MOVF   21,W
0287:  MOVWF  62
0288:  MOVF   23,W
0289:  MOVWF  63
028A:  MOVF   04,W
028B:  MOVWF  64
028C:  MOVLW  3F
028D:  MOVWF  68
028E:  MOVLW  FF
028F:  MOVWF  67
0290:  MOVWF  66
0291:  MOVWF  65
0292:  CLRF   6C
0293:  CLRF   6B
0294:  MOVF   63,W
0295:  MOVWF  6A
0296:  MOVF   62,W
0297:  MOVWF  69
*
02D8:  MOVF   64,W
02D9:  MOVWF  04
02DA:  MOVF   5F,W
02DB:  MOVWF  04
02DC:  MOVF   20,W
02DD:  MOVWF  00
02DE:  INCF   04,F
02DF:  MOVF   21,W
02E0:  MOVWF  00
02E1:  INCF   04,F
02E2:  MOVF   22,W
02E3:  MOVWF  00
02E4:  INCF   04,F
02E5:  MOVF   23,W
02E6:  MOVWF  00
.................... } 
02E7:  BCF    0A.3
02E8:  GOTO   38D (RETURN)
....................  
....................  
.................... /*! \brief PID control algorithm. 
....................  * 
....................  *  Calculates output from setpoint, process value and PID status. 
....................  * 
....................  *  \param setPoint  Desired value. 
....................  *  \param processValue  Measured value. 
....................  *  \param pid_st  PID status struct. 
....................  */ 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st) 
.................... { 
....................   signed int16 error, p_term, d_term; 
....................   signed int32 i_term, ret, temp; 
....................     processValue=processValue/4; 
....................   //printf("input %ld speed %ld ",setPoint,processValue); 
....................   error = setPoint - processValue; 
....................    
....................   // Calculate Pterm and limit error overflow 
....................    
....................   if (error > (signed int16) pid_st->maxError){ 
....................     p_term = MAX_INT; 
....................     //printf("p greater error %ld a %ld p %ld",error,pid_st->maxError,p_term); 
....................  
....................   } 
....................   else if (error < (signed int16) -pid_st->maxError){ 
....................     p_term = -MAX_INT; 
....................     printf("p less error %ld a %ld p %ld",error,-pid_st->maxError,p_term); 
....................  
....................   } 
....................   else{ 
....................     p_term = (signed int16) (pid_st->P_Factor * (float) error); 
....................     //printf("error %ld a %ld p %ld",error,pid_st->maxError,p_term); 
....................   } 
....................    
....................   // Calculate Iterm and limit integral runaway 
....................   temp = pid_st->sumError + error; 
....................   if(temp > (signed int32)pid_st->maxSumError){ 
....................     i_term = MAX_I_TERM; 
....................     pid_st->sumError = pid_st->maxSumError; 
....................     printf("\n greater temp %ld a %ld sum %ld",temp,pid_st->maxSumError,pid_st->sumError); 
....................  
....................  } 
....................   else if(temp < (signed int32)-pid_st->maxSumError){ 
....................     i_term = -MAX_I_TERM; 
....................     pid_st->sumError = -pid_st->maxSumError; 
....................     printf("\n less temp %ld a %ld sum %ld",temp,pid_st->maxSumError,pid_st->sumError); 
....................  
....................   } 
....................   else{ 
....................     pid_st->sumError = temp; 
....................     i_term = pid_st->I_Factor * pid_st->sumError; 
....................     //printf("\n eror temp %ld i_term %ld sum %ld error %ld ",temp,i_term,pid_st->sumError,error); 
....................  
....................   } 
....................  
....................   // Calculate Dterm 
....................   d_term = pid_st->D_Factor * (pid_st->lastProcessValue - processValue); 
.................... printf("\n p_term %ld d_term %ld i_term %ld",p_term,d_term,i_term); 
....................   pid_st->lastProcessValue = processValue; 
....................  
....................   //ret = (p_term + i_term + d_term) / SCALING_FACTOR; 
....................    ret = (p_term+d_term+(signed int16)i_term) / SCALING_FACTOR; 
....................   if(ret > MAX_INT){ 
....................     ret = MAX_INT; 
....................   } 
....................   else if(ret < -MAX_INT){ 
....................     ret = -MAX_INT; 
....................   } 
....................  
....................   return((signed int16)ret); 
.................... } 
....................  
.................... /*! \brief Resets the integrator. 
....................  * 
....................  *  Calling this function will reset the integrator in the PID regulator. 
....................  */ 
.................... void pid_Reset_Integrator(pidData_t *pid_st) 
.................... { 
....................   pid_st->sumError = 0; 
.................... } 
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 373A   HS NOWDT NOPUT DEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
