CCS PCM C Compiler, Version 4.084, 46530               02-Mar-13 15:40

               Filename: HondaHybrid.lst

               ROM used: 3075 words (80%)
                         Largest free fragment is 392
               RAM used: 61 (34%) at main() level
                         120 (67%) worst case
               Stack:    4 worst case (3 in main + 1 for interrupts)

*
0000:  NOP
0001:  MOVLW  00
0002:  MOVWF  0A
0003:  GOTO   549
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  26
0008:  MOVF   7F,W
0009:  MOVWF  25
000A:  MOVF   0A,W
000B:  MOVWF  2D
000C:  CLRF   0A
000D:  SWAPF  25,F
000E:  MOVF   04,W
000F:  MOVWF  27
0010:  MOVF   20,W
0011:  MOVWF  28
0012:  MOVF   21,W
0013:  MOVWF  29
0014:  MOVF   22,W
0015:  MOVWF  2A
0016:  MOVF   23,W
0017:  MOVWF  2B
0018:  MOVF   24,W
0019:  MOVWF  2C
001A:  BCF    03.7
001B:  BCF    03.5
001C:  MOVLW  8C
001D:  MOVWF  04
001E:  BTFSS  00.0
001F:  GOTO   022
0020:  BTFSC  0C.0
0021:  GOTO   03F
0022:  MOVLW  8D
0023:  MOVWF  04
0024:  BTFSS  00.0
0025:  GOTO   028
0026:  BTFSC  0D.0
0027:  GOTO   041
0028:  BTFSS  0B.5
0029:  GOTO   02C
002A:  BTFSC  0B.2
002B:  GOTO   043
002C:  MOVF   27,W
002D:  MOVWF  04
002E:  MOVF   28,W
002F:  MOVWF  20
0030:  MOVF   29,W
0031:  MOVWF  21
0032:  MOVF   2A,W
0033:  MOVWF  22
0034:  MOVF   2B,W
0035:  MOVWF  23
0036:  MOVF   2C,W
0037:  MOVWF  24
0038:  MOVF   2D,W
0039:  MOVWF  0A
003A:  SWAPF  26,W
003B:  MOVWF  03
003C:  SWAPF  7F,F
003D:  SWAPF  7F,W
003E:  RETFIE
003F:  BCF    0A.3
0040:  GOTO   151
0041:  BCF    0A.3
0042:  GOTO   1A9
0043:  BCF    0A.3
0044:  GOTO   142
.................... #include "HondaHybrid.h" 
.................... #include <16F873A.h> 
.................... //////// Standard Header file for the PIC16F873A device //////////////// 
.................... #device PIC16F873A 
.................... #list 
....................  
....................  
.................... //#include <16F737.h> 
.................... #device ICD=TRUE 
.................... #device adc=10 
.................... //#device adc=8 
.................... #use delay(clock=20000000) 
*
041F:  MOVLW  59
0420:  MOVWF  04
0421:  MOVF   00,W
0422:  BTFSC  03.2
0423:  GOTO   431
0424:  MOVLW  06
0425:  MOVWF  21
0426:  CLRF   20
0427:  DECFSZ 20,F
0428:  GOTO   427
0429:  DECFSZ 21,F
042A:  GOTO   426
042B:  MOVLW  7B
042C:  MOVWF  20
042D:  DECFSZ 20,F
042E:  GOTO   42D
042F:  DECFSZ 00,F
0430:  GOTO   424
0431:  BCF    0A.3
0432:  GOTO   5D3 (RETURN)
.................... #fuses HS,PUT,NOWDT 
.................... #use rs232 (DEBUGGER) 
*
0231:  BSF    03.5
0232:  BCF    06.3
0233:  BCF    03.5
0234:  BCF    06.3
0235:  MOVLW  08
0236:  MOVWF  21
0237:  GOTO   238
0238:  NOP
0239:  BSF    21.7
023A:  GOTO   24B
023B:  BCF    21.7
023C:  BSF    03.5
023D:  RRF    2A,F
023E:  BCF    03.5
023F:  BTFSC  03.0
0240:  BSF    06.3
0241:  BTFSS  03.0
0242:  BCF    06.3
0243:  BSF    21.6
0244:  GOTO   24B
0245:  BCF    21.6
0246:  DECFSZ 21,F
0247:  GOTO   23C
0248:  GOTO   249
0249:  NOP
024A:  BSF    06.3
024B:  MOVLW  02
024C:  MOVWF  20
024D:  CLRF   04
024E:  DECFSZ 04,F
024F:  GOTO   24E
0250:  DECFSZ 20,F
0251:  GOTO   24D
0252:  MOVLW  AD
0253:  MOVWF  04
0254:  DECFSZ 04,F
0255:  GOTO   254
0256:  GOTO   257
0257:  NOP
0258:  BTFSC  21.7
0259:  GOTO   23B
025A:  BTFSC  21.6
025B:  GOTO   245
025C:  RETLW  00
.................... #include <mcp4921.c> 
.................... //////////////// Driver for MCP4921 D/A Converter /////////////////////// 
.................... ////                                                                 //// 
.................... ////  init_dac()    Call this before using a MCP4921 DAC             //// 
.................... ////                                                                 //// 
.................... ////  write_dac( long int )   Writes command and 12 bit resolution   //// 
.................... ////                          to the MCP4921 which converts it to a  //// 
.................... ////                          voltage                                //// 
.................... ////                          0-4095 input represents 0-vref V out.  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SELECT 
....................  
.................... #define DAC_CS     PIN_C4 
.................... #define DAC_CLK    PIN_C3 
.................... #define DAC_DI     PIN_C5 
.................... #define DAC_LDAC   PIN_B5 
....................  
.................... #endif 
....................  
.................... void init_dac() 
.................... { 
....................    output_high(DAC_CS); 
*
01BD:  BCF    2E.4
01BE:  MOVF   2E,W
01BF:  BSF    03.5
01C0:  MOVWF  07
01C1:  BCF    03.5
01C2:  BSF    07.4
....................    output_high(DAC_LDAC); 
01C3:  BSF    03.5
01C4:  BCF    06.5
01C5:  BCF    03.5
01C6:  BSF    06.5
....................    output_high(DAC_CLK); 
01C7:  BCF    2E.3
01C8:  MOVF   2E,W
01C9:  BSF    03.5
01CA:  MOVWF  07
01CB:  BCF    03.5
01CC:  BSF    07.3
....................    output_high(DAC_DI); 
01CD:  BCF    2E.5
01CE:  MOVF   2E,W
01CF:  BSF    03.5
01D0:  MOVWF  07
01D1:  BCF    03.5
01D2:  BSF    07.5
.................... } 
01D3:  BCF    0A.3
01D4:  GOTO   59C (RETURN)
....................  
.................... void write_dac(int16 data) { 
....................    BYTE cmd[3]; 
....................    BYTE i; 
....................  
....................    cmd[0]=data; 
01D5:  MOVF   58,W
01D6:  MOVWF  5A
....................    cmd[1]=(data>>8); 
01D7:  MOVF   59,W
01D8:  MOVWF  5B
....................    cmd[2]=0x03;                            
01D9:  MOVLW  03
01DA:  MOVWF  5C
....................     
....................    output_high(DAC_LDAC); 
01DB:  BSF    03.5
01DC:  BCF    06.5
01DD:  BCF    03.5
01DE:  BSF    06.5
....................    output_low(DAC_CLK); 
01DF:  BCF    2E.3
01E0:  MOVF   2E,W
01E1:  BSF    03.5
01E2:  MOVWF  07
01E3:  BCF    03.5
01E4:  BCF    07.3
....................    output_low(DAC_CS); 
01E5:  BCF    2E.4
01E6:  MOVF   2E,W
01E7:  BSF    03.5
01E8:  MOVWF  07
01E9:  BCF    03.5
01EA:  BCF    07.4
....................  
....................    for(i=0; i<=23; ++i) 
01EB:  CLRF   5D
01EC:  MOVF   5D,W
01ED:  SUBLW  17
01EE:  BTFSS  03.0
01EF:  GOTO   21D
....................    { 
....................       if(i<4 || (i>7 && i<12)) 
01F0:  MOVF   5D,W
01F1:  SUBLW  03
01F2:  BTFSC  03.0
01F3:  GOTO   1FC
01F4:  MOVF   5D,W
01F5:  SUBLW  07
01F6:  BTFSC  03.0
01F7:  GOTO   201
01F8:  MOVF   5D,W
01F9:  SUBLW  0B
01FA:  BTFSS  03.0
01FB:  GOTO   201
....................          shift_left(cmd,3,0); 
01FC:  BCF    03.0
01FD:  RLF    5A,F
01FE:  RLF    5B,F
01FF:  RLF    5C,F
....................       else 
0200:  GOTO   21B
....................       { 
....................          output_bit(DAC_DI, shift_left(cmd,3,0)); 
0201:  BCF    03.0
0202:  RLF    5A,F
0203:  RLF    5B,F
0204:  RLF    5C,F
0205:  BTFSC  03.0
0206:  GOTO   209
0207:  BCF    07.5
0208:  GOTO   20A
0209:  BSF    07.5
020A:  BCF    2E.5
020B:  MOVF   2E,W
020C:  BSF    03.5
020D:  MOVWF  07
....................  
....................          output_high(DAC_CLK); 
020E:  BCF    03.5
020F:  BCF    2E.3
0210:  MOVF   2E,W
0211:  BSF    03.5
0212:  MOVWF  07
0213:  BCF    03.5
0214:  BSF    07.3
....................          output_low(DAC_CLK); 
0215:  BCF    2E.3
0216:  MOVF   2E,W
0217:  BSF    03.5
0218:  MOVWF  07
0219:  BCF    03.5
021A:  BCF    07.3
....................       } 
....................    } 
021B:  INCF   5D,F
021C:  GOTO   1EC
....................    output_high(DAC_CS); 
021D:  BCF    2E.4
021E:  MOVF   2E,W
021F:  BSF    03.5
0220:  MOVWF  07
0221:  BCF    03.5
0222:  BSF    07.4
....................  
....................    output_low(DAC_LDAC); 
0223:  BSF    03.5
0224:  BCF    06.5
0225:  BCF    03.5
0226:  BCF    06.5
....................    delay_us(10); 
0227:  MOVLW  10
0228:  MOVWF  20
0229:  DECFSZ 20,F
022A:  GOTO   229
022B:  NOP
....................     
....................    output_HIGH(DAC_LDAC); 
022C:  BSF    03.5
022D:  BCF    06.5
022E:  BCF    03.5
022F:  BSF    06.5
.................... } 
0230:  RETLW  00
....................  
....................  
....................  
.................... #include "pid.h" 
.................... /*This file has been prepared for Doxygen automatic documentation generation.*/ 
.................... /*! \file ********************************************************************* 
....................  * 
....................  * \brief Header file for pid.c. 
....................  * 
....................  * - File:               pid.h 
....................  * - Compiler:           IAR EWAAVR 4.11A 
....................  * - Supported devices:  All AVR devices can be used. 
....................  * - AppNote:            AVR221 - Discrete PID controller 
....................  * 
....................  * \author               Atmel Corporation: http://www.atmel.com \n 
....................  *                       Support email: avr@atmel.com 
....................  * 
....................  * $Name$ 
....................  * $Revision: 456 $ 
....................  * $RCSfile$ 
....................  * $Date: 2006-02-16 12:46:13 +0100 (to, 16 feb 2006) $ 
....................  *****************************************************************************/ 
....................  
.................... #ifndef PID_H 
.................... #define PID_H 
....................  
.................... //#include "stdint.h" 
.................... #define INT16_MAX 32767 
.................... #define INT32_MAX 2147483647 
.................... #define SCALING_FACTOR  1 
....................  
.................... /*! \brief PID Status 
....................  * 
....................  * Setpoints and data used by the PID control algorithm 
....................  */ 
.................... typedef struct PID_DATA{ 
....................   //! Last process value, used to find derivative of process value. 
....................   int16 lastProcessValue; 
....................   //! Summation of errors, used for integrate calculations 
....................   int32 sumError; 
....................   //! The Proportional tuning constant, multiplied with SCALING_FACTOR 
....................   int16 P_Factor; 
....................   //! The Integral tuning constant, multiplied with SCALING_FACTOR 
....................   int16 I_Factor; 
....................   //! The Derivative tuning constant, multiplied with SCALING_FACTOR 
....................   int16 D_Factor; 
....................   //! Maximum allowed error, avoid overflow 
....................   int16 maxError; 
....................   //! Maximum allowed sumerror, avoid overflow 
....................   int32 maxSumError; 
.................... } pidData_t; 
....................  
.................... /*! \brief Maximum values 
....................  * 
....................  * Needed to avoid sign/overflow problems 
....................  */ 
.................... // Maximum value of variables 
.................... #define MAX_INT         INT16_MAX 
.................... #define MAX_LONG        INT32_MAX 
.................... #define MAX_I_TERM      (MAX_LONG / 2) 
....................  
.................... // Boolean values 
.................... //#define FALSE           0 
.................... //#define TRUE            1 
....................  
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid); 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st); 
.................... void pid_Reset_Integrator(pidData_t *pid_st); 
....................  
.................... #endif 
....................  
.................... /* 
.................... This is the main controller for the super capacitor hybrid scooter a.k.a RED 
.................... B2 close contactor 
.................... CONTROL BOX INPUTS 
.................... Athrottle- A0 - analog input representing the users input for speed, 10 bit 
.................... Vspeed - CCp2-a 16 bit representation of the speed of the vehicle 
.................... Acaps- A1 - analog input representing the current voltage of the supercapacitors, 10 bit 
....................  
.................... CONTROL BOX OUTPUT 
.................... ICEthrottle- B1 - a 16 bit number sent to the internal combustion engine(ICE) throttle  
.................... ELECthrottle-  - a 16 bit number sent as analog value representing the demanded electric power 
....................  
.................... SPECIFICS OF I/O 
....................  
.................... Athrottle - the electric throttle is a 3 wire unit with a 5 volt,ground, and analog out 
....................    representing how far throttle is turned. Pin AN0 is the input. 
....................     
.................... Vspeed - There is a encoder in the rear wheel/electric motor that is used by the electric 
....................    power controller. Tapping in to this this Main Controller receives a 5 Volt square wave 
....................    with 42 pulses. There are two options for measuring speed. The first is to measure the  
....................    length of the pulses. The second is to measure the rate of pulses. This controller currently 
....................    uses the rate method. The int_ccp2 interupt is called on each falling edge and stores the  
....................    Vspeed value as the max number of 16bit (65535-timer0_since_last_reset).  
....................     
....................    The RED scooter has a circumpherence of 16.3*2*pi = 102.4 
....................    X m/h * 63360 inch/mile * 1/3600 h/sec * 1/(102.4 inch/rev) = .171875* X 
....................    Examples 50 mph is 8.9 ms 1 overflow of timer0 
....................    Example 5 mph is 89 ms or 13 time overflow 
....................     
....................    #int_timer0 increments the counter number_of_overflows each time it overflows 
....................    On int ccp2 we multiply number_of_overflows * 256 + timer0 to get timer0_since_last_reset 
....................     
.................... Acaps - the analog voltage which is the 5volt representation of the voltage in the caps which 
....................    have a value of between 0-48v. The voltages are factored so that the voltage on AN1 goes 
....................    from 0 - 4.8 volts (TODO check this factor, think its 1/11 not 1/10) 
....................     
.................... ICEthrottle -  #int_timer1 is set to make sure the period follows the required below 
....................    The period for the servo is .020 seconds which is 50,000 operations 
....................    The leftmost position of the server is .001 seconds which is 2,500 
....................    The rightmost position of the server is .002 seconds which is 5,000 
....................     
....................    The output pin is pin_B1.-> 
....................  
.................... ELECthrottle 
....................    The electric power controller takes an analog voltage as input. The output voltage 
....................    is set by the DAC. The pins used are C3,C4,C5. if CHARGING_STATE is true then  
....................     
.................... ALGORITHM 
....................    The algorithm is basically a PID controller. In broad terms we are trying to set the 
....................    ICEthrottle and ICEelectric to maximize the use of electric and accelerate to meet the 
....................    requirements set by the rider with the Athrottle signal. When the demanded power is  
....................    less than the power output possible by the ICE and the caps are in the CHARGING_STATE  
....................    then the ICE is turned up to the max and the ELECthrottle is set to regen to 
....................    charge the capacitors.If CHARGING_STATE is false then the caps are supplying the drivig power 
....................    and the ICE is set to "off", the caps supply the power. Unless the user requested supply 
....................    is enough to require both power sources. 
....................     
....................    If CHARGING_STATE is true. Then pin_b2 is set as high which will close the brake number 
....................    for the electric power controller.  
....................     
....................    If CHARGING_STATE is false then the pin_b2 is set low which opens brake. 
....................     
....................     
....................  
....................  
.................... The encoder has 42 on and offs per rotation, i.e. 21 steps 
....................  
.................... Number of operations per second is CLOCK/4/Timer Divisions 
.................... Number of operations per second is 20,000,000/4/128 = 39062.5  
.................... Each operation takes 1/39062.5 = .256 micro (x10^-6) seconds 
.................... Seconds to Overflow timer0 8bit timer = .256x10^-6 * 256 = 6.55ms 
....................  
....................  
....................  
.................... */ 
.................... #define servo_pin PIN_B1  //Setting servo out pin to be hardware pin b1 
.................... #define brake_pin PIN_B4 
.................... #define ADC_DELAY delay_us(20) 
.................... #define Acaps_pin PIN_A1 
.................... #define Acaps_channel 1 
.................... #define Athrottle_pin PIN_A0  //Voltage goes from 1.5 (306)to 4.1(836) 
.................... #define Athrottle_Min 306 
.................... #define Athrottle_Max 860 
.................... #define Athrottle_Full Athrottle_Max-Athrottle_Min 
.................... #define Athrottle_channel 0 
.................... #define Electric_Controller_Switch PIN_B0 
.................... #define Contactor_Switch PIN_B2 
....................  
.................... //PID Values 
.................... #define K_P 1.00 
.................... #define K_I 0.00 
.................... #define K_D 0.25 
....................  
.................... int1 pid_Timer = 0; 
*
055A:  BCF    2F.0
.................... struct PID_DATA pidData; 
.................... #define TIME_INTERVAL 157 //TODO replace 
....................  
.................... #define left_position 3950 
.................... #define right_position 4800 
.................... #define servo_difference  right_position-left_position 
.................... const float Athrottle_servo_factor = ((float) servo_difference)/((float) Athrottle_FULL); 
.................... #define servo_period   65356-50000 
.................... unsigned int16 current_servo_position=right_position; 
055B:  MOVLW  C0
055C:  MOVWF  42
055D:  MOVLW  12
055E:  MOVWF  43
.................... int1 SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0; 
055F:  BCF    2F.1
.................... int1 test_boolean = 0; 
0560:  BCF    2F.2
....................  
.................... int1 test_switch = 0; 
0561:  BCF    2F.3
.................... unsigned int16 test_counter = 0; 
0562:  CLRF   44
0563:  CLRF   45
.................... //int16 returnedValue = 0; 
....................  
.................... unsigned int16 number_of_timer0_interupts_since_reset =0; 
0564:  CLRF   46
0565:  CLRF   47
.................... unsigned int16 timer0_since_last_reset= 0; 
0566:  CLRF   48
0567:  CLRF   49
.................... unsigned int16 vSpeed= 0; 
0568:  CLRF   4A
0569:  CLRF   4B
.................... unsigned int16 ELECthrottle = 900; 
056A:  MOVLW  84
056B:  MOVWF  4C
056C:  MOVLW  03
056D:  MOVWF  4D
.................... unsigned int16 ICEthrottle = 0; 
056E:  CLRF   4E
056F:  CLRF   4F
.................... unsigned int16 Athrottle = 0; 
0570:  CLRF   50
0571:  CLRF   51
.................... unsigned int16 Acaps = 0; 
0572:  CLRF   52
0573:  CLRF   53
.................... int1 CURRENTLY_CHARGING = 0; 
0574:  BCF    2F.4
.................... signed int16 returnedValue =0; 
0575:  CLRF   54
0576:  CLRF   55
.................... int16 speeder = 0;  
0577:  CLRF   56
0578:  CLRF   57
.................... /* 
.................... The #int_timer0 interupt is triggered on each timer0 8bit interupt 
.................... the function simply increments a overflow counter to be used by the ccp2 
.................... interupt to calculate speed 
.................... NUMBER OF OPERATIONS =  
.................... */ 
.................... #int_timer0 
.................... void timer0_isr(){ 
....................     
....................       number_of_timer0_interupts_since_reset=number_of_timer0_interupts_since_reset+256; 
*
0142:  MOVLW  01
0143:  ADDWF  47,F
....................       //current_servo_position=current_servo_position+1; 
....................        
....................     
....................    if (number_of_timer0_interupts_since_reset>=1024){ 
0144:  MOVF   47,W
0145:  SUBLW  03
0146:  BTFSC  03.0
0147:  GOTO   14E
....................       vSpeed = 1280; 
0148:  MOVLW  05
0149:  MOVWF  4B
014A:  CLRF   4A
....................       number_of_timer0_interupts_since_reset=1024; 
014B:  MOVLW  04
014C:  MOVWF  47
014D:  CLRF   46
....................        
....................        
....................    } 
.................... } 
....................  
.................... /* 
.................... #int_timer1 is used by the ICEservo throttle to regulate the timing pulses. The  
.................... timer is setup for a pulsetrain of 20ms period. This is done as follows, 
....................  
.................... Period is 1/(CLOCK/4opsperclock)*(startingPostionOfClock) = 20 ms 
.................... for this setup 1/(20000000/4)*(50000) = 20 ms 
....................  
.................... The timer1 starts at 0 and counts up. So we set the beggining of the clock at 
.................... servo_period which is 65356-50000 so that the total time is 20ms. 
.................... */ 
014E:  BCF    0B.2
014F:  BCF    0A.3
0150:  GOTO   02C
.................... #int_timer1 
.................... void isr() 
.................... { 
....................  
.................... //Make sure that the position is within the left and right positions of the servo 
....................    if (current_servo_position<left_position){ 
0151:  MOVF   43,W
0152:  SUBLW  0F
0153:  BTFSS  03.0
0154:  GOTO   160
0155:  BTFSS  03.2
0156:  GOTO   15B
0157:  MOVF   42,W
0158:  SUBLW  6D
0159:  BTFSS  03.0
015A:  GOTO   160
....................       current_servo_position = left_position; 
015B:  MOVLW  0F
015C:  MOVWF  43
015D:  MOVLW  6E
015E:  MOVWF  42
....................    } 
....................    else if (current_servo_position > right_position){ 
015F:  GOTO   16F
0160:  MOVF   43,W
0161:  SUBLW  11
0162:  BTFSC  03.0
0163:  GOTO   16F
0164:  XORLW  FF
0165:  BTFSS  03.2
0166:  GOTO   16B
0167:  MOVF   42,W
0168:  SUBLW  C0
0169:  BTFSC  03.0
016A:  GOTO   16F
....................       current_servo_position = right_position; 
016B:  MOVLW  12
016C:  MOVWF  43
016D:  MOVLW  C0
016E:  MOVWF  42
....................    } 
....................  
....................    if(SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER) 
016F:  BTFSS  2F.1
0170:  GOTO   18E
....................       {  
....................          output_high(servo_pin);        //Set the servo control pin to high  
0171:  BSF    03.5
0172:  BCF    06.1
0173:  BCF    03.5
0174:  BSF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0;  
0175:  BCF    2F.1
....................          set_timer1(65356-current_servo_position); //Set timer for the position high pulse 
0176:  MOVF   42,W
0177:  SUBLW  4C
0178:  BSF    03.5
0179:  MOVWF  37
017A:  MOVLW  FF
017B:  MOVWF  38
017C:  BCF    03.5
017D:  MOVF   43,W
017E:  BTFSS  03.0
017F:  INCFSZ 43,W
0180:  GOTO   182
0181:  GOTO   185
0182:  BSF    03.5
0183:  SUBWF  38,F
0184:  BCF    03.5
0185:  BSF    03.5
0186:  MOVF   38,W
0187:  BCF    03.5
0188:  MOVWF  0F
0189:  BSF    03.5
018A:  MOVF   37,W
018B:  BCF    03.5
018C:  MOVWF  0E
....................       }  
....................    else  
018D:  GOTO   1A6
....................       {  
....................          output_low(servo_pin);                      // Set the servo control pin to low   
018E:  BSF    03.5
018F:  BCF    06.1
0190:  BCF    03.5
0191:  BCF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 1;  
0192:  BSF    2F.1
....................          set_timer1(servo_period+current_servo_position);          //Set timer for the low position the length is the difference between  
0193:  MOVLW  FC
0194:  ADDWF  42,W
0195:  BSF    03.5
0196:  MOVWF  37
0197:  BCF    03.5
0198:  MOVF   43,W
0199:  BSF    03.5
019A:  MOVWF  38
019B:  MOVLW  3B
019C:  BTFSC  03.0
019D:  MOVLW  3C
019E:  ADDWF  38,F
019F:  MOVF   38,W
01A0:  BCF    03.5
01A1:  MOVWF  0F
01A2:  BSF    03.5
01A3:  MOVF   37,W
01A4:  BCF    03.5
01A5:  MOVWF  0E
....................                                                      //the total int16 lenght - high pulse length 
....................       }   
.................... } 
....................  
....................  
.................... /* 
.................... #int_ccp2 is called on the falling edge of the encoder pulse. We calculate the time 
.................... between pulses.  
.................... TODO will have to put some kind of smoothing mechanism 
.................... */ 
01A6:  BCF    0C.0
01A7:  BCF    0A.3
01A8:  GOTO   02C
.................... #int_ccp2 
.................... void isr2() 
.................... { 
.................... if (number_of_timer0_interupts_since_reset>10){ 
01A9:  MOVF   47,F
01AA:  BTFSS  03.2
01AB:  GOTO   1B0
01AC:  MOVF   46,W
01AD:  SUBLW  0A
01AE:  BTFSC  03.0
01AF:  GOTO   1BA
.................... vSpeed  = (number_of_timer0_interupts_since_reset+get_timer0()); 
01B0:  MOVF   01,W
01B1:  ADDWF  46,W
01B2:  MOVWF  4A
01B3:  MOVF   47,W
01B4:  MOVWF  4B
01B5:  BTFSC  03.0
01B6:  INCF   4B,F
.................... //vSpeed  = -(get_timer0()); 
.................... set_timer0(0); 
01B7:  CLRF   01
.................... number_of_timer0_interupts_since_reset = 0; 
01B8:  CLRF   47
01B9:  CLRF   46
.................... } 
.................... } 
....................  
....................  
....................  
....................  
01BA:  BCF    0D.0
01BB:  BCF    0A.3
01BC:  GOTO   02C
.................... void main() 
.................... {   
*
0549:  CLRF   04
054A:  MOVLW  1F
054B:  ANDWF  03,F
054C:  BSF    03.5
054D:  BCF    06.3
054E:  BCF    03.5
054F:  BSF    06.3
0550:  BSF    03.5
0551:  BSF    1F.0
0552:  BSF    1F.1
0553:  BSF    1F.2
0554:  BCF    1F.3
0555:  MOVLW  07
0556:  MOVWF  1C
....................     
....................    setup_adc_ports(NO_ANALOGS); 
*
0579:  BSF    03.5
057A:  BSF    1F.0
057B:  BSF    1F.1
057C:  BSF    1F.2
057D:  BCF    1F.3
....................    setup_adc(ADC_OFF); 
057E:  BCF    03.5
057F:  BCF    1F.0
....................    setup_spi(FALSE); 
0580:  CLRF   14
....................     
....................    setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
0581:  BSF    03.5
0582:  MOVF   01,W
0583:  ANDLW  C0
0584:  IORLW  00
0585:  MOVWF  01
0586:  CLRWDT
....................    setup_timer_1(T1_DISABLED); 
0587:  BCF    03.5
0588:  CLRF   10
....................    setup_timer_2(T2_DISABLED,0,1); 
0589:  MOVLW  00
058A:  MOVWF  21
058B:  MOVWF  12
058C:  MOVLW  00
058D:  BSF    03.5
058E:  MOVWF  12
....................    setup_port_a(ALL_ANALOG); 
058F:  BCF    1F.0
0590:  BCF    1F.1
0591:  BCF    1F.2
0592:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
0593:  BCF    1F.6
0594:  BCF    03.5
0595:  BSF    1F.6
0596:  BSF    1F.7
0597:  BSF    03.5
0598:  BSF    1F.7
0599:  BCF    03.5
059A:  BSF    1F.0
....................     
....................    init_dac(); 
059B:  GOTO   1BD
....................   
....................    setup_timer_1(T1_DIV_BY_2| T1_INTERNAL);  
059C:  MOVLW  95
059D:  MOVWF  10
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_128); 
059E:  BSF    03.5
059F:  MOVF   01,W
05A0:  ANDLW  C0
05A1:  IORLW  06
05A2:  MOVWF  01
....................    setup_ccp2(CCP_CAPTURE_RE);    // Configure CCP2 to capture fall 
05A3:  BCF    03.5
05A4:  BSF    2E.1
05A5:  MOVF   2E,W
05A6:  BSF    03.5
05A7:  MOVWF  07
05A8:  BCF    03.5
05A9:  CLRF   1D
05AA:  MOVLW  05
05AB:  MOVWF  1D
....................    enable_interrupts(INT_CCP2);   // Setup interrupt on falling edge 
05AC:  BSF    03.5
05AD:  BSF    0D.0
....................    enable_interrupts(INT_TIMER0); 
05AE:  BCF    03.5
05AF:  BSF    0B.5
....................    enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
05B0:  BSF    03.5
05B1:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
05B2:  MOVLW  C0
05B3:  BCF    03.5
05B4:  IORWF  0B,F
....................    output_low(Electric_Controller_Switch); 
05B5:  BSF    03.5
05B6:  BCF    06.0
05B7:  BCF    03.5
05B8:  BCF    06.0
....................    write_dac(0); 
05B9:  CLRF   59
05BA:  CLRF   58
05BB:  CALL   1D5
....................    output_high(Contactor_Switch); 
05BC:  BSF    03.5
05BD:  BCF    06.2
05BE:  BCF    03.5
05BF:  BSF    06.2
....................    output_low(brake_pin); 
05C0:  BSF    03.5
05C1:  BCF    06.4
05C2:  BCF    03.5
05C3:  BCF    06.4
....................    pid_Init(K_P*SCALING_FACTOR,K_I*SCALING_FACTOR,K_D*SCALING_FACTOR, & pidData); 
05C4:  CLRF   59
05C5:  MOVLW  01
05C6:  MOVWF  58
05C7:  CLRF   5B
05C8:  CLRF   5A
05C9:  CLRF   5D
05CA:  CLRF   5C
05CB:  MOVLW  30
05CC:  MOVWF  5E
05CD:  GOTO   319
....................     
....................    delay_ms(3000); 
05CE:  MOVLW  0C
05CF:  MOVWF  58
05D0:  MOVLW  FA
05D1:  MOVWF  59
05D2:  GOTO   41F
05D3:  DECFSZ 58,F
05D4:  GOTO   5D0
....................    //write_dac(1000); 
....................    //delay_ms(10000); 
....................    //output_high(Contactor_Switch); 
....................    //output_high(brake_pin); 
....................    //output_high(Electric_Controller_Switch); 
....................    while(TRUE) { 
....................  
....................       //GET INPUTS 
....................       //Vspeedhappens in interrupts 
....................        
....................       set_adc_channel(Acaps_channel); 
05D5:  MOVLW  08
05D6:  MOVWF  21
05D7:  MOVF   1F,W
05D8:  ANDLW  C7
05D9:  IORWF  21,W
05DA:  MOVWF  1F
....................       ADC_DELAY; 
05DB:  MOVLW  21
05DC:  MOVWF  20
05DD:  DECFSZ 20,F
05DE:  GOTO   5DD
....................       Acaps = read_adc(); 
05DF:  BSF    1F.2
05E0:  BTFSC  1F.2
05E1:  GOTO   5E0
05E2:  BSF    03.5
05E3:  MOVF   1E,W
05E4:  BCF    03.5
05E5:  MOVWF  52
05E6:  MOVF   1E,W
05E7:  MOVWF  53
....................        
....................       set_adc_channel(Athrottle_channel); 
05E8:  MOVLW  00
05E9:  MOVWF  21
05EA:  MOVF   1F,W
05EB:  ANDLW  C7
05EC:  IORWF  21,W
05ED:  MOVWF  1F
....................       ADC_DELAY; 
05EE:  MOVLW  21
05EF:  MOVWF  20
05F0:  DECFSZ 20,F
05F1:  GOTO   5F0
....................       Athrottle = read_adc(); 
05F2:  BSF    1F.2
05F3:  BTFSC  1F.2
05F4:  GOTO   5F3
05F5:  BSF    03.5
05F6:  MOVF   1E,W
05F7:  BCF    03.5
05F8:  MOVWF  50
05F9:  MOVF   1E,W
05FA:  MOVWF  51
....................  
....................       //CONTROL BOX 
....................  
....................        
....................       //current_servo_position=left_position+((Athrottle-Athrottle_Min)/Athrottle_Full)*servo_difference;//(vSpeed/65536.0)*(2500); 
....................       if (Athrottle<Athrottle_Min){ 
05FB:  MOVF   51,W
05FC:  SUBLW  01
05FD:  BTFSS  03.0
05FE:  GOTO   609
05FF:  BTFSS  03.2
0600:  GOTO   605
0601:  MOVF   50,W
0602:  SUBLW  31
0603:  BTFSS  03.0
0604:  GOTO   609
....................          Athrottle=Athrottle_Min; 
0605:  MOVLW  01
0606:  MOVWF  51
0607:  MOVLW  32
0608:  MOVWF  50
....................       } 
....................       //current_servo_position=right_position-(Athrottle-Athrottle_Min)*Athrottle_servo_factor;//(Athrottle/Athrottle_Full)*servo_difference;//(vSpeed/65536.0)*(2500); 
....................       //printf("Analog Cap %d Analog Throttle %d\n",(int) Acaps, (int) Athrottle); 
....................       current_servo_position =right_position-vSpeed+200; 
0609:  MOVF   4A,W
060A:  SUBLW  C0
060B:  MOVWF  58
060C:  MOVLW  12
060D:  MOVWF  59
060E:  MOVF   4B,W
060F:  BTFSS  03.0
0610:  INCFSZ 4B,W
0611:  SUBWF  59,F
0612:  MOVLW  C8
0613:  ADDWF  58,W
0614:  MOVWF  42
0615:  MOVF   59,W
0616:  MOVWF  43
0617:  BTFSC  03.0
0618:  INCF   43,F
....................       speeder = vSpeed; 
0619:  MOVF   4B,W
061A:  MOVWF  57
061B:  MOVF   4A,W
061C:  MOVWF  56
....................       printf("Speed %lu \n",speeder); 
061D:  CLRF   58
061E:  MOVF   58,W
061F:  CALL   045
0620:  INCF   58,F
0621:  MOVWF  20
0622:  BSF    03.5
0623:  MOVWF  2A
0624:  BCF    03.5
0625:  CALL   231
0626:  MOVLW  06
0627:  SUBWF  58,W
0628:  BTFSS  03.2
0629:  GOTO   61E
062A:  MOVLW  10
062B:  MOVWF  04
062C:  MOVF   57,W
062D:  MOVWF  5A
062E:  MOVF   56,W
062F:  MOVWF  59
0630:  CALL   433
0631:  MOVLW  20
0632:  BSF    03.5
0633:  MOVWF  2A
0634:  BCF    03.5
0635:  CALL   231
0636:  MOVLW  0A
0637:  BSF    03.5
0638:  MOVWF  2A
0639:  BCF    03.5
063A:  CALL   231
....................       //SET OUTPUTS  
....................       //The writing of the ICEThrottle happens in interupts and all that is 
....................       //required is updating ICEthrottle 
....................       //printf("speed before %ld \n",vSpeed); 
....................       returnedValue = pid_Controller((Athrottle-AThrottle_Min),(1280-speeder),& pidData); 
063B:  MOVLW  32
063C:  SUBWF  50,W
063D:  MOVWF  58
063E:  MOVF   51,W
063F:  MOVWF  59
0640:  MOVLW  01
0641:  BTFSS  03.0
0642:  MOVLW  02
0643:  SUBWF  59,F
0644:  MOVF   56,W
0645:  SUBLW  00
0646:  MOVWF  5A
0647:  MOVLW  05
0648:  MOVWF  5B
0649:  MOVF   57,W
064A:  BTFSS  03.0
064B:  INCFSZ 57,W
064C:  SUBWF  5B,F
064D:  MOVF   59,W
064E:  MOVWF  5D
064F:  MOVF   58,W
0650:  MOVWF  5C
0651:  MOVF   5B,W
0652:  MOVWF  5F
0653:  MOVF   5A,W
0654:  MOVWF  5E
0655:  MOVLW  30
0656:  MOVWF  60
0657:  BSF    0A.3
0658:  GOTO   000
0659:  BCF    0A.3
065A:  MOVF   22,W
065B:  MOVWF  55
065C:  MOVF   21,W
065D:  MOVWF  54
....................       if (ELECthrottle+returnedValue<0){ 
065E:  MOVF   54,W
065F:  ADDWF  4C,W
0660:  MOVWF  58
0661:  MOVF   4D,W
0662:  MOVWF  59
0663:  MOVF   55,W
0664:  BTFSC  03.0
0665:  INCFSZ 55,W
0666:  ADDWF  59,F
0667:  BTFSS  59.7
0668:  GOTO   66C
....................          ELECthrottle=0; 
0669:  CLRF   4D
066A:  CLRF   4C
....................       } 
....................       else { 
066B:  GOTO   672
....................       ELECthrottle = ELECthrottle+returnedValue; 
066C:  MOVF   54,W
066D:  ADDWF  4C,F
066E:  MOVF   55,W
066F:  BTFSC  03.0
0670:  INCFSZ 55,W
0671:  ADDWF  4D,F
....................       } 
....................       printf("r %lu\n",((unsigned int16) returnedValue)); 
0672:  MOVLW  72
0673:  BSF    03.5
0674:  MOVWF  2A
0675:  BCF    03.5
0676:  CALL   231
0677:  MOVLW  20
0678:  BSF    03.5
0679:  MOVWF  2A
067A:  BCF    03.5
067B:  CALL   231
067C:  MOVLW  10
067D:  MOVWF  04
067E:  MOVF   55,W
067F:  MOVWF  5A
0680:  MOVF   54,W
0681:  MOVWF  59
0682:  CALL   433
0683:  MOVLW  0A
0684:  BSF    03.5
0685:  MOVWF  2A
0686:  BCF    03.5
0687:  CALL   231
....................       write_dac((unsigned int16)ELECthrottle); 
0688:  MOVF   4D,W
0689:  MOVWF  59
068A:  MOVF   4C,W
068B:  MOVWF  58
068C:  CALL   1D5
....................       //write_dac((right_position-(right_position-(Athrottle-Athrottle_Min)*Athrottle_servo_factor))*4); 
....................       //write_dac(((Athrottle-AThrottle_Min)*2)+950); 
....................  
....................       //write_dac((right_position-current_servo_position)*4); 
....................    } 
068D:  GOTO   5D5
....................     
....................  
.................... } 
....................  
.................... /*! \brief Initialisation of PID controller parameters. 
....................  * 
....................  *  Initialise the variables used by the PID algorithm. 
....................  * 
....................  *  \param p_factor  Proportional term. 
....................  *  \param i_factor  Integral term. 
....................  *  \param d_factor  Derivate term. 
....................  *  \param pid  Struct with PID status. 
....................  */ 
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid) 
.................... // Set up PID controller parameters 
068E:  GOTO   68E
.................... { 
....................   // Start values for PID controller 
....................   pid->sumError = 0; 
*
0319:  MOVLW  02
031A:  ADDWF  5E,W
031B:  MOVWF  04
031C:  INCF   04,F
031D:  INCF   04,F
031E:  INCF   04,F
031F:  CLRF   00
0320:  DECF   04,F
0321:  CLRF   00
0322:  DECF   04,F
0323:  CLRF   00
0324:  DECF   04,F
0325:  CLRF   00
....................   pid->lastProcessValue = 0; 
0326:  MOVF   5E,W
0327:  MOVWF  04
0328:  INCF   04,F
0329:  CLRF   00
032A:  DECF   04,F
032B:  CLRF   00
....................   // Tuning constants for PID loop 
....................   pid->P_Factor = p_factor; 
032C:  MOVLW  06
032D:  ADDWF  5E,W
032E:  MOVWF  04
032F:  INCF   04,F
0330:  MOVF   59,W
0331:  MOVWF  00
0332:  DECF   04,F
0333:  MOVF   58,W
0334:  MOVWF  00
....................   pid->I_Factor = i_factor; 
0335:  MOVLW  08
0336:  ADDWF  5E,W
0337:  MOVWF  04
0338:  INCF   04,F
0339:  MOVF   5B,W
033A:  MOVWF  00
033B:  DECF   04,F
033C:  MOVF   5A,W
033D:  MOVWF  00
....................   pid->D_Factor = d_factor; 
033E:  MOVLW  0A
033F:  ADDWF  5E,W
0340:  MOVWF  04
0341:  INCF   04,F
0342:  MOVF   5D,W
0343:  MOVWF  00
0344:  DECF   04,F
0345:  MOVF   5C,W
0346:  MOVWF  00
....................   // Limits to avoid overflow 
....................   pid->maxError = MAX_INT / (pid->P_Factor + 1); 
0347:  MOVLW  0C
0348:  ADDWF  5E,W
0349:  MOVWF  5F
034A:  MOVLW  06
034B:  ADDWF  5E,W
034C:  MOVWF  04
034D:  INCF   04,F
034E:  MOVF   00,W
034F:  MOVWF  61
0350:  DECF   04,F
0351:  MOVF   00,W
0352:  MOVWF  60
0353:  MOVLW  01
0354:  ADDWF  60,W
0355:  MOVWF  21
0356:  MOVF   61,W
0357:  MOVWF  23
0358:  BTFSC  03.0
0359:  INCF   23,F
035A:  MOVF   21,W
035B:  MOVWF  62
035C:  MOVF   23,W
035D:  MOVWF  63
035E:  MOVLW  7F
035F:  MOVWF  65
0360:  MOVLW  FF
0361:  MOVWF  64
0362:  MOVF   63,W
0363:  MOVWF  67
0364:  MOVF   62,W
0365:  MOVWF  66
*
038A:  MOVF   5F,W
038B:  MOVWF  04
038C:  INCF   04,F
038D:  MOVF   22,W
038E:  MOVWF  00
038F:  DECF   04,F
0390:  MOVF   21,W
0391:  MOVWF  00
....................   printf("Max %ld factor %ld and pid %ld",MAX_INT,pid->P_Factor,pid->maxError); 
0392:  MOVLW  06
0393:  ADDWF  5E,W
0394:  MOVWF  04
0395:  INCF   04,F
0396:  MOVF   00,W
0397:  MOVWF  60
0398:  DECF   04,F
0399:  MOVF   00,W
039A:  MOVWF  5F
039B:  MOVLW  0C
039C:  ADDWF  5E,W
039D:  MOVWF  04
039E:  INCF   04,F
039F:  MOVF   00,W
03A0:  MOVWF  62
03A1:  DECF   04,F
03A2:  MOVF   00,W
03A3:  MOVWF  61
03A4:  CLRF   63
03A5:  MOVF   63,W
03A6:  CALL   055
03A7:  INCF   63,F
03A8:  MOVWF  20
03A9:  BSF    03.5
03AA:  MOVWF  2A
03AB:  BCF    03.5
03AC:  CALL   231
03AD:  MOVLW  04
03AE:  SUBWF  63,W
03AF:  BTFSS  03.2
03B0:  GOTO   3A5
03B1:  MOVLW  10
03B2:  MOVWF  04
03B3:  MOVLW  7F
03B4:  MOVWF  77
03B5:  MOVLW  FF
03B6:  MOVWF  76
03B7:  CALL   25D
03B8:  MOVLW  07
03B9:  MOVWF  64
03BA:  MOVF   64,W
03BB:  CALL   055
03BC:  INCF   64,F
03BD:  MOVWF  20
03BE:  BSF    03.5
03BF:  MOVWF  2A
03C0:  BCF    03.5
03C1:  CALL   231
03C2:  MOVLW  0F
03C3:  SUBWF  64,W
03C4:  BTFSS  03.2
03C5:  GOTO   3BA
03C6:  MOVLW  10
03C7:  MOVWF  04
03C8:  MOVF   60,W
03C9:  MOVWF  77
03CA:  MOVF   5F,W
03CB:  MOVWF  76
03CC:  CALL   25D
03CD:  MOVLW  12
03CE:  MOVWF  65
03CF:  MOVF   65,W
03D0:  CALL   055
03D1:  INCF   65,F
03D2:  MOVWF  20
03D3:  BSF    03.5
03D4:  MOVWF  2A
03D5:  BCF    03.5
03D6:  CALL   231
03D7:  MOVLW  1B
03D8:  SUBWF  65,W
03D9:  BTFSS  03.2
03DA:  GOTO   3CF
03DB:  MOVLW  10
03DC:  MOVWF  04
03DD:  MOVF   62,W
03DE:  MOVWF  77
03DF:  MOVF   61,W
03E0:  MOVWF  76
03E1:  CALL   25D
....................   pid->maxSumError = MAX_I_TERM / (pid->I_Factor + 1); 
03E2:  MOVLW  0E
03E3:  ADDWF  5E,W
03E4:  MOVWF  5F
03E5:  MOVLW  08
03E6:  ADDWF  5E,W
03E7:  MOVWF  04
03E8:  INCF   04,F
03E9:  MOVF   00,W
03EA:  MOVWF  61
03EB:  DECF   04,F
03EC:  MOVF   00,W
03ED:  MOVWF  60
03EE:  MOVLW  01
03EF:  ADDWF  60,W
03F0:  MOVWF  21
03F1:  MOVF   61,W
03F2:  MOVWF  23
03F3:  BTFSC  03.0
03F4:  INCF   23,F
03F5:  MOVF   21,W
03F6:  MOVWF  62
03F7:  MOVF   23,W
03F8:  MOVWF  63
03F9:  MOVF   04,W
03FA:  MOVWF  64
03FB:  MOVLW  3F
03FC:  BSF    03.5
03FD:  MOVWF  2D
03FE:  MOVLW  FF
03FF:  MOVWF  2C
0400:  MOVWF  2B
0401:  MOVWF  2A
0402:  CLRF   31
0403:  CLRF   30
0404:  BCF    03.5
0405:  MOVF   23,W
0406:  BSF    03.5
0407:  MOVWF  2F
0408:  BCF    03.5
0409:  MOVF   21,W
040A:  BSF    03.5
040B:  MOVWF  2E
040C:  BCF    03.5
040D:  CALL   2D4
040E:  MOVF   64,W
040F:  MOVWF  04
0410:  MOVF   5F,W
0411:  MOVWF  04
0412:  MOVF   20,W
0413:  MOVWF  00
0414:  INCF   04,F
0415:  MOVF   21,W
0416:  MOVWF  00
0417:  INCF   04,F
0418:  MOVF   22,W
0419:  MOVWF  00
041A:  INCF   04,F
041B:  MOVF   23,W
041C:  MOVWF  00
.................... } 
041D:  BCF    0A.3
041E:  GOTO   5CE (RETURN)
....................  
....................  
.................... /*! \brief PID control algorithm. 
....................  * 
....................  *  Calculates output from setpoint, process value and PID status. 
....................  * 
....................  *  \param setPoint  Desired value. 
....................  *  \param processValue  Measured value. 
....................  *  \param pid_st  PID status struct. 
....................  */ 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st) 
.................... { 
....................   signed int16 error, p_term, d_term; 
....................   signed int32 i_term, ret, temp; 
....................     processValue=processValue/4; 
*
0800:  RRF    5F,F
0801:  RRF    5E,F
0802:  RRF    5F,F
0803:  RRF    5E,F
0804:  MOVLW  3F
0805:  ANDWF  5F,F
....................   //printf("input %ld speed %ld ",setPoint,processValue); 
....................   error = setPoint - processValue; 
0806:  MOVF   5E,W
0807:  SUBWF  5C,W
0808:  MOVWF  20
0809:  MOVF   5D,W
080A:  MOVWF  23
080B:  MOVF   5F,W
080C:  BTFSS  03.0
080D:  INCFSZ 5F,W
080E:  SUBWF  23,F
080F:  MOVF   20,W
0810:  MOVWF  61
0811:  MOVF   23,W
0812:  MOVWF  62
....................    
....................   // Calculate Pterm and limit error overflow 
....................    
....................   if (error > (signed int16) pid_st->maxError){ 
0813:  MOVLW  0C
0814:  ADDWF  60,W
0815:  MOVWF  04
0816:  INCF   04,F
0817:  MOVF   00,W
0818:  MOVWF  23
0819:  DECF   04,F
081A:  MOVF   00,W
081B:  MOVWF  21
081C:  BTFSS  23.7
081D:  GOTO   021
081E:  BTFSS  62.7
081F:  GOTO   02D
0820:  GOTO   023
0821:  BTFSC  62.7
0822:  GOTO   091
0823:  MOVF   23,W
0824:  SUBWF  62,W
0825:  BTFSS  03.0
0826:  GOTO   091
0827:  BTFSS  03.2
0828:  GOTO   02D
0829:  MOVF   61,W
082A:  SUBWF  21,W
082B:  BTFSC  03.0
082C:  GOTO   091
....................     p_term = MAX_INT; 
082D:  MOVLW  7F
082E:  MOVWF  64
082F:  MOVLW  FF
0830:  MOVWF  63
....................     printf(" greater error %ld a %ld p %ld",error,pid_st->maxError,p_term); 
0831:  MOVLW  0C
0832:  ADDWF  60,W
0833:  MOVWF  04
0834:  INCF   04,F
0835:  MOVF   00,W
0836:  MOVWF  74
0837:  DECF   04,F
0838:  MOVF   00,W
0839:  MOVWF  73
083A:  CLRF   75
083B:  MOVF   75,W
083C:  BCF    0A.3
083D:  CALL   078
083E:  BSF    0A.3
083F:  INCF   75,F
0840:  MOVWF  20
0841:  BSF    03.5
0842:  MOVWF  2A
0843:  BCF    0A.3
0844:  BCF    03.5
0845:  CALL   231
0846:  BSF    0A.3
0847:  MOVLW  0F
0848:  SUBWF  75,W
0849:  BTFSS  03.2
084A:  GOTO   03B
084B:  MOVLW  10
084C:  MOVWF  04
084D:  MOVF   62,W
084E:  MOVWF  77
084F:  MOVF   61,W
0850:  MOVWF  76
0851:  BCF    0A.3
0852:  CALL   25D
0853:  BSF    0A.3
0854:  MOVLW  20
0855:  BSF    03.5
0856:  MOVWF  2A
0857:  BCF    0A.3
0858:  BCF    03.5
0859:  CALL   231
085A:  BSF    0A.3
085B:  MOVLW  61
085C:  BSF    03.5
085D:  MOVWF  2A
085E:  BCF    0A.3
085F:  BCF    03.5
0860:  CALL   231
0861:  BSF    0A.3
0862:  MOVLW  20
0863:  BSF    03.5
0864:  MOVWF  2A
0865:  BCF    0A.3
0866:  BCF    03.5
0867:  CALL   231
0868:  BSF    0A.3
0869:  MOVLW  10
086A:  MOVWF  04
086B:  MOVF   74,W
086C:  MOVWF  77
086D:  MOVF   73,W
086E:  MOVWF  76
086F:  BCF    0A.3
0870:  CALL   25D
0871:  BSF    0A.3
0872:  MOVLW  20
0873:  BSF    03.5
0874:  MOVWF  2A
0875:  BCF    0A.3
0876:  BCF    03.5
0877:  CALL   231
0878:  BSF    0A.3
0879:  MOVLW  70
087A:  BSF    03.5
087B:  MOVWF  2A
087C:  BCF    0A.3
087D:  BCF    03.5
087E:  CALL   231
087F:  BSF    0A.3
0880:  MOVLW  20
0881:  BSF    03.5
0882:  MOVWF  2A
0883:  BCF    0A.3
0884:  BCF    03.5
0885:  CALL   231
0886:  BSF    0A.3
0887:  MOVLW  10
0888:  MOVWF  04
0889:  MOVF   64,W
088A:  MOVWF  77
088B:  MOVF   63,W
088C:  MOVWF  76
088D:  BCF    0A.3
088E:  CALL   25D
088F:  BSF    0A.3
....................  
....................   } 
....................   else if (error < (signed int16) -pid_st->maxError){ 
0890:  GOTO   197
0891:  MOVLW  0C
0892:  ADDWF  60,W
0893:  MOVWF  04
0894:  INCF   04,F
0895:  MOVF   00,W
0896:  MOVWF  23
0897:  DECF   04,F
0898:  MOVF   00,W
0899:  SUBLW  00
089A:  MOVWF  20
089B:  MOVF   23,W
089C:  BTFSS  03.0
089D:  INCFSZ 23,W
089E:  GOTO   0A1
089F:  MOVLW  00
08A0:  GOTO   0A2
08A1:  SUBLW  00
08A2:  MOVWF  23
08A3:  MOVF   20,W
08A4:  MOVWF  21
08A5:  BTFSS  62.7
08A6:  GOTO   0AA
08A7:  BTFSS  23.7
08A8:  GOTO   0B6
08A9:  GOTO   0AC
08AA:  BTFSC  23.7
08AB:  GOTO   120
08AC:  MOVF   62,W
08AD:  SUBWF  23,W
08AE:  BTFSS  03.0
08AF:  GOTO   120
08B0:  BTFSS  03.2
08B1:  GOTO   0B6
08B2:  MOVF   21,W
08B3:  SUBWF  61,W
08B4:  BTFSC  03.0
08B5:  GOTO   120
....................     p_term = -MAX_INT; 
08B6:  MOVLW  80
08B7:  MOVWF  64
08B8:  MOVLW  01
08B9:  MOVWF  63
....................     printf("less error %ld a %ld p %ld",error,-pid_st->maxError,p_term); 
08BA:  MOVLW  0C
08BB:  ADDWF  60,W
08BC:  MOVWF  04
08BD:  INCF   04,F
08BE:  MOVF   00,W
08BF:  MOVWF  23
08C0:  DECF   04,F
08C1:  MOVF   00,W
08C2:  SUBLW  00
08C3:  MOVWF  73
08C4:  CLRF   74
08C5:  MOVF   23,W
08C6:  BTFSS  03.0
08C7:  INCFSZ 23,W
08C8:  SUBWF  74,F
08C9:  CLRF   75
08CA:  MOVF   75,W
08CB:  BCF    0A.3
08CC:  CALL   09B
08CD:  BSF    0A.3
08CE:  INCF   75,F
08CF:  MOVWF  20
08D0:  BSF    03.5
08D1:  MOVWF  2A
08D2:  BCF    0A.3
08D3:  BCF    03.5
08D4:  CALL   231
08D5:  BSF    0A.3
08D6:  MOVLW  0B
08D7:  SUBWF  75,W
08D8:  BTFSS  03.2
08D9:  GOTO   0CA
08DA:  MOVLW  10
08DB:  MOVWF  04
08DC:  MOVF   62,W
08DD:  MOVWF  77
08DE:  MOVF   61,W
08DF:  MOVWF  76
08E0:  BCF    0A.3
08E1:  CALL   25D
08E2:  BSF    0A.3
08E3:  MOVLW  20
08E4:  BSF    03.5
08E5:  MOVWF  2A
08E6:  BCF    0A.3
08E7:  BCF    03.5
08E8:  CALL   231
08E9:  BSF    0A.3
08EA:  MOVLW  61
08EB:  BSF    03.5
08EC:  MOVWF  2A
08ED:  BCF    0A.3
08EE:  BCF    03.5
08EF:  CALL   231
08F0:  BSF    0A.3
08F1:  MOVLW  20
08F2:  BSF    03.5
08F3:  MOVWF  2A
08F4:  BCF    0A.3
08F5:  BCF    03.5
08F6:  CALL   231
08F7:  BSF    0A.3
08F8:  MOVLW  10
08F9:  MOVWF  04
08FA:  MOVF   74,W
08FB:  MOVWF  77
08FC:  MOVF   73,W
08FD:  MOVWF  76
08FE:  BCF    0A.3
08FF:  CALL   25D
0900:  BSF    0A.3
0901:  MOVLW  20
0902:  BSF    03.5
0903:  MOVWF  2A
0904:  BCF    0A.3
0905:  BCF    03.5
0906:  CALL   231
0907:  BSF    0A.3
0908:  MOVLW  70
0909:  BSF    03.5
090A:  MOVWF  2A
090B:  BCF    0A.3
090C:  BCF    03.5
090D:  CALL   231
090E:  BSF    0A.3
090F:  MOVLW  20
0910:  BSF    03.5
0911:  MOVWF  2A
0912:  BCF    0A.3
0913:  BCF    03.5
0914:  CALL   231
0915:  BSF    0A.3
0916:  MOVLW  10
0917:  MOVWF  04
0918:  MOVF   64,W
0919:  MOVWF  77
091A:  MOVF   63,W
091B:  MOVWF  76
091C:  BCF    0A.3
091D:  CALL   25D
091E:  BSF    0A.3
....................  
....................   } 
....................   else{ 
091F:  GOTO   197
....................     p_term = pid_st->P_Factor * error; 
0920:  MOVLW  06
0921:  ADDWF  60,W
0922:  MOVWF  04
0923:  INCF   04,F
0924:  MOVF   00,W
0925:  MOVWF  74
0926:  DECF   04,F
0927:  MOVF   00,W
0928:  MOVWF  73
0929:  MOVF   74,W
092A:  MOVWF  7A
092B:  MOVF   73,W
092C:  MOVWF  79
092D:  MOVF   62,W
092E:  MOVWF  7C
092F:  MOVF   61,W
0930:  MOVWF  7B
0931:  BCF    0A.3
0932:  CALL   48D
0933:  BSF    0A.3
0934:  MOVF   22,W
0935:  MOVWF  64
0936:  MOVF   21,W
0937:  MOVWF  63
....................    printf("error %ld a %ld p %ld",error,pid_st->maxError,p_term); 
0938:  MOVLW  0C
0939:  ADDWF  60,W
093A:  MOVWF  04
093B:  INCF   04,F
093C:  MOVF   00,W
093D:  MOVWF  74
093E:  DECF   04,F
093F:  MOVF   00,W
0940:  MOVWF  73
0941:  CLRF   75
0942:  MOVF   75,W
0943:  BCF    0A.3
0944:  CALL   0BA
0945:  BSF    0A.3
0946:  INCF   75,F
0947:  MOVWF  20
0948:  BSF    03.5
0949:  MOVWF  2A
094A:  BCF    0A.3
094B:  BCF    03.5
094C:  CALL   231
094D:  BSF    0A.3
094E:  MOVLW  06
094F:  SUBWF  75,W
0950:  BTFSS  03.2
0951:  GOTO   142
0952:  MOVLW  10
0953:  MOVWF  04
0954:  MOVF   62,W
0955:  MOVWF  77
0956:  MOVF   61,W
0957:  MOVWF  76
0958:  BCF    0A.3
0959:  CALL   25D
095A:  BSF    0A.3
095B:  MOVLW  20
095C:  BSF    03.5
095D:  MOVWF  2A
095E:  BCF    0A.3
095F:  BCF    03.5
0960:  CALL   231
0961:  BSF    0A.3
0962:  MOVLW  61
0963:  BSF    03.5
0964:  MOVWF  2A
0965:  BCF    0A.3
0966:  BCF    03.5
0967:  CALL   231
0968:  BSF    0A.3
0969:  MOVLW  20
096A:  BSF    03.5
096B:  MOVWF  2A
096C:  BCF    0A.3
096D:  BCF    03.5
096E:  CALL   231
096F:  BSF    0A.3
0970:  MOVLW  10
0971:  MOVWF  04
0972:  MOVF   74,W
0973:  MOVWF  77
0974:  MOVF   73,W
0975:  MOVWF  76
0976:  BCF    0A.3
0977:  CALL   25D
0978:  BSF    0A.3
0979:  MOVLW  20
097A:  BSF    03.5
097B:  MOVWF  2A
097C:  BCF    0A.3
097D:  BCF    03.5
097E:  CALL   231
097F:  BSF    0A.3
0980:  MOVLW  70
0981:  BSF    03.5
0982:  MOVWF  2A
0983:  BCF    0A.3
0984:  BCF    03.5
0985:  CALL   231
0986:  BSF    0A.3
0987:  MOVLW  20
0988:  BSF    03.5
0989:  MOVWF  2A
098A:  BCF    0A.3
098B:  BCF    03.5
098C:  CALL   231
098D:  BSF    0A.3
098E:  MOVLW  10
098F:  MOVWF  04
0990:  MOVF   64,W
0991:  MOVWF  77
0992:  MOVF   63,W
0993:  MOVWF  76
0994:  BCF    0A.3
0995:  CALL   25D
0996:  BSF    0A.3
....................   } 
....................    
....................   // Calculate Iterm and limit integral runaway 
....................   temp = pid_st->sumError + error; 
0997:  MOVLW  02
0998:  ADDWF  60,W
0999:  MOVWF  04
099A:  MOVF   00,W
099B:  MOVWF  73
099C:  INCF   04,F
099D:  MOVF   00,W
099E:  MOVWF  74
099F:  INCF   04,F
09A0:  MOVF   00,W
09A1:  MOVWF  75
09A2:  INCF   04,F
09A3:  MOVF   00,W
09A4:  MOVWF  76
09A5:  MOVF   61,W
09A6:  MOVWF  20
09A7:  MOVF   62,W
09A8:  MOVWF  21
09A9:  CLRF   22
09AA:  CLRF   23
09AB:  BTFSS  62.7
09AC:  GOTO   1AF
09AD:  DECF   22,F
09AE:  DECF   23,F
09AF:  MOVF   20,W
09B0:  ADDWF  73,W
09B1:  MOVWF  6F
09B2:  MOVF   74,W
09B3:  MOVWF  70
09B4:  MOVF   21,W
09B5:  BTFSC  03.0
09B6:  INCFSZ 21,W
09B7:  ADDWF  70,F
09B8:  MOVF   75,W
09B9:  MOVWF  71
09BA:  MOVF   22,W
09BB:  BTFSC  03.0
09BC:  INCFSZ 22,W
09BD:  ADDWF  71,F
09BE:  MOVF   76,W
09BF:  MOVWF  72
09C0:  MOVF   23,W
09C1:  BTFSC  03.0
09C2:  INCFSZ 23,W
09C3:  ADDWF  72,F
....................   if(temp > (signed int32)pid_st->maxSumError){ 
09C4:  MOVLW  0E
09C5:  ADDWF  60,W
09C6:  MOVWF  04
09C7:  MOVF   00,W
09C8:  MOVWF  20
09C9:  INCF   04,F
09CA:  MOVF   00,W
09CB:  MOVWF  21
09CC:  INCF   04,F
09CD:  MOVF   00,W
09CE:  MOVWF  22
09CF:  INCF   04,F
09D0:  MOVF   00,W
09D1:  MOVWF  23
09D2:  BTFSS  23.7
09D3:  GOTO   1D7
09D4:  BTFSS  72.7
09D5:  GOTO   1EF
09D6:  GOTO   1D9
09D7:  BTFSC  72.7
09D8:  GOTO   2A7
09D9:  MOVF   23,W
09DA:  SUBWF  72,W
09DB:  BTFSS  03.0
09DC:  GOTO   2A7
09DD:  BTFSS  03.2
09DE:  GOTO   1EF
09DF:  MOVF   22,W
09E0:  SUBWF  71,W
09E1:  BTFSS  03.0
09E2:  GOTO   2A7
09E3:  BTFSS  03.2
09E4:  GOTO   1EF
09E5:  MOVF   21,W
09E6:  SUBWF  70,W
09E7:  BTFSS  03.0
09E8:  GOTO   2A7
09E9:  BTFSS  03.2
09EA:  GOTO   1EF
09EB:  MOVF   6F,W
09EC:  SUBWF  20,W
09ED:  BTFSC  03.0
09EE:  GOTO   2A7
....................     i_term = MAX_I_TERM; 
09EF:  MOVLW  3F
09F0:  MOVWF  6A
09F1:  MOVLW  FF
09F2:  MOVWF  69
09F3:  MOVWF  68
09F4:  MOVWF  67
....................     pid_st->sumError = pid_st->maxSumError; 
09F5:  MOVLW  02
09F6:  ADDWF  60,W
09F7:  MOVWF  73
09F8:  MOVLW  0E
09F9:  ADDWF  60,W
09FA:  MOVWF  04
09FB:  MOVF   00,W
09FC:  MOVWF  20
09FD:  INCF   04,F
09FE:  MOVF   00,W
09FF:  MOVWF  21
0A00:  INCF   04,F
0A01:  MOVF   00,W
0A02:  MOVWF  22
0A03:  INCF   04,F
0A04:  MOVF   00,W
0A05:  MOVWF  23
0A06:  MOVF   73,W
0A07:  MOVWF  04
0A08:  MOVF   20,W
0A09:  MOVWF  00
0A0A:  INCF   04,F
0A0B:  MOVF   21,W
0A0C:  MOVWF  00
0A0D:  INCF   04,F
0A0E:  MOVF   22,W
0A0F:  MOVWF  00
0A10:  INCF   04,F
0A11:  MOVF   23,W
0A12:  MOVWF  00
....................     printf("\n greater temp %ld a %ld sum %ld",temp,pid_st->maxSumError,pid_st->sumError); 
0A13:  MOVLW  0E
0A14:  ADDWF  60,W
0A15:  MOVWF  04
0A16:  MOVF   00,W
0A17:  MOVWF  73
0A18:  INCF   04,F
0A19:  MOVF   00,W
0A1A:  MOVWF  74
0A1B:  INCF   04,F
0A1C:  MOVF   00,W
0A1D:  MOVWF  75
0A1E:  INCF   04,F
0A1F:  MOVF   00,W
0A20:  MOVWF  76
0A21:  MOVLW  02
0A22:  ADDWF  60,W
0A23:  MOVWF  04
0A24:  MOVF   00,W
0A25:  MOVWF  77
0A26:  INCF   04,F
0A27:  MOVF   00,W
0A28:  MOVWF  78
0A29:  INCF   04,F
0A2A:  MOVF   00,W
0A2B:  MOVWF  79
0A2C:  INCF   04,F
0A2D:  MOVF   00,W
0A2E:  MOVWF  7A
0A2F:  CLRF   7B
0A30:  MOVF   7B,W
0A31:  BCF    0A.3
0A32:  CALL   0D4
0A33:  BSF    0A.3
0A34:  INCF   7B,F
0A35:  MOVWF  20
0A36:  BSF    03.5
0A37:  MOVWF  2A
0A38:  BCF    0A.3
0A39:  BCF    03.5
0A3A:  CALL   231
0A3B:  BSF    0A.3
0A3C:  MOVLW  0F
0A3D:  SUBWF  7B,W
0A3E:  BTFSS  03.2
0A3F:  GOTO   230
0A40:  MOVLW  41
0A41:  MOVWF  04
0A42:  MOVF   72,W
0A43:  BSF    03.5
0A44:  MOVWF  23
0A45:  BCF    03.5
0A46:  MOVF   71,W
0A47:  BSF    03.5
0A48:  MOVWF  22
0A49:  BCF    03.5
0A4A:  MOVF   70,W
0A4B:  BSF    03.5
0A4C:  MOVWF  21
0A4D:  BCF    03.5
0A4E:  MOVF   6F,W
0A4F:  BSF    03.5
0A50:  MOVWF  20
0A51:  BCF    0A.3
0A52:  BCF    03.5
0A53:  CALL   4A2
0A54:  BSF    0A.3
0A55:  MOVLW  20
0A56:  BSF    03.5
0A57:  MOVWF  2A
0A58:  BCF    0A.3
0A59:  BCF    03.5
0A5A:  CALL   231
0A5B:  BSF    0A.3
0A5C:  MOVLW  61
0A5D:  BSF    03.5
0A5E:  MOVWF  2A
0A5F:  BCF    0A.3
0A60:  BCF    03.5
0A61:  CALL   231
0A62:  BSF    0A.3
0A63:  MOVLW  20
0A64:  BSF    03.5
0A65:  MOVWF  2A
0A66:  BCF    0A.3
0A67:  BCF    03.5
0A68:  CALL   231
0A69:  BSF    0A.3
0A6A:  MOVLW  41
0A6B:  MOVWF  04
0A6C:  MOVF   76,W
0A6D:  BSF    03.5
0A6E:  MOVWF  23
0A6F:  BCF    03.5
0A70:  MOVF   75,W
0A71:  BSF    03.5
0A72:  MOVWF  22
0A73:  BCF    03.5
0A74:  MOVF   74,W
0A75:  BSF    03.5
0A76:  MOVWF  21
0A77:  BCF    03.5
0A78:  MOVF   73,W
0A79:  BSF    03.5
0A7A:  MOVWF  20
0A7B:  BCF    0A.3
0A7C:  BCF    03.5
0A7D:  CALL   4A2
0A7E:  BSF    0A.3
0A7F:  MOVLW  18
0A80:  MOVWF  7C
0A81:  MOVF   7C,W
0A82:  BCF    0A.3
0A83:  CALL   0D4
0A84:  BSF    0A.3
0A85:  INCF   7C,F
0A86:  MOVWF  20
0A87:  BSF    03.5
0A88:  MOVWF  2A
0A89:  BCF    0A.3
0A8A:  BCF    03.5
0A8B:  CALL   231
0A8C:  BSF    0A.3
0A8D:  MOVLW  1D
0A8E:  SUBWF  7C,W
0A8F:  BTFSS  03.2
0A90:  GOTO   281
0A91:  MOVLW  41
0A92:  MOVWF  04
0A93:  MOVF   7A,W
0A94:  BSF    03.5
0A95:  MOVWF  23
0A96:  BCF    03.5
0A97:  MOVF   79,W
0A98:  BSF    03.5
0A99:  MOVWF  22
0A9A:  BCF    03.5
0A9B:  MOVF   78,W
0A9C:  BSF    03.5
0A9D:  MOVWF  21
0A9E:  BCF    03.5
0A9F:  MOVF   77,W
0AA0:  BSF    03.5
0AA1:  MOVWF  20
0AA2:  BCF    0A.3
0AA3:  BCF    03.5
0AA4:  CALL   4A2
0AA5:  BSF    0A.3
....................  
....................  } 
....................   else if(temp < (signed int32)-pid_st->maxSumError){ 
0AA6:  GOTO   4E1
0AA7:  MOVLW  0E
0AA8:  ADDWF  60,W
0AA9:  MOVWF  04
0AAA:  MOVF   00,W
0AAB:  MOVWF  20
0AAC:  INCF   04,F
0AAD:  MOVF   00,W
0AAE:  MOVWF  21
0AAF:  INCF   04,F
0AB0:  MOVF   00,W
0AB1:  MOVWF  22
0AB2:  INCF   04,F
0AB3:  MOVF   00,W
0AB4:  MOVWF  23
0AB5:  MOVLW  FD
0AB6:  ADDWF  04,F
0AB7:  MOVF   20,W
0AB8:  SUBLW  00
0AB9:  MOVWF  20
0ABA:  MOVF   21,W
0ABB:  BTFSS  03.0
0ABC:  INCFSZ 21,W
0ABD:  GOTO   2C0
0ABE:  MOVLW  00
0ABF:  GOTO   2C1
0AC0:  SUBLW  00
0AC1:  MOVWF  21
0AC2:  MOVF   22,W
0AC3:  BTFSS  03.0
0AC4:  INCFSZ 22,W
0AC5:  GOTO   2C8
0AC6:  MOVLW  00
0AC7:  GOTO   2C9
0AC8:  SUBLW  00
0AC9:  MOVWF  22
0ACA:  MOVF   23,W
0ACB:  BTFSS  03.0
0ACC:  INCFSZ 23,W
0ACD:  GOTO   2D0
0ACE:  MOVLW  00
0ACF:  GOTO   2D1
0AD0:  SUBLW  00
0AD1:  MOVWF  23
0AD2:  BTFSS  72.7
0AD3:  GOTO   2D7
0AD4:  BTFSS  23.7
0AD5:  GOTO   2EF
0AD6:  GOTO   2D9
0AD7:  BTFSC  23.7
0AD8:  GOTO   3CB
0AD9:  MOVF   72,W
0ADA:  SUBWF  23,W
0ADB:  BTFSS  03.0
0ADC:  GOTO   3CB
0ADD:  BTFSS  03.2
0ADE:  GOTO   2EF
0ADF:  MOVF   71,W
0AE0:  SUBWF  22,W
0AE1:  BTFSS  03.0
0AE2:  GOTO   3CB
0AE3:  BTFSS  03.2
0AE4:  GOTO   2EF
0AE5:  MOVF   70,W
0AE6:  SUBWF  21,W
0AE7:  BTFSS  03.0
0AE8:  GOTO   3CB
0AE9:  BTFSS  03.2
0AEA:  GOTO   2EF
0AEB:  MOVF   20,W
0AEC:  SUBWF  6F,W
0AED:  BTFSC  03.0
0AEE:  GOTO   3CB
....................     i_term = -MAX_I_TERM; 
0AEF:  MOVLW  C0
0AF0:  MOVWF  6A
0AF1:  CLRF   69
0AF2:  CLRF   68
0AF3:  MOVLW  01
0AF4:  MOVWF  67
....................     pid_st->sumError = -pid_st->maxSumError; 
0AF5:  MOVLW  02
0AF6:  ADDWF  60,W
0AF7:  MOVWF  73
0AF8:  MOVLW  0E
0AF9:  ADDWF  60,W
0AFA:  MOVWF  04
0AFB:  MOVF   00,W
0AFC:  MOVWF  20
0AFD:  INCF   04,F
0AFE:  MOVF   00,W
0AFF:  MOVWF  21
0B00:  INCF   04,F
0B01:  MOVF   00,W
0B02:  MOVWF  22
0B03:  INCF   04,F
0B04:  MOVF   00,W
0B05:  MOVWF  23
0B06:  MOVLW  FD
0B07:  ADDWF  04,F
0B08:  MOVF   20,W
0B09:  SUBLW  00
0B0A:  MOVWF  20
0B0B:  MOVF   21,W
0B0C:  BTFSS  03.0
0B0D:  INCFSZ 21,W
0B0E:  GOTO   311
0B0F:  MOVLW  00
0B10:  GOTO   312
0B11:  SUBLW  00
0B12:  MOVWF  21
0B13:  MOVF   22,W
0B14:  BTFSS  03.0
0B15:  INCFSZ 22,W
0B16:  GOTO   319
0B17:  MOVLW  00
0B18:  GOTO   31A
0B19:  SUBLW  00
0B1A:  MOVWF  22
0B1B:  MOVF   23,W
0B1C:  BTFSS  03.0
0B1D:  INCFSZ 23,W
0B1E:  GOTO   321
0B1F:  MOVLW  00
0B20:  GOTO   322
0B21:  SUBLW  00
0B22:  MOVWF  23
0B23:  MOVWF  77
0B24:  MOVF   22,W
0B25:  MOVWF  76
0B26:  MOVF   21,W
0B27:  MOVWF  75
0B28:  MOVF   20,W
0B29:  MOVWF  74
0B2A:  MOVF   73,W
0B2B:  MOVWF  04
0B2C:  MOVF   74,W
0B2D:  MOVWF  00
0B2E:  INCF   04,F
0B2F:  MOVF   75,W
0B30:  MOVWF  00
0B31:  INCF   04,F
0B32:  MOVF   76,W
0B33:  MOVWF  00
0B34:  INCF   04,F
0B35:  MOVF   77,W
0B36:  MOVWF  00
....................     printf("\n less temp %ld a %ld sum %ld",temp,pid_st->maxSumError,pid_st->sumError); 
0B37:  MOVLW  0E
0B38:  ADDWF  60,W
0B39:  MOVWF  04
0B3A:  MOVF   00,W
0B3B:  MOVWF  73
0B3C:  INCF   04,F
0B3D:  MOVF   00,W
0B3E:  MOVWF  74
0B3F:  INCF   04,F
0B40:  MOVF   00,W
0B41:  MOVWF  75
0B42:  INCF   04,F
0B43:  MOVF   00,W
0B44:  MOVWF  76
0B45:  MOVLW  02
0B46:  ADDWF  60,W
0B47:  MOVWF  04
0B48:  MOVF   00,W
0B49:  MOVWF  77
0B4A:  INCF   04,F
0B4B:  MOVF   00,W
0B4C:  MOVWF  78
0B4D:  INCF   04,F
0B4E:  MOVF   00,W
0B4F:  MOVWF  79
0B50:  INCF   04,F
0B51:  MOVF   00,W
0B52:  MOVWF  7A
0B53:  CLRF   7B
0B54:  MOVF   7B,W
0B55:  BCF    0A.3
0B56:  CALL   0F9
0B57:  BSF    0A.3
0B58:  INCF   7B,F
0B59:  MOVWF  20
0B5A:  BSF    03.5
0B5B:  MOVWF  2A
0B5C:  BCF    0A.3
0B5D:  BCF    03.5
0B5E:  CALL   231
0B5F:  BSF    0A.3
0B60:  MOVLW  0C
0B61:  SUBWF  7B,W
0B62:  BTFSS  03.2
0B63:  GOTO   354
0B64:  MOVLW  41
0B65:  MOVWF  04
0B66:  MOVF   72,W
0B67:  BSF    03.5
0B68:  MOVWF  23
0B69:  BCF    03.5
0B6A:  MOVF   71,W
0B6B:  BSF    03.5
0B6C:  MOVWF  22
0B6D:  BCF    03.5
0B6E:  MOVF   70,W
0B6F:  BSF    03.5
0B70:  MOVWF  21
0B71:  BCF    03.5
0B72:  MOVF   6F,W
0B73:  BSF    03.5
0B74:  MOVWF  20
0B75:  BCF    0A.3
0B76:  BCF    03.5
0B77:  CALL   4A2
0B78:  BSF    0A.3
0B79:  MOVLW  20
0B7A:  BSF    03.5
0B7B:  MOVWF  2A
0B7C:  BCF    0A.3
0B7D:  BCF    03.5
0B7E:  CALL   231
0B7F:  BSF    0A.3
0B80:  MOVLW  61
0B81:  BSF    03.5
0B82:  MOVWF  2A
0B83:  BCF    0A.3
0B84:  BCF    03.5
0B85:  CALL   231
0B86:  BSF    0A.3
0B87:  MOVLW  20
0B88:  BSF    03.5
0B89:  MOVWF  2A
0B8A:  BCF    0A.3
0B8B:  BCF    03.5
0B8C:  CALL   231
0B8D:  BSF    0A.3
0B8E:  MOVLW  41
0B8F:  MOVWF  04
0B90:  MOVF   76,W
0B91:  BSF    03.5
0B92:  MOVWF  23
0B93:  BCF    03.5
0B94:  MOVF   75,W
0B95:  BSF    03.5
0B96:  MOVWF  22
0B97:  BCF    03.5
0B98:  MOVF   74,W
0B99:  BSF    03.5
0B9A:  MOVWF  21
0B9B:  BCF    03.5
0B9C:  MOVF   73,W
0B9D:  BSF    03.5
0B9E:  MOVWF  20
0B9F:  BCF    0A.3
0BA0:  BCF    03.5
0BA1:  CALL   4A2
0BA2:  BSF    0A.3
0BA3:  MOVLW  15
0BA4:  MOVWF  7C
0BA5:  MOVF   7C,W
0BA6:  BCF    0A.3
0BA7:  CALL   0F9
0BA8:  BSF    0A.3
0BA9:  INCF   7C,F
0BAA:  MOVWF  20
0BAB:  BSF    03.5
0BAC:  MOVWF  2A
0BAD:  BCF    0A.3
0BAE:  BCF    03.5
0BAF:  CALL   231
0BB0:  BSF    0A.3
0BB1:  MOVLW  1A
0BB2:  SUBWF  7C,W
0BB3:  BTFSS  03.2
0BB4:  GOTO   3A5
0BB5:  MOVLW  41
0BB6:  MOVWF  04
0BB7:  MOVF   7A,W
0BB8:  BSF    03.5
0BB9:  MOVWF  23
0BBA:  BCF    03.5
0BBB:  MOVF   79,W
0BBC:  BSF    03.5
0BBD:  MOVWF  22
0BBE:  BCF    03.5
0BBF:  MOVF   78,W
0BC0:  BSF    03.5
0BC1:  MOVWF  21
0BC2:  BCF    03.5
0BC3:  MOVF   77,W
0BC4:  BSF    03.5
0BC5:  MOVWF  20
0BC6:  BCF    0A.3
0BC7:  BCF    03.5
0BC8:  CALL   4A2
0BC9:  BSF    0A.3
....................  
....................   } 
....................   else{ 
0BCA:  GOTO   4E1
....................     pid_st->sumError = temp; 
0BCB:  MOVLW  02
0BCC:  ADDWF  60,W
0BCD:  MOVWF  04
0BCE:  MOVF   6F,W
0BCF:  MOVWF  00
0BD0:  INCF   04,F
0BD1:  MOVF   70,W
0BD2:  MOVWF  00
0BD3:  INCF   04,F
0BD4:  MOVF   71,W
0BD5:  MOVWF  00
0BD6:  INCF   04,F
0BD7:  MOVF   72,W
0BD8:  MOVWF  00
....................     i_term = pid_st->I_Factor * pid_st->sumError; 
0BD9:  MOVLW  08
0BDA:  ADDWF  60,W
0BDB:  MOVWF  04
0BDC:  INCF   04,F
0BDD:  MOVF   00,W
0BDE:  MOVWF  74
0BDF:  DECF   04,F
0BE0:  MOVF   00,W
0BE1:  MOVWF  73
0BE2:  MOVLW  02
0BE3:  ADDWF  60,W
0BE4:  MOVWF  04
0BE5:  MOVF   00,W
0BE6:  MOVWF  20
0BE7:  INCF   04,F
0BE8:  MOVF   00,W
0BE9:  MOVWF  21
0BEA:  INCF   04,F
0BEB:  MOVF   00,W
0BEC:  MOVWF  22
0BED:  INCF   04,F
0BEE:  MOVF   00,W
0BEF:  MOVWF  23
0BF0:  MOVLW  FD
0BF1:  ADDWF  04,F
0BF2:  MOVF   23,W
0BF3:  MOVWF  78
0BF4:  MOVF   22,W
0BF5:  MOVWF  77
0BF6:  MOVF   21,W
0BF7:  MOVWF  76
0BF8:  MOVF   20,W
0BF9:  MOVWF  75
0BFA:  MOVF   04,W
0BFB:  MOVWF  79
0BFC:  CLRF   7D
0BFD:  CLRF   7C
0BFE:  MOVF   74,W
0BFF:  MOVWF  7B
0C00:  MOVF   73,W
0C01:  MOVWF  7A
0C02:  MOVF   78,W
0C03:  BSF    03.5
0C04:  MOVWF  23
0C05:  BCF    03.5
0C06:  MOVF   77,W
0C07:  BSF    03.5
0C08:  MOVWF  22
0C09:  BCF    03.5
0C0A:  MOVF   76,W
0C0B:  BSF    03.5
0C0C:  MOVWF  21
0C0D:  BCF    03.5
0C0E:  MOVF   75,W
0C0F:  BSF    03.5
0C10:  MOVWF  20
*
0C43:  BCF    03.5
0C44:  MOVF   79,W
0C45:  MOVWF  04
0C46:  MOVF   23,W
0C47:  MOVWF  6A
0C48:  MOVF   22,W
0C49:  MOVWF  69
0C4A:  MOVF   21,W
0C4B:  MOVWF  68
0C4C:  MOVF   20,W
0C4D:  MOVWF  67
....................     printf("\n eror temp %ld a %ld sum %ld",temp,pid_st->maxSumError,pid_st->sumError); 
0C4E:  MOVLW  0E
0C4F:  ADDWF  60,W
0C50:  MOVWF  04
0C51:  MOVF   00,W
0C52:  MOVWF  73
0C53:  INCF   04,F
0C54:  MOVF   00,W
0C55:  MOVWF  74
0C56:  INCF   04,F
0C57:  MOVF   00,W
0C58:  MOVWF  75
0C59:  INCF   04,F
0C5A:  MOVF   00,W
0C5B:  MOVWF  76
0C5C:  MOVLW  02
0C5D:  ADDWF  60,W
0C5E:  MOVWF  04
0C5F:  MOVF   00,W
0C60:  MOVWF  77
0C61:  INCF   04,F
0C62:  MOVF   00,W
0C63:  MOVWF  78
0C64:  INCF   04,F
0C65:  MOVF   00,W
0C66:  MOVWF  79
0C67:  INCF   04,F
0C68:  MOVF   00,W
0C69:  MOVWF  7A
0C6A:  CLRF   7B
0C6B:  MOVF   7B,W
0C6C:  BCF    0A.3
0C6D:  CALL   120
0C6E:  BSF    0A.3
0C6F:  INCF   7B,F
0C70:  MOVWF  20
0C71:  BSF    03.5
0C72:  MOVWF  2A
0C73:  BCF    0A.3
0C74:  BCF    03.5
0C75:  CALL   231
0C76:  BSF    0A.3
0C77:  MOVLW  0C
0C78:  SUBWF  7B,W
0C79:  BTFSS  03.2
0C7A:  GOTO   46B
0C7B:  MOVLW  41
0C7C:  MOVWF  04
0C7D:  MOVF   72,W
0C7E:  BSF    03.5
0C7F:  MOVWF  23
0C80:  BCF    03.5
0C81:  MOVF   71,W
0C82:  BSF    03.5
0C83:  MOVWF  22
0C84:  BCF    03.5
0C85:  MOVF   70,W
0C86:  BSF    03.5
0C87:  MOVWF  21
0C88:  BCF    03.5
0C89:  MOVF   6F,W
0C8A:  BSF    03.5
0C8B:  MOVWF  20
0C8C:  BCF    0A.3
0C8D:  BCF    03.5
0C8E:  CALL   4A2
0C8F:  BSF    0A.3
0C90:  MOVLW  20
0C91:  BSF    03.5
0C92:  MOVWF  2A
0C93:  BCF    0A.3
0C94:  BCF    03.5
0C95:  CALL   231
0C96:  BSF    0A.3
0C97:  MOVLW  61
0C98:  BSF    03.5
0C99:  MOVWF  2A
0C9A:  BCF    0A.3
0C9B:  BCF    03.5
0C9C:  CALL   231
0C9D:  BSF    0A.3
0C9E:  MOVLW  20
0C9F:  BSF    03.5
0CA0:  MOVWF  2A
0CA1:  BCF    0A.3
0CA2:  BCF    03.5
0CA3:  CALL   231
0CA4:  BSF    0A.3
0CA5:  MOVLW  41
0CA6:  MOVWF  04
0CA7:  MOVF   76,W
0CA8:  BSF    03.5
0CA9:  MOVWF  23
0CAA:  BCF    03.5
0CAB:  MOVF   75,W
0CAC:  BSF    03.5
0CAD:  MOVWF  22
0CAE:  BCF    03.5
0CAF:  MOVF   74,W
0CB0:  BSF    03.5
0CB1:  MOVWF  21
0CB2:  BCF    03.5
0CB3:  MOVF   73,W
0CB4:  BSF    03.5
0CB5:  MOVWF  20
0CB6:  BCF    0A.3
0CB7:  BCF    03.5
0CB8:  CALL   4A2
0CB9:  BSF    0A.3
0CBA:  MOVLW  15
0CBB:  MOVWF  7C
0CBC:  MOVF   7C,W
0CBD:  BCF    0A.3
0CBE:  CALL   120
0CBF:  BSF    0A.3
0CC0:  INCF   7C,F
0CC1:  MOVWF  20
0CC2:  BSF    03.5
0CC3:  MOVWF  2A
0CC4:  BCF    0A.3
0CC5:  BCF    03.5
0CC6:  CALL   231
0CC7:  BSF    0A.3
0CC8:  MOVLW  1A
0CC9:  SUBWF  7C,W
0CCA:  BTFSS  03.2
0CCB:  GOTO   4BC
0CCC:  MOVLW  41
0CCD:  MOVWF  04
0CCE:  MOVF   7A,W
0CCF:  BSF    03.5
0CD0:  MOVWF  23
0CD1:  BCF    03.5
0CD2:  MOVF   79,W
0CD3:  BSF    03.5
0CD4:  MOVWF  22
0CD5:  BCF    03.5
0CD6:  MOVF   78,W
0CD7:  BSF    03.5
0CD8:  MOVWF  21
0CD9:  BCF    03.5
0CDA:  MOVF   77,W
0CDB:  BSF    03.5
0CDC:  MOVWF  20
0CDD:  BCF    0A.3
0CDE:  BCF    03.5
0CDF:  CALL   4A2
0CE0:  BSF    0A.3
....................  
....................   } 
....................  
....................   // Calculate Dterm 
....................   d_term = pid_st->D_Factor * (pid_st->lastProcessValue - processValue); 
0CE1:  MOVLW  0A
0CE2:  ADDWF  60,W
0CE3:  MOVWF  04
0CE4:  INCF   04,F
0CE5:  MOVF   00,W
0CE6:  MOVWF  74
0CE7:  DECF   04,F
0CE8:  MOVF   00,W
0CE9:  MOVWF  73
0CEA:  MOVF   60,W
0CEB:  MOVWF  04
0CEC:  INCF   04,F
0CED:  MOVF   00,W
0CEE:  MOVWF  76
0CEF:  DECF   04,F
0CF0:  MOVF   00,W
0CF1:  MOVWF  75
0CF2:  MOVF   5E,W
0CF3:  SUBWF  75,W
0CF4:  MOVWF  20
0CF5:  MOVF   76,W
0CF6:  MOVWF  23
0CF7:  MOVF   5F,W
0CF8:  BTFSS  03.0
0CF9:  INCFSZ 5F,W
0CFA:  SUBWF  23,F
0CFB:  MOVF   20,W
0CFC:  MOVWF  77
0CFD:  MOVF   23,W
0CFE:  MOVWF  78
0CFF:  MOVF   74,W
0D00:  MOVWF  7A
0D01:  MOVF   73,W
0D02:  MOVWF  79
0D03:  MOVF   78,W
0D04:  MOVWF  7C
0D05:  MOVF   77,W
0D06:  MOVWF  7B
0D07:  BCF    0A.3
0D08:  CALL   48D
0D09:  BSF    0A.3
0D0A:  MOVF   21,W
0D0B:  MOVWF  65
0D0C:  MOVF   22,W
0D0D:  MOVWF  66
....................  
....................   pid_st->lastProcessValue = processValue; 
0D0E:  MOVF   60,W
0D0F:  MOVWF  04
0D10:  INCF   04,F
0D11:  MOVF   5F,W
0D12:  MOVWF  00
0D13:  DECF   04,F
0D14:  MOVF   5E,W
0D15:  MOVWF  00
....................  
....................   //ret = (p_term + i_term + d_term) / SCALING_FACTOR; 
....................    ret = (p_term+d_term+i_term) / SCALING_FACTOR; 
0D16:  MOVF   65,W
0D17:  ADDWF  63,W
0D18:  MOVWF  73
0D19:  MOVF   64,W
0D1A:  MOVWF  74
0D1B:  MOVF   66,W
0D1C:  BTFSC  03.0
0D1D:  INCFSZ 66,W
0D1E:  ADDWF  74,F
0D1F:  MOVF   73,W
0D20:  ADDWF  67,W
0D21:  MOVWF  75
0D22:  MOVF   68,W
0D23:  MOVWF  76
0D24:  MOVF   74,W
0D25:  BTFSC  03.0
0D26:  INCFSZ 74,W
0D27:  ADDWF  76,F
0D28:  MOVF   69,W
0D29:  MOVWF  77
0D2A:  MOVLW  00
0D2B:  BTFSC  03.0
0D2C:  MOVLW  01
0D2D:  ADDWF  77,F
0D2E:  MOVF   6A,W
0D2F:  MOVWF  78
0D30:  MOVLW  00
0D31:  BTFSC  03.0
0D32:  MOVLW  01
0D33:  ADDWF  78,F
0D34:  MOVF   78,W
0D35:  MOVWF  6E
0D36:  MOVF   77,W
0D37:  MOVWF  6D
0D38:  MOVF   76,W
0D39:  MOVWF  6C
0D3A:  MOVF   75,W
0D3B:  MOVWF  6B
....................   if(ret > MAX_INT){ 
0D3C:  BTFSC  6E.7
0D3D:  GOTO   54F
0D3E:  MOVF   6E,F
0D3F:  BTFSS  03.2
0D40:  GOTO   548
0D41:  MOVF   6D,F
0D42:  BTFSS  03.2
0D43:  GOTO   548
0D44:  MOVF   6C,W
0D45:  SUBLW  7F
0D46:  BTFSC  03.0
0D47:  GOTO   54F
....................     ret = MAX_INT; 
0D48:  CLRF   6E
0D49:  CLRF   6D
0D4A:  MOVLW  7F
0D4B:  MOVWF  6C
0D4C:  MOVLW  FF
0D4D:  MOVWF  6B
....................   } 
....................   else if(ret < -MAX_INT){ 
0D4E:  GOTO   56E
0D4F:  BTFSS  6E.7
0D50:  GOTO   56E
0D51:  MOVF   6E,W
0D52:  SUBLW  FF
0D53:  BTFSS  03.0
0D54:  GOTO   56E
0D55:  BTFSS  03.2
0D56:  GOTO   567
0D57:  MOVF   6D,W
0D58:  SUBLW  FF
0D59:  BTFSS  03.0
0D5A:  GOTO   56E
0D5B:  BTFSS  03.2
0D5C:  GOTO   567
0D5D:  MOVF   6C,W
0D5E:  SUBLW  80
0D5F:  BTFSS  03.0
0D60:  GOTO   56E
0D61:  BTFSS  03.2
0D62:  GOTO   567
0D63:  MOVF   6B,W
0D64:  SUBLW  00
0D65:  BTFSS  03.0
0D66:  GOTO   56E
....................     ret = -MAX_INT; 
0D67:  MOVLW  FF
0D68:  MOVWF  6E
0D69:  MOVWF  6D
0D6A:  MOVLW  80
0D6B:  MOVWF  6C
0D6C:  MOVLW  01
0D6D:  MOVWF  6B
....................   } 
....................  
....................   return((int16)ret); 
0D6E:  MOVF   6B,W
0D6F:  MOVWF  21
0D70:  MOVF   6C,W
0D71:  MOVWF  22
.................... } 
0D72:  BCF    0A.3
0D73:  GOTO   659 (RETURN)
....................  
.................... /*! \brief Resets the integrator. 
....................  * 
....................  *  Calling this function will reset the integrator in the PID regulator. 
....................  */ 
.................... void pid_Reset_Integrator(pidData_t *pid_st) 
.................... { 
....................   pid_st->sumError = 0; 
.................... } 
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 373A   HS NOWDT NOPUT DEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
