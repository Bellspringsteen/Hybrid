CCS PCM C Compiler, Version 4.084, 46530               01-Dec-12 15:22

               Filename: HondaHybrid.lst

               ROM used: 669 words (17%)
                         Largest free fragment is 1788
               RAM used: 58 (32%) at main() level
                         80 (45%) worst case
               Stack:    3 worst case (2 in main + 1 for interrupts)

*
0000:  NOP
0001:  MOVLW  00
0002:  MOVWF  0A
0003:  GOTO   1C3
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  26
0008:  MOVF   7F,W
0009:  MOVWF  25
000A:  MOVF   0A,W
000B:  MOVWF  2D
000C:  CLRF   0A
000D:  SWAPF  25,F
000E:  MOVF   04,W
000F:  MOVWF  27
0010:  MOVF   20,W
0011:  MOVWF  28
0012:  MOVF   21,W
0013:  MOVWF  29
0014:  MOVF   22,W
0015:  MOVWF  2A
0016:  MOVF   23,W
0017:  MOVWF  2B
0018:  MOVF   24,W
0019:  MOVWF  2C
001A:  BCF    03.7
001B:  BCF    03.5
001C:  MOVLW  8C
001D:  MOVWF  04
001E:  BTFSS  00.0
001F:  GOTO   022
0020:  BTFSC  0C.0
0021:  GOTO   03F
0022:  MOVLW  8D
0023:  MOVWF  04
0024:  BTFSS  00.0
0025:  GOTO   028
0026:  BTFSC  0D.0
0027:  GOTO   041
0028:  BTFSS  0B.5
0029:  GOTO   02C
002A:  BTFSC  0B.2
002B:  GOTO   043
002C:  MOVF   27,W
002D:  MOVWF  04
002E:  MOVF   28,W
002F:  MOVWF  20
0030:  MOVF   29,W
0031:  MOVWF  21
0032:  MOVF   2A,W
0033:  MOVWF  22
0034:  MOVF   2B,W
0035:  MOVWF  23
0036:  MOVF   2C,W
0037:  MOVWF  24
0038:  MOVF   2D,W
0039:  MOVWF  0A
003A:  SWAPF  26,W
003B:  MOVWF  03
003C:  SWAPF  7F,F
003D:  SWAPF  7F,W
003E:  RETFIE
003F:  BCF    0A.3
0040:  GOTO   051
0041:  BCF    0A.3
0042:  GOTO   099
0043:  BCF    0A.3
0044:  GOTO   045
.................... #include "HondaHybrid.h" 
.................... #include <16F873A.h> 
.................... //////// Standard Header file for the PIC16F873A device //////////////// 
.................... #device PIC16F873A 
.................... #list 
....................  
....................  
.................... //#include <16F737.h> 
.................... #device ICD=TRUE 
.................... #device adc=10 
.................... //#device adc=8 
.................... #use delay(clock=20000000) 
.................... #fuses HS,PUT,NOWDT 
.................... #use rs232 (DEBUGGER) 
.................... #include <mcp4921.c> 
.................... //////////////// Driver for MCP4921 D/A Converter /////////////////////// 
.................... ////                                                                 //// 
.................... ////  init_dac()    Call this before using a MCP4921 DAC             //// 
.................... ////                                                                 //// 
.................... ////  write_dac( long int )   Writes command and 12 bit resolution   //// 
.................... ////                          to the MCP4921 which converts it to a  //// 
.................... ////                          voltage                                //// 
.................... ////                          0-4095 input represents 0-vref V out.  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SELECT 
....................  
.................... #define DAC_CS     PIN_C4 
.................... #define DAC_CLK    PIN_C3 
.................... #define DAC_DI     PIN_C5 
.................... #define DAC_LDAC   PIN_B4 
....................  
.................... #endif 
....................  
.................... void init_dac() 
.................... { 
....................    output_high(DAC_CS); 
*
00A4:  BCF    2E.4
00A5:  MOVF   2E,W
00A6:  BSF    03.5
00A7:  MOVWF  07
00A8:  BCF    03.5
00A9:  BSF    07.4
....................    output_high(DAC_LDAC); 
00AA:  BSF    03.5
00AB:  BCF    06.4
00AC:  BCF    03.5
00AD:  BSF    06.4
....................    output_high(DAC_CLK); 
00AE:  BCF    2E.3
00AF:  MOVF   2E,W
00B0:  BSF    03.5
00B1:  MOVWF  07
00B2:  BCF    03.5
00B3:  BSF    07.3
....................    output_high(DAC_DI); 
00B4:  BCF    2E.5
00B5:  MOVF   2E,W
00B6:  BSF    03.5
00B7:  MOVWF  07
00B8:  BCF    03.5
00B9:  BSF    07.5
.................... } 
00BA:  BCF    0A.3
00BB:  GOTO   210 (RETURN)
....................  
.................... void write_dac(int16 data) { 
....................    BYTE cmd[3]; 
....................    BYTE i; 
....................  
....................    cmd[0]=data; 
....................    cmd[1]=(data>>8); 
....................    cmd[2]=0x03;                            
....................     
....................    output_high(DAC_LDAC); 
....................    output_low(DAC_CLK); 
....................    output_low(DAC_CS); 
....................  
....................    for(i=0; i<=23; ++i) 
....................    { 
....................       if(i<4 || (i>7 && i<12)) 
....................          shift_left(cmd,3,0); 
....................       else 
....................       { 
....................          output_bit(DAC_DI, shift_left(cmd,3,0)); 
....................  
....................          output_high(DAC_CLK); 
....................          output_low(DAC_CLK); 
....................       } 
....................    } 
....................    output_high(DAC_CS); 
....................  
....................    output_low(DAC_LDAC); 
....................    delay_us(10); 
....................     
....................    output_HIGH(DAC_LDAC); 
.................... } 
....................  
....................  
....................  
.................... #include "pid.h" 
.................... /*This file has been prepared for Doxygen automatic documentation generation.*/ 
.................... /*! \file ********************************************************************* 
....................  * 
....................  * \brief Header file for pid.c. 
....................  * 
....................  * - File:               pid.h 
....................  * - Compiler:           IAR EWAAVR 4.11A 
....................  * - Supported devices:  All AVR devices can be used. 
....................  * - AppNote:            AVR221 - Discrete PID controller 
....................  * 
....................  * \author               Atmel Corporation: http://www.atmel.com \n 
....................  *                       Support email: avr@atmel.com 
....................  * 
....................  * $Name$ 
....................  * $Revision: 456 $ 
....................  * $RCSfile$ 
....................  * $Date: 2006-02-16 12:46:13 +0100 (to, 16 feb 2006) $ 
....................  *****************************************************************************/ 
....................  
.................... #ifndef PID_H 
.................... #define PID_H 
....................  
.................... //#include "stdint.h" 
.................... #define INT16_MAX 32767 
.................... #define INT32_MAX 2147483647 
.................... #define SCALING_FACTOR  128 
....................  
.................... /*! \brief PID Status 
....................  * 
....................  * Setpoints and data used by the PID control algorithm 
....................  */ 
.................... typedef struct PID_DATA{ 
....................   //! Last process value, used to find derivative of process value. 
....................   int16 lastProcessValue; 
....................   //! Summation of errors, used for integrate calculations 
....................   int32 sumError; 
....................   //! The Proportional tuning constant, multiplied with SCALING_FACTOR 
....................   int16 P_Factor; 
....................   //! The Integral tuning constant, multiplied with SCALING_FACTOR 
....................   int16 I_Factor; 
....................   //! The Derivative tuning constant, multiplied with SCALING_FACTOR 
....................   int16 D_Factor; 
....................   //! Maximum allowed error, avoid overflow 
....................   int16 maxError; 
....................   //! Maximum allowed sumerror, avoid overflow 
....................   int32 maxSumError; 
.................... } pidData_t; 
....................  
.................... /*! \brief Maximum values 
....................  * 
....................  * Needed to avoid sign/overflow problems 
....................  */ 
.................... // Maximum value of variables 
.................... #define MAX_INT         INT16_MAX 
.................... #define MAX_LONG        INT32_MAX 
.................... #define MAX_I_TERM      (MAX_LONG / 2) 
....................  
.................... // Boolean values 
.................... #define FALSE           0 
.................... #define TRUE            1 
....................  
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid); 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st); 
.................... void pid_Reset_Integrator(pidData_t *pid_st); 
....................  
.................... #endif 
....................  
.................... /* 
.................... This is the main controller for the super capacitor hybrid scooter a.k.a RED 
.................... B2 close contactor 
.................... CONTROL BOX INPUTS 
.................... Athrottle- A0 - analog input representing the users input for speed, 10 bit 
.................... Vspeed - CCp2-a 16 bit representation of the speed of the vehicle 
.................... Acaps- A1 - analog input representing the current voltage of the supercapacitors, 10 bit 
....................  
.................... CONTROL BOX OUTPUT 
.................... ICEthrottle- B1 - a 16 bit number sent to the internal combustion engine(ICE) throttle  
.................... ELECthrottle-  - a 16 bit number sent as analog value representing the demanded electric power 
....................  
.................... SPECIFICS OF I/O 
....................  
.................... Athrottle - the electric throttle is a 3 wire unit with a 5 volt,ground, and analog out 
....................    representing how far throttle is turned. Pin AN0 is the input. 
....................     
.................... Vspeed - There is a encoder in the rear wheel/electric motor that is used by the electric 
....................    power controller. Tapping in to this this Main Controller receives a 5 Volt square wave 
....................    with 42 pulses. There are two options for measuring speed. The first is to measure the  
....................    length of the pulses. The second is to measure the rate of pulses. This controller currently 
....................    uses the rate method. The int_ccp2 interupt is called on each falling edge and stores the  
....................    Vspeed value as the max number of 16bit (65535-timer0_since_last_reset).  
....................     
....................    The RED scooter has a circumpherence of 16.3*2*pi = 102.4 
....................    X m/h * 63360 inch/mile * 1/3600 h/sec * 1/(102.4 inch/rev) = .171875* X 
....................    Examples 50 mph is 8.9 ms 1 overflow of timer0 
....................    Example 5 mph is 89 ms or 13 time overflow 
....................     
....................    #int_timer0 increments the counter number_of_overflows each time it overflows 
....................    On int ccp2 we multiply number_of_overflows * 256 + timer0 to get timer0_since_last_reset 
....................     
.................... Acaps - the analog voltage which is the 5volt representation of the voltage in the caps which 
....................    have a value of between 0-48v. The voltages are factored so that the voltage on AN1 goes 
....................    from 0 - 4.8 volts (TODO check this factor, think its 1/11 not 1/10) 
....................     
.................... ICEthrottle -  #int_timer1 is set to make sure the period follows the required below 
....................    The period for the servo is .020 seconds which is 50,000 operations 
....................    The leftmost position of the server is .001 seconds which is 2,500 
....................    The rightmost position of the server is .002 seconds which is 5,000 
....................     
....................    The output pin is pin_B1.-> 
....................  
.................... ELECthrottle 
....................    The electric power controller takes an analog voltage as input. The output voltage 
....................    is set by the DAC. The pins used are C3,C4,C5. if CHARGING_STATE is true then  
....................     
.................... ALGORITHM 
....................    The algorithm is basically a PID controller. In broad terms we are trying to set the 
....................    ICEthrottle and ICEelectric to maximize the use of electric and accelerate to meet the 
....................    requirements set by the rider with the Athrottle signal. When the demanded power is  
....................    less than the power output possible by the ICE and the caps are in the CHARGING_STATE  
....................    then the ICE is turned up to the max and the ELECthrottle is set to regen to 
....................    charge the capacitors.If CHARGING_STATE is false then the caps are supplying the drivig power 
....................    and the ICE is set to "off", the caps supply the power. Unless the user requested supply 
....................    is enough to require both power sources. 
....................     
....................    If CHARGING_STATE is true. Then pin_b2 is set as high which will close the brake number 
....................    for the electric power controller.  
....................     
....................    If CHARGING_STATE is false then the pin_b2 is set low which opens brake. 
....................     
....................     
....................  
....................  
.................... The encoder has 42 on and offs per rotation, i.e. 21 steps 
....................  
.................... Number of operations per second is CLOCK/4/Timer Divisions 
.................... Number of operations per second is 20,000,000/4/128 = 39062.5  
.................... Each operation takes 1/39062.5 = .256 micro (x10^-6) seconds 
.................... Seconds to Overflow timer0 8bit timer = .256x10^-6 * 256 = 6.55ms 
....................  
....................  
....................  
.................... */ 
.................... #define servo_pin PIN_B1  //Setting servo out pin to be hardware pin b1 
.................... #define ADC_DELAY delay_us(20) 
.................... #define Acaps_pin PIN_A1 
.................... #define Acaps_channel 1 
.................... #define Athrottle_pin PIN_A0  //Voltage goes from 1.5 (306)to 4.1(836) 
.................... #define Athrottle_Min 306 
.................... #define Athrottle_Max 836 
.................... #define Athrottle_Full Athrottle_Max-Athrottle_Min 
.................... #define Athrottle_channel 0 
.................... #define Electric_Controller_Switch PIN_B0 
.................... #define Contactor_Switch PIN_B2 
....................  
.................... //PID Values 
.................... #define K_P 1.00 
.................... #define K_I 1.00 
.................... #define K_D 0.00 
....................  
.................... int1 pid_Timer = 0; 
*
01D4:  BCF    2F.0
.................... struct PID_DATA pidData; 
.................... #define TIME_INTERVAL 157 //TODO replace 
....................  
.................... #define left_position 3950 
.................... #define right_position 4800 
.................... #define servo_difference  right_position-left_position 
.................... #define servo_period   65356-50000 
.................... unsigned int16 current_servo_position=2500; 
01D5:  MOVLW  C4
01D6:  MOVWF  42
01D7:  MOVLW  09
01D8:  MOVWF  43
.................... int1 SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0; 
01D9:  BCF    2F.1
.................... int1 test_boolean = 0; 
01DA:  BCF    2F.2
....................  
.................... int1 test_switch = 0; 
01DB:  BCF    2F.3
.................... unsigned int16 test_counter = 0; 
01DC:  CLRF   44
01DD:  CLRF   45
....................  
.................... unsigned int8 number_of_timer0_interupts_since_reset =0; 
01DE:  CLRF   46
.................... unsigned int16 timer0_since_last_reset= 0; 
01DF:  CLRF   47
01E0:  CLRF   48
.................... unsigned int16 vSpeed= 255; 
01E1:  MOVLW  FF
01E2:  MOVWF  49
01E3:  CLRF   4A
.................... unsigned int16 ELECthrottle = 0; 
01E4:  CLRF   4B
01E5:  CLRF   4C
.................... unsigned int16 ICEthrottle = 0; 
01E6:  CLRF   4D
01E7:  CLRF   4E
.................... unsigned int16 Athrottle = 0; 
01E8:  CLRF   4F
01E9:  CLRF   50
.................... unsigned int16 Acaps = 0; 
01EA:  CLRF   51
01EB:  CLRF   52
.................... int1 CURRENTLY_CHARGING = 0; 
01EC:  BCF    2F.4
....................  
.................... /* 
.................... The #int_timer0 interupt is triggered on each timer0 8bit interupt 
.................... the function simply increments a overflow counter to be used by the ccp2 
.................... interupt to calculate speed 
.................... NUMBER OF OPERATIONS =  
.................... */ 
.................... #int_timer0 
.................... void timer0_isr(){ 
....................    if (number_of_timer0_interupts_since_reset!=255){ 
*
0045:  INCFSZ 46,W
0046:  GOTO   048
0047:  GOTO   04A
....................       number_of_timer0_interupts_since_reset++; 
0048:  INCF   46,F
....................       //current_servo_position=current_servo_position+1; 
....................        
....................    } 
....................    else { 
0049:  GOTO   04E
....................       vSpeed = 255; 
004A:  CLRF   4A
004B:  MOVLW  FF
004C:  MOVWF  49
....................       number_of_timer0_interupts_since_reset=0; 
004D:  CLRF   46
....................        
....................        
....................    } 
.................... } 
....................  
.................... /* 
.................... #int_timer1 is used by the ICEservo throttle to regulate the timing pulses. The  
.................... timer is setup for a pulsetrain of 20ms period. This is done as follows, 
....................  
.................... Period is 1/(CLOCK/4opsperclock)*(startingPostionOfClock) = 20 ms 
.................... for this setup 1/(20000000/4)*(50000) = 20 ms 
....................  
.................... The timer1 starts at 0 and counts up. So we set the beggining of the clock at 
.................... servo_period which is 65356-50000 so that the total time is 20ms. 
.................... */ 
004E:  BCF    0B.2
004F:  BCF    0A.3
0050:  GOTO   02C
.................... #int_timer1 
.................... void isr() 
.................... { 
....................  
.................... //Make sure that the position is within the left and right positions of the servo 
....................    if (current_servo_position<left_position){ 
0051:  MOVF   43,W
0052:  SUBLW  0F
0053:  BTFSS  03.0
0054:  GOTO   060
0055:  BTFSS  03.2
0056:  GOTO   05B
0057:  MOVF   42,W
0058:  SUBLW  6D
0059:  BTFSS  03.0
005A:  GOTO   060
....................       current_servo_position = left_position; 
005B:  MOVLW  0F
005C:  MOVWF  43
005D:  MOVLW  6E
005E:  MOVWF  42
....................    } 
....................    else if (current_servo_position > right_position){ 
005F:  GOTO   06F
0060:  MOVF   43,W
0061:  SUBLW  11
0062:  BTFSC  03.0
0063:  GOTO   06F
0064:  XORLW  FF
0065:  BTFSS  03.2
0066:  GOTO   06B
0067:  MOVF   42,W
0068:  SUBLW  C0
0069:  BTFSC  03.0
006A:  GOTO   06F
....................       current_servo_position = left_position; 
006B:  MOVLW  0F
006C:  MOVWF  43
006D:  MOVLW  6E
006E:  MOVWF  42
....................    } 
....................  
....................    if(SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER) 
006F:  BTFSS  2F.1
0070:  GOTO   084
....................       {  
....................          output_high(servo_pin);        //Set the servo control pin to high  
0071:  BSF    03.5
0072:  BCF    06.1
0073:  BCF    03.5
0074:  BSF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0;  
0075:  BCF    2F.1
....................          set_timer1(65356-current_servo_position); //Set timer for the position high pulse 
0076:  MOVF   42,W
0077:  SUBLW  4C
0078:  MOVWF  6D
0079:  MOVLW  FF
007A:  MOVWF  6E
007B:  MOVF   43,W
007C:  BTFSS  03.0
007D:  INCFSZ 43,W
007E:  SUBWF  6E,F
007F:  MOVF   6E,W
0080:  MOVWF  0F
0081:  MOVF   6D,W
0082:  MOVWF  0E
....................       }  
....................    else  
0083:  GOTO   096
....................       {  
....................          output_low(servo_pin);                      // Set the servo control pin to low   
0084:  BSF    03.5
0085:  BCF    06.1
0086:  BCF    03.5
0087:  BCF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 1;  
0088:  BSF    2F.1
....................          set_timer1(servo_period+current_servo_position);          //Set timer for the low position the length is the difference between  
0089:  MOVLW  FC
008A:  ADDWF  42,W
008B:  MOVWF  6D
008C:  MOVF   43,W
008D:  MOVWF  6E
008E:  MOVLW  3B
008F:  BTFSC  03.0
0090:  MOVLW  3C
0091:  ADDWF  6E,F
0092:  MOVF   6E,W
0093:  MOVWF  0F
0094:  MOVF   6D,W
0095:  MOVWF  0E
....................                                                      //the total int16 lenght - high pulse length 
....................       }   
.................... } 
....................  
....................  
.................... /* 
.................... #int_ccp2 is called on the falling edge of the encoder pulse. We calculate the time 
.................... between pulses.  
.................... TODO will have to put some kind of smoothing mechanism 
.................... */ 
0096:  BCF    0C.0
0097:  BCF    0A.3
0098:  GOTO   02C
.................... #int_ccp2 
.................... void isr2() 
.................... { 
.................... if (number_of_timer0_interupts_since_reset>20){ 
0099:  MOVF   46,W
009A:  SUBLW  14
009B:  BTFSC  03.0
009C:  GOTO   0A1
.................... vSpeed  = number_of_timer0_interupts_since_reset; 
009D:  CLRF   4A
009E:  MOVF   46,W
009F:  MOVWF  49
.................... number_of_timer0_interupts_since_reset = 0; 
00A0:  CLRF   46
.................... } 
.................... } 
....................  
....................  
....................  
....................  
00A1:  BCF    0D.0
00A2:  BCF    0A.3
00A3:  GOTO   02C
.................... void main() 
.................... {   
*
01C3:  CLRF   04
01C4:  MOVLW  1F
01C5:  ANDWF  03,F
01C6:  BSF    03.5
01C7:  BCF    06.3
01C8:  BCF    03.5
01C9:  BSF    06.3
01CA:  BSF    03.5
01CB:  BSF    1F.0
01CC:  BSF    1F.1
01CD:  BSF    1F.2
01CE:  BCF    1F.3
01CF:  MOVLW  07
01D0:  MOVWF  1C
....................     
....................    setup_adc_ports(NO_ANALOGS); 
*
01ED:  BSF    03.5
01EE:  BSF    1F.0
01EF:  BSF    1F.1
01F0:  BSF    1F.2
01F1:  BCF    1F.3
....................    setup_adc(ADC_OFF); 
01F2:  BCF    03.5
01F3:  BCF    1F.0
....................    setup_spi(FALSE); 
01F4:  CLRF   14
....................     
....................    setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
01F5:  BSF    03.5
01F6:  MOVF   01,W
01F7:  ANDLW  C0
01F8:  IORLW  00
01F9:  MOVWF  01
01FA:  CLRWDT
....................    setup_timer_1(T1_DISABLED); 
01FB:  BCF    03.5
01FC:  CLRF   10
....................    setup_timer_2(T2_DISABLED,0,1); 
01FD:  MOVLW  00
01FE:  MOVWF  21
01FF:  MOVWF  12
0200:  MOVLW  00
0201:  BSF    03.5
0202:  MOVWF  12
....................    setup_port_a(ALL_ANALOG); 
0203:  BCF    1F.0
0204:  BCF    1F.1
0205:  BCF    1F.2
0206:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
0207:  BCF    1F.6
0208:  BCF    03.5
0209:  BSF    1F.6
020A:  BSF    1F.7
020B:  BSF    03.5
020C:  BSF    1F.7
020D:  BCF    03.5
020E:  BSF    1F.0
....................     
....................    init_dac(); 
020F:  GOTO   0A4
....................   
....................    setup_timer_1(T1_DIV_BY_2| T1_INTERNAL);  
0210:  MOVLW  95
0211:  MOVWF  10
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_128); 
0212:  BSF    03.5
0213:  MOVF   01,W
0214:  ANDLW  C0
0215:  IORLW  06
0216:  MOVWF  01
....................    setup_ccp2(CCP_CAPTURE_RE);    // Configure CCP2 to capture fall 
0217:  BCF    03.5
0218:  BSF    2E.1
0219:  MOVF   2E,W
021A:  BSF    03.5
021B:  MOVWF  07
021C:  BCF    03.5
021D:  CLRF   1D
021E:  MOVLW  05
021F:  MOVWF  1D
....................    enable_interrupts(INT_CCP2);   // Setup interrupt on falling edge 
0220:  BSF    03.5
0221:  BSF    0D.0
....................    enable_interrupts(INT_TIMER0); 
0222:  BCF    03.5
0223:  BSF    0B.5
....................    enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
0224:  BSF    03.5
0225:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
0226:  MOVLW  C0
0227:  BCF    03.5
0228:  IORWF  0B,F
....................    output_high(Electric_Controller_Switch); 
0229:  BSF    03.5
022A:  BCF    06.0
022B:  BCF    03.5
022C:  BSF    06.0
....................    output_high(Contactor_Switch); 
022D:  BSF    03.5
022E:  BCF    06.2
022F:  BCF    03.5
0230:  BSF    06.2
....................     
....................    pid_Init(K_P * SCALING_FACTOR,K_I*SCALING_FACTOR,K_D*SCALING_FACTOR, & pidData); 
0231:  CLRF   54
0232:  MOVLW  80
0233:  MOVWF  53
0234:  CLRF   56
0235:  MOVWF  55
0236:  CLRF   58
0237:  CLRF   57
0238:  MOVLW  30
0239:  MOVWF  59
023A:  GOTO   0E1
....................     
....................  
....................    while(TRUE) { 
....................  
....................       //GET INPUTS 
....................       //Vspeed happens in interrupts 
....................        
....................       set_adc_channel(Acaps_channel); 
023B:  MOVLW  08
023C:  MOVWF  21
023D:  MOVF   1F,W
023E:  ANDLW  C7
023F:  IORWF  21,W
0240:  MOVWF  1F
....................       ADC_DELAY; 
0241:  MOVLW  21
0242:  MOVWF  20
0243:  DECFSZ 20,F
0244:  GOTO   243
....................       Acaps = read_adc(); 
0245:  BSF    1F.2
0246:  BTFSC  1F.2
0247:  GOTO   246
0248:  BSF    03.5
0249:  MOVF   1E,W
024A:  BCF    03.5
024B:  MOVWF  51
024C:  MOVF   1E,W
024D:  MOVWF  52
....................        
....................       set_adc_channel(Athrottle_channel); 
024E:  MOVLW  00
024F:  MOVWF  21
0250:  MOVF   1F,W
0251:  ANDLW  C7
0252:  IORWF  21,W
0253:  MOVWF  1F
....................       ADC_DELAY; 
0254:  MOVLW  21
0255:  MOVWF  20
0256:  DECFSZ 20,F
0257:  GOTO   256
....................       Athrottle = read_adc(); 
0258:  BSF    1F.2
0259:  BTFSC  1F.2
025A:  GOTO   259
025B:  BSF    03.5
025C:  MOVF   1E,W
025D:  BCF    03.5
025E:  MOVWF  4F
025F:  MOVF   1E,W
0260:  MOVWF  50
....................  
....................       //CONTROL BOX 
....................  
....................        
....................       current_servo_position=left_position+((Athrottle-Athrottle_Min)/Athrottle_Full)*servo_difference;//(vSpeed/65536.0)*(2500); 
0261:  MOVLW  32
0262:  SUBWF  4F,W
0263:  MOVWF  53
0264:  MOVF   50,W
0265:  MOVWF  54
0266:  MOVLW  01
0267:  BTFSS  03.0
0268:  MOVLW  02
0269:  SUBWF  54,F
026A:  MOVF   54,W
026B:  MOVWF  60
026C:  MOVF   53,W
026D:  MOVWF  5F
026E:  MOVLW  03
026F:  MOVWF  62
0270:  MOVLW  44
0271:  MOVWF  61
0272:  CALL   0BC
0273:  MOVF   22,W
0274:  MOVWF  55
0275:  MOVF   21,W
0276:  MOVWF  54
0277:  MOVLW  32
0278:  SUBWF  21,W
0279:  MOVWF  56
027A:  MOVF   22,W
027B:  MOVWF  57
027C:  MOVLW  01
027D:  BTFSS  03.0
027E:  MOVLW  02
027F:  SUBWF  57,F
0280:  MOVF   57,W
0281:  MOVWF  59
0282:  MOVF   56,W
0283:  MOVWF  58
0284:  MOVLW  12
0285:  MOVWF  5B
0286:  MOVLW  C0
0287:  MOVWF  5A
0288:  GOTO   1AD
0289:  MOVF   21,W
028A:  ADDLW  6E
028B:  MOVWF  57
028C:  MOVF   22,W
028D:  MOVWF  58
028E:  MOVLW  0F
028F:  BTFSC  03.0
0290:  MOVLW  10
0291:  ADDWF  58,F
0292:  MOVLW  6E
0293:  SUBWF  57,W
0294:  MOVWF  42
0295:  MOVF   58,W
0296:  MOVWF  43
0297:  MOVLW  0F
0298:  BTFSS  03.0
0299:  MOVLW  10
029A:  SUBWF  43,F
....................       //printf("Analog Cap %d Analog Throttle %d\n",(int) Acaps, (int) Athrottle); 
....................        
....................     
....................       //SET OUTPUTS  
....................       //The writing of the ICEThrottle happens in interupts and all that is 
....................       //required is updating ICEthrottle 
....................        
....................       //write_dac(current_servo_position*4); 
....................    } 
029B:  GOTO   23B
....................     
....................  
.................... } 
....................  
.................... /*! \brief Initialisation of PID controller parameters. 
....................  * 
....................  *  Initialise the variables used by the PID algorithm. 
....................  * 
....................  *  \param p_factor  Proportional term. 
....................  *  \param i_factor  Integral term. 
....................  *  \param d_factor  Derivate term. 
....................  *  \param pid  Struct with PID status. 
....................  */ 
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid) 
.................... // Set up PID controller parameters 
029C:  GOTO   29C
.................... { 
....................   // Start values for PID controller 
....................   pid->sumError = 0; 
*
00E1:  MOVLW  02
00E2:  ADDWF  59,W
00E3:  MOVWF  04
00E4:  INCF   04,F
00E5:  INCF   04,F
00E6:  INCF   04,F
00E7:  CLRF   00
00E8:  DECF   04,F
00E9:  CLRF   00
00EA:  DECF   04,F
00EB:  CLRF   00
00EC:  DECF   04,F
00ED:  CLRF   00
....................   pid->lastProcessValue = 0; 
00EE:  MOVF   59,W
00EF:  MOVWF  04
00F0:  INCF   04,F
00F1:  CLRF   00
00F2:  DECF   04,F
00F3:  CLRF   00
....................   // Tuning constants for PID loop 
....................   pid->P_Factor = p_factor; 
00F4:  MOVLW  06
00F5:  ADDWF  59,W
00F6:  MOVWF  04
00F7:  INCF   04,F
00F8:  MOVF   54,W
00F9:  MOVWF  00
00FA:  DECF   04,F
00FB:  MOVF   53,W
00FC:  MOVWF  00
....................   pid->I_Factor = i_factor; 
00FD:  MOVLW  08
00FE:  ADDWF  59,W
00FF:  MOVWF  04
0100:  INCF   04,F
0101:  MOVF   56,W
0102:  MOVWF  00
0103:  DECF   04,F
0104:  MOVF   55,W
0105:  MOVWF  00
....................   pid->D_Factor = d_factor; 
0106:  MOVLW  0A
0107:  ADDWF  59,W
0108:  MOVWF  04
0109:  INCF   04,F
010A:  MOVF   58,W
010B:  MOVWF  00
010C:  DECF   04,F
010D:  MOVF   57,W
010E:  MOVWF  00
....................   // Limits to avoid overflow 
....................   pid->maxError = MAX_INT / (pid->P_Factor + 1); 
010F:  MOVLW  0C
0110:  ADDWF  59,W
0111:  MOVWF  5A
0112:  MOVLW  06
0113:  ADDWF  59,W
0114:  MOVWF  04
0115:  INCF   04,F
0116:  MOVF   00,W
0117:  MOVWF  5C
0118:  DECF   04,F
0119:  MOVF   00,W
011A:  MOVWF  5B
011B:  MOVLW  01
011C:  ADDWF  5B,W
011D:  MOVWF  21
011E:  MOVF   5C,W
011F:  MOVWF  23
0120:  BTFSC  03.0
0121:  INCF   23,F
0122:  MOVF   21,W
0123:  MOVWF  5D
0124:  MOVF   23,W
0125:  MOVWF  5E
0126:  MOVLW  7F
0127:  MOVWF  60
0128:  MOVLW  FF
0129:  MOVWF  5F
012A:  MOVF   23,W
012B:  MOVWF  62
012C:  MOVF   21,W
012D:  MOVWF  61
012E:  CALL   0BC
012F:  MOVF   5A,W
0130:  MOVWF  04
0131:  INCF   04,F
0132:  MOVF   22,W
0133:  MOVWF  00
0134:  DECF   04,F
0135:  MOVF   21,W
0136:  MOVWF  00
....................   pid->maxSumError = MAX_I_TERM / (pid->I_Factor + 1); 
0137:  MOVLW  0E
0138:  ADDWF  59,W
0139:  MOVWF  5A
013A:  MOVLW  08
013B:  ADDWF  59,W
013C:  MOVWF  04
013D:  INCF   04,F
013E:  MOVF   00,W
013F:  MOVWF  5C
0140:  DECF   04,F
0141:  MOVF   00,W
0142:  MOVWF  5B
0143:  MOVLW  01
0144:  ADDWF  5B,W
0145:  MOVWF  21
0146:  MOVF   5C,W
0147:  MOVWF  23
0148:  BTFSC  03.0
0149:  INCF   23,F
014A:  MOVF   21,W
014B:  MOVWF  5D
014C:  MOVF   23,W
014D:  MOVWF  5E
014E:  MOVF   04,W
014F:  MOVWF  5F
0150:  MOVLW  3F
0151:  MOVWF  63
0152:  MOVLW  FF
0153:  MOVWF  62
0154:  MOVWF  61
0155:  MOVWF  60
0156:  CLRF   67
0157:  CLRF   66
0158:  MOVF   5E,W
0159:  MOVWF  65
015A:  MOVF   5D,W
015B:  MOVWF  64
*
019C:  MOVF   5F,W
019D:  MOVWF  04
019E:  MOVF   5A,W
019F:  MOVWF  04
01A0:  MOVF   20,W
01A1:  MOVWF  00
01A2:  INCF   04,F
01A3:  MOVF   21,W
01A4:  MOVWF  00
01A5:  INCF   04,F
01A6:  MOVF   22,W
01A7:  MOVWF  00
01A8:  INCF   04,F
01A9:  MOVF   23,W
01AA:  MOVWF  00
.................... } 
01AB:  BCF    0A.3
01AC:  GOTO   23B (RETURN)
....................  
....................  
.................... /*! \brief PID control algorithm. 
....................  * 
....................  *  Calculates output from setpoint, process value and PID status. 
....................  * 
....................  *  \param setPoint  Desired value. 
....................  *  \param processValue  Measured value. 
....................  *  \param pid_st  PID status struct. 
....................  */ 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st) 
.................... { 
....................   int16 error, p_term, d_term; 
....................   int32 i_term, ret, temp; 
....................  
....................   error = setPoint - processValue; 
....................  
....................   // Calculate Pterm and limit error overflow 
....................   if (error > pid_st->maxError){ 
....................     p_term = MAX_INT; 
....................   } 
....................   else if (error < -pid_st->maxError){ 
....................     p_term = -MAX_INT; 
....................   } 
....................   else{ 
....................     p_term = pid_st->P_Factor * error; 
....................   } 
....................  
....................   // Calculate Iterm and limit integral runaway 
....................   temp = pid_st->sumError + error; 
....................   if(temp > pid_st->maxSumError){ 
....................     i_term = MAX_I_TERM; 
....................     pid_st->sumError = pid_st->maxSumError; 
....................   } 
....................   else if(temp < -pid_st->maxSumError){ 
....................     i_term = -MAX_I_TERM; 
....................     pid_st->sumError = -pid_st->maxSumError; 
....................   } 
....................   else{ 
....................     pid_st->sumError = temp; 
....................     i_term = pid_st->I_Factor * pid_st->sumError; 
....................   } 
....................  
....................   // Calculate Dterm 
....................   d_term = pid_st->D_Factor * (pid_st->lastProcessValue - processValue); 
....................  
....................   pid_st->lastProcessValue = processValue; 
....................  
....................   ret = (p_term + i_term + d_term) / SCALING_FACTOR; 
....................   if(ret > MAX_INT){ 
....................     ret = MAX_INT; 
....................   } 
....................   else if(ret < -MAX_INT){ 
....................     ret = -MAX_INT; 
....................   } 
....................  
....................   return((int16)ret); 
.................... } 
....................  
.................... /*! \brief Resets the integrator. 
....................  * 
....................  *  Calling this function will reset the integrator in the PID regulator. 
....................  */ 
.................... void pid_Reset_Integrator(pidData_t *pid_st) 
.................... { 
....................   pid_st->sumError = 0; 
.................... } 
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 373A   HS NOWDT NOPUT DEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
