CCS PCM C Compiler, Version 4.084, 46530               29-Nov-13 12:21

               Filename: HondaHybrid.lst

               ROM used: 794 words (21%)
                         Largest free fragment is 1788
               RAM used: 53 (30%) at main() level
                         80 (45%) worst case
               Stack:    2 worst case (1 in main + 1 for interrupts)

*
0000:  NOP
0001:  MOVLW  00
0002:  MOVWF  0A
0003:  GOTO   267
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  26
0008:  MOVF   7F,W
0009:  MOVWF  25
000A:  MOVF   0A,W
000B:  MOVWF  2D
000C:  CLRF   0A
000D:  SWAPF  25,F
000E:  MOVF   04,W
000F:  MOVWF  27
0010:  MOVF   20,W
0011:  MOVWF  28
0012:  MOVF   21,W
0013:  MOVWF  29
0014:  MOVF   22,W
0015:  MOVWF  2A
0016:  MOVF   23,W
0017:  MOVWF  2B
0018:  MOVF   24,W
0019:  MOVWF  2C
001A:  BCF    03.7
001B:  BCF    03.5
001C:  MOVLW  8C
001D:  MOVWF  04
001E:  BTFSS  00.0
001F:  GOTO   022
0020:  BTFSC  0C.0
0021:  GOTO   03F
0022:  MOVLW  8D
0023:  MOVWF  04
0024:  BTFSS  00.0
0025:  GOTO   028
0026:  BTFSC  0D.0
0027:  GOTO   041
0028:  BTFSS  0B.5
0029:  GOTO   02C
002A:  BTFSC  0B.2
002B:  GOTO   043
002C:  MOVF   27,W
002D:  MOVWF  04
002E:  MOVF   28,W
002F:  MOVWF  20
0030:  MOVF   29,W
0031:  MOVWF  21
0032:  MOVF   2A,W
0033:  MOVWF  22
0034:  MOVF   2B,W
0035:  MOVWF  23
0036:  MOVF   2C,W
0037:  MOVWF  24
0038:  MOVF   2D,W
0039:  MOVWF  0A
003A:  SWAPF  26,W
003B:  MOVWF  03
003C:  SWAPF  7F,F
003D:  SWAPF  7F,W
003E:  RETFIE
003F:  BCF    0A.3
0040:  GOTO   061
0041:  BCF    0A.3
0042:  GOTO   0A9
0043:  BCF    0A.3
0044:  GOTO   053
.................... #define DEBUG 
.................... //#define BOARDV1 
.................... #define TEST 
.................... #include "HondaHybrid.h" 
.................... #include <16F873A.h> 
.................... //////// Standard Header file for the PIC16F873A device //////////////// 
.................... #device PIC16F873A 
.................... #list 
....................  
....................  
.................... #ifdef DEBUG 
....................    #device ICD=TRUE 
.................... #endif 
....................  
.................... #device adc=10 
.................... #use delay(clock=20000000) 
*
0229:  MOVLW  54
022A:  MOVWF  04
022B:  MOVF   00,W
022C:  BTFSC  03.2
022D:  GOTO   23B
022E:  MOVLW  06
022F:  MOVWF  21
0230:  CLRF   20
0231:  DECFSZ 20,F
0232:  GOTO   231
0233:  DECFSZ 21,F
0234:  GOTO   230
0235:  MOVLW  7B
0236:  MOVWF  20
0237:  DECFSZ 20,F
0238:  GOTO   237
0239:  DECFSZ 00,F
023A:  GOTO   22E
023B:  RETLW  00
.................... #ifdef DEBUG 
....................    #use rs232 (DEBUGGER) 
023C:  BSF    03.5
023D:  BCF    06.3
023E:  BCF    03.5
023F:  BCF    06.3
0240:  MOVLW  08
0241:  MOVWF  21
0242:  GOTO   243
0243:  NOP
0244:  BSF    21.7
0245:  GOTO   254
0246:  BCF    21.7
0247:  RRF    54,F
0248:  BTFSC  03.0
0249:  BSF    06.3
024A:  BTFSS  03.0
024B:  BCF    06.3
024C:  BSF    21.6
024D:  GOTO   254
024E:  BCF    21.6
024F:  DECFSZ 21,F
0250:  GOTO   247
0251:  GOTO   252
0252:  NOP
0253:  BSF    06.3
0254:  MOVLW  02
0255:  MOVWF  20
0256:  CLRF   04
0257:  DECFSZ 04,F
0258:  GOTO   257
0259:  DECFSZ 20,F
025A:  GOTO   256
025B:  MOVLW  AD
025C:  MOVWF  04
025D:  DECFSZ 04,F
025E:  GOTO   25D
025F:  GOTO   260
0260:  NOP
0261:  BTFSC  21.7
0262:  GOTO   246
0263:  BTFSC  21.6
0264:  GOTO   24E
0265:  BCF    0A.3
0266:  GOTO   307 (RETURN)
.................... #endif 
.................... #fuses HS,PUT,NOWDT 
.................... #include <mcp4921.c> 
.................... //////////////// Driver for MCP4921 D/A Converter /////////////////////// 
.................... ////                                                                 //// 
.................... ////  init_dac()    Call this before using a MCP4921 DAC             //// 
.................... ////                                                                 //// 
.................... ////  write_dac( long int )   Writes command and 12 bit resolution   //// 
.................... ////                          to the MCP4921 which converts it to a  //// 
.................... ////                          voltage                                //// 
.................... ////                          0-4095 input represents 0-vref V out.  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SELECT 
....................  
.................... #define DAC_CS     PIN_C4 
.................... #define DAC_CLK    PIN_C3 
.................... #define DAC_DI     PIN_C5 
.................... #define DAC_LDAC   PIN_B4 
....................  
.................... #endif 
....................  
.................... void init_dac() 
.................... { 
....................    output_high(DAC_CS); 
*
00C6:  BCF    2E.4
00C7:  MOVF   2E,W
00C8:  BSF    03.5
00C9:  MOVWF  07
00CA:  BCF    03.5
00CB:  BSF    07.4
....................    output_high(DAC_LDAC); 
00CC:  BSF    03.5
00CD:  BCF    06.4
00CE:  BCF    03.5
00CF:  BSF    06.4
....................    output_high(DAC_CLK); 
00D0:  BCF    2E.3
00D1:  MOVF   2E,W
00D2:  BSF    03.5
00D3:  MOVWF  07
00D4:  BCF    03.5
00D5:  BSF    07.3
....................    output_high(DAC_DI); 
00D6:  BCF    2E.5
00D7:  MOVF   2E,W
00D8:  BSF    03.5
00D9:  MOVWF  07
00DA:  BCF    03.5
00DB:  BSF    07.5
.................... } 
00DC:  BCF    0A.3
00DD:  GOTO   2B1 (RETURN)
....................  
.................... void write_dac(int16 data) { 
....................    BYTE cmd[3]; 
....................    BYTE i; 
....................  
....................    cmd[0]=data; 
00DE:  MOVF   53,W
00DF:  MOVWF  55
....................    cmd[1]=(data>>8); 
00E0:  MOVF   54,W
00E1:  MOVWF  56
....................    cmd[2]=0x03;                            
00E2:  MOVLW  03
00E3:  MOVWF  57
....................     
....................    output_high(DAC_LDAC); 
00E4:  BSF    03.5
00E5:  BCF    06.4
00E6:  BCF    03.5
00E7:  BSF    06.4
....................    output_low(DAC_CLK); 
00E8:  BCF    2E.3
00E9:  MOVF   2E,W
00EA:  BSF    03.5
00EB:  MOVWF  07
00EC:  BCF    03.5
00ED:  BCF    07.3
....................    output_low(DAC_CS); 
00EE:  BCF    2E.4
00EF:  MOVF   2E,W
00F0:  BSF    03.5
00F1:  MOVWF  07
00F2:  BCF    03.5
00F3:  BCF    07.4
....................  
....................    for(i=0; i<=23; ++i) 
00F4:  CLRF   58
00F5:  MOVF   58,W
00F6:  SUBLW  17
00F7:  BTFSS  03.0
00F8:  GOTO   126
....................    { 
....................       if(i<4 || (i>7 && i<12)) 
00F9:  MOVF   58,W
00FA:  SUBLW  03
00FB:  BTFSC  03.0
00FC:  GOTO   105
00FD:  MOVF   58,W
00FE:  SUBLW  07
00FF:  BTFSC  03.0
0100:  GOTO   10A
0101:  MOVF   58,W
0102:  SUBLW  0B
0103:  BTFSS  03.0
0104:  GOTO   10A
....................          shift_left(cmd,3,0); 
0105:  BCF    03.0
0106:  RLF    55,F
0107:  RLF    56,F
0108:  RLF    57,F
....................       else 
0109:  GOTO   124
....................       { 
....................          output_bit(DAC_DI, shift_left(cmd,3,0)); 
010A:  BCF    03.0
010B:  RLF    55,F
010C:  RLF    56,F
010D:  RLF    57,F
010E:  BTFSC  03.0
010F:  GOTO   112
0110:  BCF    07.5
0111:  GOTO   113
0112:  BSF    07.5
0113:  BCF    2E.5
0114:  MOVF   2E,W
0115:  BSF    03.5
0116:  MOVWF  07
....................  
....................          output_high(DAC_CLK); 
0117:  BCF    03.5
0118:  BCF    2E.3
0119:  MOVF   2E,W
011A:  BSF    03.5
011B:  MOVWF  07
011C:  BCF    03.5
011D:  BSF    07.3
....................          output_low(DAC_CLK); 
011E:  BCF    2E.3
011F:  MOVF   2E,W
0120:  BSF    03.5
0121:  MOVWF  07
0122:  BCF    03.5
0123:  BCF    07.3
....................       } 
....................    } 
0124:  INCF   58,F
0125:  GOTO   0F5
....................    output_high(DAC_CS); 
0126:  BCF    2E.4
0127:  MOVF   2E,W
0128:  BSF    03.5
0129:  MOVWF  07
012A:  BCF    03.5
012B:  BSF    07.4
....................  
....................    output_low(DAC_LDAC); 
012C:  BSF    03.5
012D:  BCF    06.4
012E:  BCF    03.5
012F:  BCF    06.4
....................    delay_us(10); 
0130:  MOVLW  10
0131:  MOVWF  20
0132:  DECFSZ 20,F
0133:  GOTO   132
0134:  NOP
....................     
....................    output_HIGH(DAC_LDAC); 
0135:  BSF    03.5
0136:  BCF    06.4
0137:  BCF    03.5
0138:  BSF    06.4
.................... } 
0139:  RETLW  00
....................  
....................  
....................  
.................... #include "pid.h" 
.................... /*This file has been prepared for Doxygen automatic documentation generation.*/ 
.................... /*! \file ********************************************************************* 
....................  * 
....................  * \brief Header file for pid.c. 
....................  * 
....................  * - File:               pid.h 
....................  * - Compiler:           IAR EWAAVR 4.11A 
....................  * - Supported devices:  All AVR devices can be used. 
....................  * - AppNote:            AVR221 - Discrete PID controller 
....................  * 
....................  * \author               Atmel Corporation: http://www.atmel.com \n 
....................  *                       Support email: avr@atmel.com 
....................  * 
....................  * $Name$ 
....................  * $Revision: 456 $ 
....................  * $RCSfile$ 
....................  * $Date: 2006-02-16 12:46:13 +0100 (to, 16 feb 2006) $ 
....................  *****************************************************************************/ 
....................  
.................... #ifndef PID_H 
.................... #define PID_H 
....................  
.................... //#include "stdint.h" 
.................... #define INT16_MAX 32767 
.................... #define INT32_MAX 2147483647 
.................... #define SCALING_FACTOR  128 
....................  
.................... /*! \brief PID Status 
....................  * 
....................  * Setpoints and data used by the PID control algorithm 
....................  */ 
.................... typedef struct PID_DATA{ 
....................   //! Last process value, used to find derivative of process value. 
....................   int16 lastProcessValue; 
....................   //! Summation of errors, used for integrate calculations 
....................   int32 sumError; 
....................   //! The Proportional tuning constant, multiplied with SCALING_FACTOR 
....................   int16 P_Factor; 
....................   //! The Integral tuning constant, multiplied with SCALING_FACTOR 
....................   int16 I_Factor; 
....................   //! The Derivative tuning constant, multiplied with SCALING_FACTOR 
....................   int16 D_Factor; 
....................   //! Maximum allowed error, avoid overflow 
....................   int16 maxError; 
....................   //! Maximum allowed sumerror, avoid overflow 
....................   int32 maxSumError; 
.................... } pidData_t; 
....................  
.................... /*! \brief Maximum values 
....................  * 
....................  * Needed to avoid sign/overflow problems 
....................  */ 
.................... // Maximum value of variables 
.................... #define MAX_INT         INT16_MAX 
.................... #define MAX_LONG        INT32_MAX 
.................... #define MAX_I_TERM      (MAX_LONG / 2) 
....................  
.................... // Boolean values 
.................... //#define FALSE           0 
.................... //#define TRUE            1 
....................  
.................... boolean checkRunnaway(struct PID_DATA *pid); 
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid); 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st); 
.................... void pid_Reset_Integrator(pidData_t *pid_st); 
....................  
.................... #endif 
....................  
.................... /* 
.................... This is the main controller for the super capacitor hybrid scooter a.k.a RED 
.................... B2 close contactor 
.................... CONTROL BOX INPUTS 
.................... Athrottle- A0 - analog input representing the users input for speed, 10 bit 
.................... Vspeed - CCp2-a 16 bit representation of the speed of the vehicle 
.................... Acaps- A1 - analog input representing the current voltage of the supercapacitors, 10 bit 
.................... There are 18 Supercaps with a maximum voltage of 2.7 (2.85 is breakdown) volts for a total of 48.6 V 
.................... The circuit has a 10/110 voltage divider into the ADC. So minimum voltage of 18 Volts is 335 and 48 Volts is 893. Measured 38.2V equal to 726 
....................  
.................... CONTROL BOX OUTPUT 
.................... ICEthrottle- B1 - a 16 bit number sent to the internal combustion engine(ICE) throttle  
.................... ELECthrottle-  - a 16 bit number sent as analog value representing the demanded electric power 
....................  
.................... SPECIFICS OF I/O 
....................  
.................... Athrottle - the electric throttle is a 3 wire unit with a 5 volt,ground, and analog out 
....................    representing how far throttle is turned. Pin AN0 is the input. 
....................     
.................... Vspeed - There is a encoder in the rear wheel/electric motor that is used by the electric 
....................    power controller. Tapping in to this this Main Controller receives a 5 Volt square wave 
....................    with 42 pulses. There are two options for measuring speed. The first is to measure the  
....................    length of the pulses. The second is to measure the rate of pulses. This controller currently 
....................    uses the rate method. The int_ccp2 interupt is called on each falling edge and stores the  
....................    Vspeed value as the max number of 16bit (65535-timer0_since_last_reset).  
....................     
....................    The RED scooter has a circumpherence of 16.3*2*pi = 102.4 
....................    X m/h * 63360 inch/mile * 1/3600 h/sec * 1/(102.4 inch/rev) = .171875* X 
....................    Examples 50 mph is 8.9 ms 1 overflow of timer0 
....................    Example 5 mph is 89 ms or 13 time overflow 
....................     
....................    #int_timer0 increments the counter number_of_overflows each time it overflows 
....................    On int ccp2 we multiply number_of_overflows * 256 + timer0 to get timer0_since_last_reset 
....................     
.................... Acaps - the analog voltage which is the 5volt representation of the voltage in the caps which 
....................    have a value of between 0-48v. The voltages are factored so that the voltage on AN1 goes 
....................    from 0 - 4.8 volts (TODO check this factor, think its 1/11 not 1/10) 
....................     
.................... ICEthrottle -  #int_timer1 is set to make sure the period follows the required below 
....................    The period for the servo is .020 seconds which is 50,000 operations 
....................    The leftmost position of the server is .001 seconds which is 2,500 
....................    The rightmost position of the server is .002 seconds which is 5,000 
....................     
....................    The output pin is pin_B1.-> 
....................  
.................... ELECthrottle 
....................    The electric power controller takes an analog voltage as input. The output voltage 
....................    is set by the DAC. The pins used are C3,C4,C5. if CHARGING_STATE is true then  
....................     
.................... ALGORITHM 
....................    The algorithm is basically a PID controller. In broad terms we are trying to set the 
....................    ICEthrottle and ICEelectric to maximize the use of electric and accelerate to meet the 
....................    requirements set by the rider with the Athrottle signal. When the demanded power is  
....................    less than the power output possible by the ICE and the caps are in the CHARGING_STATE  
....................    then the ICE is turned up to the max and the ELECthrottle is set to regen to 
....................    charge the capacitors.If CHARGING_STATE is false then the caps are supplying the drivig power 
....................    and the ICE is set to "off", the caps supply the power. Unless the user requested supply 
....................    is enough to require both power sources. 
....................     
....................    If CHARGING_STATE is true. Then pin_b2 is set as high which will close the brake number 
....................    for the electric power controller.  
....................     
....................    If CHARGING_STATE is false then the pin_b2 is set low which opens brake. 
....................     
....................    
....................  
....................  
.................... The encoder has 42 on and offs per rotation, i.e. 21 steps 
....................  
.................... Number of operations per second is CLOCK/4/Timer Divisions 
.................... Number of operations per second is 20,000,000/4/128 = 39062.5  
.................... Each operation takes 1/39062.5 = .256 micro (x10^-6) seconds 
.................... Seconds to Overflow timer0 8bit timer = .256x10^-6 * 256 = 6.55ms 
....................  
....................   
....................  
.................... */ 
.................... #define servo_pin PIN_B1  //Setting servo out pin to be hardware pin b1 
.................... #define brake_pin PIN_B4 
.................... #define ADC_DELAY delay_us(20) 
.................... #define Acaps_pin PIN_A1 
.................... #define Acaps_channel 1 
.................... #define Athrottle_pin PIN_A0  //Voltage goes from 1.5 (306)to 4.1(836) 
.................... #define Athrottle_Min 316 
.................... #define Athrottle_Max 860 
.................... #define Athrottle_3quarter 700 
.................... #define Athrottle_Full Athrottle_Max-Athrottle_Min 
.................... #define Athrottle_channel 0 
.................... #ifdef BOARDV1 
.................... #define Electric_Controller_Switch PIN_B0 
.................... #define Contactor_Switch PIN_B2 
.................... #else 
.................... #define Contactor_Switch PIN_B5 
.................... #define Controller_Power_Switch PIN_B2 
.................... #define Electric_Controller_Switch PIN_B0 //this is the switch from acceleration/breaking with driving high as breaking 
.................... #define ALGORITHM_INPUT_SWITCH PIN_A2 
.................... #endif 
.................... #define A_CAPS_MAX 725//893 
.................... #define A_CAPS_MIN 400//335 
.................... #define A_CAPS_MID_LOW (A_CAPS_MIN + 100) //This is the low end of the middle ACaps range. The range in which discharge and charge are allowed.  
.................... #define A_CAPS_MID_HIGH (A_CAPS_MAX - 100) //This is the low end of the middle ACaps range. The range in which discharge and charge are allowed.  
.................... #define V_SPEED_REGEN_MIN 50 //Why is there a minimum speed? Because below this no regenerative action is possible with electric motor 
.................... #define INSUFFICIENT_BRAKING_RUNNAWAY_ERROR 50000 
....................  
.................... //PID Values 
.................... #define K_P 1.50 
.................... #define K_I 0.00 
.................... #define K_D 0.20 
....................  
.................... struct PID_DATA pidData; 
.................... #define TIME_INTERVAL 157 //TODO replace 
....................  
.................... #define left_position 2500//4450 
.................... #define right_position 4600 
.................... #define servo_difference  right_position-left_position 
.................... #define servo_difference_div 5200 
.................... #define ELEC_CONTROLLER_OFFSET 900 
.................... //const float Athrottle_servo_factor = ((float) servo_difference)/((float) Athrottle_FULL); 
.................... #define servo_period   65356-50000 
.................... unsigned int16 current_servo_position=right_position; 
*
0278:  MOVLW  F8
0279:  MOVWF  41
027A:  MOVLW  11
027B:  MOVWF  42
.................... int1 SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0; 
027C:  BCF    43.0
....................  
.................... unsigned int16 number_of_timer0_interupts_since_reset =0; 
027D:  CLRF   44
027E:  CLRF   45
.................... unsigned int16 vSpeed= 0; 
027F:  CLRF   46
0280:  CLRF   47
.................... signed int16 ELECthrottle = 0; 
0281:  CLRF   48
0282:  CLRF   49
.................... unsigned int16 ICEthrottle = 0; 
0283:  CLRF   4A
0284:  CLRF   4B
.................... unsigned int16 Athrottle = 0; 
0285:  CLRF   4C
0286:  CLRF   4D
.................... unsigned int16 Acaps = 0; 
0287:  CLRF   4E
0288:  CLRF   4F
.................... int1 ICE_ON = 0; 
0289:  BCF    43.1
.................... int1 CURRENTLY_CHARGING = 0; 
028A:  BCF    43.2
.................... int1 RUNNAWAY_CHECK = 0; 
028B:  BCF    43.3
.................... signed int16 returnedValue =0; 
028C:  CLRF   50
028D:  CLRF   51
....................  
.................... enum{  
....................    EVERYTHING_OFF, 
....................    SPEED_TO_LOW_ICE_DIRECT, 
....................    CHARGING_ALLOWED,  
....................    DISCHARGING_ALLOWED,  
....................    CHARGING_AND_DISCHARING_ALLOWED, 
....................    INSUFFICIENT_BRAKING_RUNAWAY, 
....................    USER_INPUT_OFF 
.................... } CHARGING_STATE; 
....................  
.................... /* 
.................... The #int_timer0 interupt is triggered on each timer0 8bit interupt 
.................... the function simply increments a overflow counter to be used by the ccp2 
.................... interupt to calculate speed 
.................... NUMBER OF OPERATIONS =  
.................... */ 
.................... #int_timer0 
.................... void timer0_isr(){ 
....................     
....................       number_of_timer0_interupts_since_reset=number_of_timer0_interupts_since_reset+256; 
*
0053:  MOVLW  01
0054:  ADDWF  45,F
....................       //current_servo_position=current_servo_position+1; 
....................        
....................     
....................    if (number_of_timer0_interupts_since_reset>=1024){ 
0055:  MOVF   45,W
0056:  SUBLW  03
0057:  BTFSC  03.0
0058:  GOTO   05E
....................       vSpeed = 0; 
0059:  CLRF   47
005A:  CLRF   46
....................       number_of_timer0_interupts_since_reset=1024; 
005B:  MOVLW  04
005C:  MOVWF  45
005D:  CLRF   44
....................        
....................        
....................    } 
.................... } 
....................  
.................... /* 
.................... #int_timer1 is used by the ICEservo throttle to regulate the timing pulses. The  
.................... timer is setup for a pulsetrain of 20ms period. This is done as follows, 
....................  
.................... Period is 1/(CLOCK/4opsperclock)*(startingPostionOfClock) = 20 ms 
.................... for this setup 1/(20000000/4)*(50000) = 20 ms 
....................  
.................... The timer1 starts at 0 and counts up. So we set the beggining of the clock at 
.................... servo_period which is 65356-50000 so that the total time is 20ms. 
.................... */ 
005E:  BCF    0B.2
005F:  BCF    0A.3
0060:  GOTO   02C
.................... #int_timer1 
.................... void isr() 
.................... { 
....................  
.................... //Make sure that the position is within the left and right positions of the servo 
....................    if (current_servo_position<left_position){ 
0061:  MOVF   42,W
0062:  SUBLW  09
0063:  BTFSS  03.0
0064:  GOTO   070
0065:  BTFSS  03.2
0066:  GOTO   06B
0067:  MOVF   41,W
0068:  SUBLW  C3
0069:  BTFSS  03.0
006A:  GOTO   070
....................       current_servo_position = left_position; 
006B:  MOVLW  09
006C:  MOVWF  42
006D:  MOVLW  C4
006E:  MOVWF  41
....................    } 
....................    else if (current_servo_position > right_position){ 
006F:  GOTO   07F
0070:  MOVF   42,W
0071:  SUBLW  10
0072:  BTFSC  03.0
0073:  GOTO   07F
0074:  XORLW  FF
0075:  BTFSS  03.2
0076:  GOTO   07B
0077:  MOVF   41,W
0078:  SUBLW  F8
0079:  BTFSC  03.0
007A:  GOTO   07F
....................       current_servo_position = right_position; 
007B:  MOVLW  11
007C:  MOVWF  42
007D:  MOVLW  F8
007E:  MOVWF  41
....................    } 
.................... //printf("Current servo position %ld",current_servo_position); 
....................    if(SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER) 
007F:  BTFSS  43.0
0080:  GOTO   094
....................       {  
....................          output_high(servo_pin);        //Set the servo control pin to high  
0081:  BSF    03.5
0082:  BCF    06.1
0083:  BCF    03.5
0084:  BSF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 0;  
0085:  BCF    43.0
....................          set_timer1(65356-current_servo_position); //Set timer for the position high pulse 
0086:  MOVF   41,W
0087:  SUBLW  4C
0088:  MOVWF  6D
0089:  MOVLW  FF
008A:  MOVWF  6E
008B:  MOVF   42,W
008C:  BTFSS  03.0
008D:  INCFSZ 42,W
008E:  SUBWF  6E,F
008F:  MOVF   6E,W
0090:  MOVWF  0F
0091:  MOVF   6D,W
0092:  MOVWF  0E
....................       }  
....................    else  
0093:  GOTO   0A6
....................       {  
....................          output_low(servo_pin);                      // Set the servo control pin to low   
0094:  BSF    03.5
0095:  BCF    06.1
0096:  BCF    03.5
0097:  BCF    06.1
....................          SERVO_PIN_TO_BE_SET_HIGH_ON_NEXT_TIMER = 1;  
0098:  BSF    43.0
....................          set_timer1(servo_period+current_servo_position);          //Set timer for the low position the length is the difference between  
0099:  MOVLW  FC
009A:  ADDWF  41,W
009B:  MOVWF  6D
009C:  MOVF   42,W
009D:  MOVWF  6E
009E:  MOVLW  3B
009F:  BTFSC  03.0
00A0:  MOVLW  3C
00A1:  ADDWF  6E,F
00A2:  MOVF   6E,W
00A3:  MOVWF  0F
00A4:  MOVF   6D,W
00A5:  MOVWF  0E
....................                                                      //the total int16 lenght - high pulse length 
....................       }  
....................  
.................... } 
....................  
....................  
.................... /* 
.................... #int_ccp2 is called on the falling edge of the encoder pulse. We calculate the time 
.................... between pulses.  
.................... TODO will have to put some kind of smoothing mechanism 
.................... */ 
00A6:  BCF    0C.0
00A7:  BCF    0A.3
00A8:  GOTO   02C
.................... #int_ccp2 
.................... void isr2() 
.................... { 
.................... if (number_of_timer0_interupts_since_reset>10){ 
00A9:  MOVF   45,F
00AA:  BTFSS  03.2
00AB:  GOTO   0B0
00AC:  MOVF   44,W
00AD:  SUBLW  0A
00AE:  BTFSC  03.0
00AF:  GOTO   0C3
.................... vSpeed  = 1280 - (number_of_timer0_interupts_since_reset+get_timer0()); 
00B0:  MOVF   01,W
00B1:  ADDWF  44,W
00B2:  MOVWF  21
00B3:  MOVF   45,W
00B4:  MOVWF  23
00B5:  BTFSC  03.0
00B6:  INCF   23,F
00B7:  MOVF   21,W
00B8:  SUBLW  00
00B9:  MOVWF  46
00BA:  MOVLW  05
00BB:  MOVWF  47
00BC:  MOVF   23,W
00BD:  BTFSS  03.0
00BE:  INCFSZ 23,W
00BF:  SUBWF  47,F
.................... //vSpeed  = -(get_timer0()); 
.................... set_timer0(0); 
00C0:  CLRF   01
.................... number_of_timer0_interupts_since_reset = 0; 
00C1:  CLRF   45
00C2:  CLRF   44
.................... } 
.................... } 
....................  
00C3:  BCF    0D.0
00C4:  BCF    0A.3
00C5:  GOTO   02C
.................... void trickBreaking(){ 
.................... write_dac((unsigned int16) 400+ELEC_CONTROLLER_OFFSET); 
.................... delay_ms(500);       
.................... } 
....................  
.................... void printfLogf(char string){ 
....................    #ifdef DEBUG 
....................       printf("IN PrintfLog"); 
....................       printf("%c",string); 
....................    #else 
....................       delay_ms(250); 
....................    #endif 
.................... } 
....................  
.................... #ifdef TEST 
....................  
.................... /* 
.................... TEST SUITE 
.................... */ 
....................  
.................... void createHeartbeat(){ 
....................   //This creates a heartbeat on pin B1 
....................   while (1){ 
....................            output_high(servo_pin);        //Set the servo control pin to high 
....................            delay_ms(1000); 
....................            output_low(servo_pin); 
....................            delay_ms(1000); 
....................     } 
.................... } 
....................  
.................... void wiperAnalogVoltage(){ 
....................   
....................  //signed int16 test =0; 
....................  unsigned int16 wiperValue = 0; 
....................     while (1){ 
.................... printf("Wiper Value is now %ld",wiperValue); 
....................    
....................   if (wiperValue>(4095)){ 
....................      wiperValue = 0; 
....................     printf("Wiper Value is now %ld",wiperValue); 
....................   } 
....................   wiperValue=wiperValue+10; 
....................   write_dac(wiperValue); 
....................   delay_ms(10); 
....................     } 
.................... } 
....................  
.................... void heartbeatElectricControllerPower(){ 
....................     while (1){ 
....................  
....................   output_high(Contactor_Switch);        //Set the servo control pin to high 
....................            delay_ms(1000); 
....................            output_low(Contactor_Switch); 
....................            delay_ms(1000); 
....................     } 
.................... } 
....................  
.................... void wiperServo(){ 
....................     unsigned int32 wiperValue = 0; 
....................   current_servo_position = left_position; 
....................     while (1){ 
....................   printf("Servo Value %ld",current_servo_position); 
....................   if ((current_servo_position+10)>right_position){ 
....................     current_servo_position = left_position;//servo_difference; 
....................   } 
....................   current_servo_position =current_servo_position+10; 
....................   //delay_ms(1); 
....................     } 
.................... } 
....................  
.................... void printAnalogThrottleInput(){ 
....................     set_adc_channel(Athrottle_channel); 
....................       ADC_DELAY; 
....................       Athrottle = read_adc(); 
....................   printf("Analog Throttle is %ld",Athrottle ); 
.................... } 
....................  
.................... void main() 
.................... { 
*
0267:  CLRF   04
0268:  MOVLW  1F
0269:  ANDWF  03,F
026A:  BSF    03.5
026B:  BCF    06.3
026C:  BCF    03.5
026D:  BSF    06.3
026E:  BSF    03.5
026F:  BSF    1F.0
0270:  BSF    1F.1
0271:  BSF    1F.2
0272:  BCF    1F.3
0273:  MOVLW  07
0274:  MOVWF  1C
....................  
....................    setup_adc_ports(NO_ANALOGS); 
*
028E:  BSF    03.5
028F:  BSF    1F.0
0290:  BSF    1F.1
0291:  BSF    1F.2
0292:  BCF    1F.3
....................    setup_adc(ADC_OFF); 
0293:  BCF    03.5
0294:  BCF    1F.0
....................    setup_spi(FALSE); 
0295:  CLRF   14
....................  
....................    setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
0296:  BSF    03.5
0297:  MOVF   01,W
0298:  ANDLW  C0
0299:  IORLW  00
029A:  MOVWF  01
029B:  CLRWDT
....................    setup_timer_1(T1_DISABLED); 
029C:  BCF    03.5
029D:  CLRF   10
....................    setup_timer_2(T2_DISABLED,0,1); 
029E:  MOVLW  00
029F:  MOVWF  21
02A0:  MOVWF  12
02A1:  MOVLW  00
02A2:  BSF    03.5
02A3:  MOVWF  12
....................    setup_port_a(ALL_ANALOG); 
02A4:  BCF    1F.0
02A5:  BCF    1F.1
02A6:  BCF    1F.2
02A7:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
02A8:  BCF    1F.6
02A9:  BCF    03.5
02AA:  BSF    1F.6
02AB:  BSF    1F.7
02AC:  BSF    03.5
02AD:  BSF    1F.7
02AE:  BCF    03.5
02AF:  BSF    1F.0
....................  
....................    init_dac(); 
02B0:  GOTO   0C6
....................  
....................    setup_timer_1(T1_DIV_BY_2| T1_INTERNAL); 
02B1:  MOVLW  95
02B2:  MOVWF  10
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_128); 
02B3:  BSF    03.5
02B4:  MOVF   01,W
02B5:  ANDLW  C0
02B6:  IORLW  06
02B7:  MOVWF  01
....................    setup_ccp2(CCP_CAPTURE_RE);    // Configure CCP2 to capture fall 
02B8:  BCF    03.5
02B9:  BSF    2E.1
02BA:  MOVF   2E,W
02BB:  BSF    03.5
02BC:  MOVWF  07
02BD:  BCF    03.5
02BE:  CLRF   1D
02BF:  MOVLW  05
02C0:  MOVWF  1D
....................    enable_interrupts(INT_CCP2);   // Setup interrupt on falling edge 
02C1:  BSF    03.5
02C2:  BSF    0D.0
....................    enable_interrupts(INT_TIMER0); 
02C3:  BCF    03.5
02C4:  BSF    0B.5
....................    enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
02C5:  BSF    03.5
02C6:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
02C7:  MOVLW  C0
02C8:  BCF    03.5
02C9:  IORWF  0B,F
....................  
....................  
....................    CHARGING_STATE = EVERYTHING_OFF; 
02CA:  CLRF   52
....................    output_high(Electric_Controller_Switch); 
02CB:  BSF    03.5
02CC:  BCF    06.0
02CD:  BCF    03.5
02CE:  BSF    06.0
....................    write_dac(0); 
02CF:  CLRF   54
02D0:  CLRF   53
02D1:  CALL   0DE
....................    ICE_ON=TRUE; 
02D2:  BSF    43.1
....................    output_high(Contactor_Switch); 
02D3:  BSF    03.5
02D4:  BCF    06.5
02D5:  BCF    03.5
02D6:  BSF    06.5
....................    output_high(Controller_Power_Switch); 
02D7:  BSF    03.5
02D8:  BCF    06.2
02D9:  BCF    03.5
02DA:  BSF    06.2
....................    output_low(brake_pin); 
02DB:  BSF    03.5
02DC:  BCF    06.4
02DD:  BCF    03.5
02DE:  BCF    06.4
....................    pid_Init(K_P*SCALING_FACTOR,K_I*SCALING_FACTOR,K_D*SCALING_FACTOR, & pidData); 
02DF:  CLRF   54
02E0:  MOVLW  C0
02E1:  MOVWF  53
02E2:  CLRF   56
02E3:  CLRF   55
02E4:  CLRF   58
02E5:  MOVLW  19
02E6:  MOVWF  57
02E7:  MOVLW  2F
02E8:  MOVWF  59
02E9:  GOTO   13A
....................    delay_ms(3000); 
02EA:  MOVLW  0C
02EB:  MOVWF  53
02EC:  MOVLW  FA
02ED:  MOVWF  54
02EE:  CALL   229
02EF:  DECFSZ 53,F
02F0:  GOTO   2EC
....................    current_servo_position =right_position-1000; 
02F1:  MOVLW  0E
02F2:  MOVWF  42
02F3:  MOVLW  10
02F4:  MOVWF  41
....................    delay_ms(3000); 
02F5:  MOVLW  0C
02F6:  MOVWF  53
02F7:  MOVLW  FA
02F8:  MOVWF  54
02F9:  CALL   229
02FA:  DECFSZ 53,F
02FB:  GOTO   2F7
....................    current_servo_position =right_position; 
02FC:  MOVLW  11
02FD:  MOVWF  42
02FE:  MOVLW  F8
02FF:  MOVWF  41
....................     
....................     
....................     
....................  
....................  
....................  
....................  
....................    while(TRUE) { 
....................         //Test Breaking Analog Voltage. Should produce analog voltage  on pin 13 as well as drive pin 12 LOW 
....................         //output_high(brake_pin); 
....................         //output_high(Electric_Controller_Switch); 
....................         //wiperAnalogVoltage(); 
....................  
....................         //Test Accelerating Analog Voltage. Should produce analog voltage on pin 15 and let pin 12 float. 
....................         //output_low(brake_pin); 
....................         //output_low(Electric_Controller_Switch); 
....................         //wiperAnalogVoltage(); 
....................          
....................         //Test Short Circuit from Pin 11 to pin 8 with 1 second heartbeat. This tests V+ Controller. Also pin 9 should be heartbeating between 0 and 12V 
....................         //heartbeatElectricControllerPower(); 
....................          printf("test loop"); 
0300:  CLRF   53
0301:  MOVF   53,W
0302:  CALL   045
0303:  INCF   53,F
0304:  MOVWF  20
0305:  MOVWF  54
0306:  GOTO   23C
0307:  MOVLW  09
0308:  SUBWF  53,W
0309:  BTFSS  03.2
030A:  GOTO   301
....................         //Test Wiper of Servo 
....................        // wiperServo(); 
....................        output_low(Electric_Controller_Switch); 
030B:  BSF    03.5
030C:  BCF    06.0
030D:  BCF    03.5
030E:  BCF    06.0
....................        write_dac(2000); 
030F:  MOVLW  07
0310:  MOVWF  54
0311:  MOVLW  D0
0312:  MOVWF  53
0313:  CALL   0DE
....................         //current_servo_position = right_position; 
....................        //printAnalogThrottleInput(); 
....................        output_low(brake_pin); 
0314:  BSF    03.5
0315:  BCF    06.4
0316:  BCF    03.5
0317:  BCF    06.4
....................        //Test Electric Controller Out 
....................        //output_high(Contactor_Switch); 
....................        //output_high(Contactor_Switch2); 
....................  
....................    } 
0318:  GOTO   300
....................  
....................  
.................... } 
....................  
....................   
....................  
.................... #else 
.................... void main() 
.................... {   
....................     
....................    setup_adc_ports(NO_ANALOGS); 
....................    setup_adc(ADC_OFF); 
....................    setup_spi(FALSE); 
....................     
....................    setup_counters(RTCC_INTERNAL,RTCC_DIV_2); 
....................    setup_timer_1(T1_DISABLED); 
....................    setup_timer_2(T2_DISABLED,0,1); 
....................    setup_port_a(AN0_AN1_AN3); 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
....................     
....................    init_dac(); 
....................   
....................    setup_timer_1(T1_DIV_BY_2| T1_INTERNAL);  
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_128); 
....................    setup_ccp2(CCP_CAPTURE_RE);    // Configure CCP2 to capture fall 
....................    enable_interrupts(INT_CCP2);   // Setup interrupt on falling edge 
....................    enable_interrupts(INT_TIMER0); 
....................    enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
....................    enable_interrupts(GLOBAL); 
....................     
....................    CHARGING_STATE = EVERYTHING_OFF; 
....................    output_high(Electric_Controller_Switch); 
....................    write_dac(0); 
....................    ICE_ON=TRUE; 
....................    output_high(Contactor_Switch); 
....................    output_low(brake_pin); 
....................    pid_Init(K_P*SCALING_FACTOR,K_I*SCALING_FACTOR,K_D*SCALING_FACTOR, & pidData); 
....................    delay_ms(3000); 
....................    current_servo_position =right_position-1000; 
....................    delay_ms(3000); 
....................    current_servo_position =right_position; 
....................    //write_dac(1000); 
....................    //delay_ms(10000); 
....................    //output_high(Contactor_Switch); 
....................    //output_high(brake_pin); 
....................    //output_high(Electric_Controller_Switch); 
....................    while(TRUE) { 
....................        
....................       //GET INPUTS 
....................       //Vspeedhappens in interrupts 
....................       set_adc_channel(Acaps_channel); 
....................       ADC_DELAY; 
....................       Acaps = read_adc(); 
....................        
....................       set_adc_channel(Athrottle_channel); 
....................       ADC_DELAY; 
....................       Athrottle = read_adc(); 
....................       if (!input(ALGORITHM_INPUT_SWITCH)){ 
....................       current_servo_position = right_position - (Athrottle-Athrottle_Min)*4; 
....................       #ifdef DEBUG 
....................             printf("State: Weak Hybrid \n");   
....................          #else 
....................             delay_ms(250); 
....................          #endif 
....................       if ((Athrottle>Athrottle_3quarter)&&(Acaps>A_CAPS_MIN)){ 
....................          //set electric motor to drive 
....................          #ifdef DEBUG 
....................             printf("drive \n");   
....................          #else 
....................             delay_ms(250); 
....................          #endif 
....................          CURRENTLY_CHARGING=1; 
....................          output_low(brake_pin); 
....................          output_low(Electric_Controller_Switch); 
....................          write_dac(2000+ELEC_CONTROLLER_OFFSET); 
....................       }else if ((Acaps<A_CAPS_MAX)&&(vSpeed<V_SPEED_REGEN_MIN)){ 
....................          // set electric motor to charge 
....................          #ifdef DEBUG 
....................             printf("breaking \n");   
....................          #else 
....................             delay_ms(250); 
....................          #endif 
....................          if (CURRENTLY_CHARGING==1){ 
....................                 trickBreaking(); 
....................          } 
....................          CURRENTLY_CHARGING=0; 
....................          output_high(brake_pin); 
....................          output_high(Electric_Controller_Switch); 
....................          write_dac(1200+ELEC_CONTROLLER_OFFSET); 
....................       }else { 
....................          //set electric motor to zero 
....................          #ifdef DEBUG 
....................             printf("turn off motor \n");   
....................          #else 
....................             delay_ms(250); 
....................          #endif 
....................          CURRENTLY_CHARGING=1; 
....................          write_dac(0); 
....................       } 
....................       }else{ 
....................       if (Athrottle<Athrottle_Min){ 
....................          Athrottle=Athrottle_Min; 
....................       } 
....................       //SET THE STATE 
....................       if (Acaps> (A_CAPS_MAX +10)){ 
....................          //FREAK OUT 
....................          //printf("State: Freak Out \n"); 
....................         output_low(Electric_Controller_Switch); 
....................          #ifdef DEBUG 
....................             printf("State: FREAK OUT \n");   
....................          #else 
....................             delay_ms(250); 
....................          #endif 
....................          write_dac(0); 
....................          //ICE_ON = FALSE; 
....................          ICEthrottle = 0; 
....................          //output_high(Contactor_Switch); 
....................          CHARGING_STATE =EVERYTHING_OFF; 
....................         //return; 
....................         //break; 
....................       } 
....................       else if (Athrottle<(Athrottle_Min+5)){ 
....................          CHARGING_STATE = USER_INPUT_OFF; 
....................          #ifdef DEBUG 
....................             printf("State: Throttle Off \n");   
....................          #else 
....................             delay_ms(250); 
....................          #endif 
....................           
....................          } 
....................       else if (ICE_ON&&(vSpeed<V_SPEED_REGEN_MIN)){ 
....................          #ifdef DEBUG 
....................             printf("State: Speed To Low %ld \n",vSpeed);   
....................          #else 
....................             delay_ms(250); 
....................          #endif 
....................          CHARGING_STATE=SPEED_TO_LOW_ICE_DIRECT; 
....................       } 
....................       else if (checkRunnaway(& pidData)){// INSUFFICIENT_BRAKING_RUNNAWAY_ERROR){ 
....................          #ifdef DEBUG 
....................             printf("State: RUNNAWAY \n");   
....................          #else 
....................             delay_ms(250); 
....................          #endif 
....................          ICE_ON=TRUE; 
....................          CHARGING_STATE=INSUFFICIENT_BRAKING_RUNAWAY; 
....................       } 
....................       else if ((Acaps > A_CAPS_MAX)&&(CHARGING_STATE==CHARGING_ALLOWED||CHARGING_STATE==CHARGING_AND_DISCHARING_ALLOWED)){ 
....................          //Stop Charging they are full 
....................           
....................          #ifdef DEBUG 
....................             printf("State: Caps Full \n");   
....................          #else 
....................             delay_ms(250); 
....................          #endif 
....................           
....................         ICE_ON=FALSE; 
....................         CHARGING_STATE=DISCHARGING_ALLOWED; 
....................       } 
....................       else if ((Acaps < A_CAPS_MIN)&& CHARGING_STATE!=CHARGING_ALLOWED){ 
....................          //Stop running electric, the caps are almost empty 
....................          
....................         #ifdef DEBUG 
....................             printf("State: Caps Empty \n");   
....................          #else 
....................             delay_ms(250); 
....................          #endif 
....................  
....................         ICE_ON=TRUE; 
....................         CHARGING_STATE=CHARGING_ALLOWED; 
....................       } 
....................      else if (A_CAPS_MID_LOW < Acaps < A_CAPS_MID_HIGH){ 
....................         #ifdef DEBUG 
....................             printf("State: Normal \n");   
....................          #else 
....................             delay_ms(250); 
....................          #endif 
....................          CHARGING_STATE=CHARGING_AND_DISCHARING_ALLOWED; 
....................      } 
....................       
....................       
.................... //PID CONTROLLER 
....................       //Servo to mirror Athrottle ->  
....................       //current_servo_position=right_position-(Athrottle-Athrottle_Min)*Athrottle_servo_factor;//(Athrottle/Athrottle_Full)*servo_difference;//(vSpeed/65536.0)*(2500); 
....................       ////printf("Analog Cap %d Analog Throttle %Lu\n",(int) Acaps,Athrottle); 
....................       //current_servo_position =right_position-vSpeed+200; 
....................       ////printf("Speed %lu \n",speeder); 
....................       //SET OUTPUTS  
....................       //The writing of the ICEThrottle happens in interupts and all that is 
....................       //required is updating ICEthrottle 
....................        
....................       returnedValue = pid_Controller((Athrottle-AThrottle_Min),vSpeed,& pidData); 
....................       ELECthrottle = ELECthrottle+returnedValue; 
....................       //printf("Throttle %ld and electhrottle %ld \n",Athrottle,ELECthrottle); 
....................        
....................       
....................       if (ELECthrottle>2500){ 
....................          ELECthrottle=2500; 
....................       } 
....................       else if (ELECthrottle<-1500){ 
....................          ELECthrottle = -1500; 
....................       } 
....................        
....................        
....................       //SET OUTPUTS 
....................       if (CHARGING_STATE==EVERYTHING_OFF||CHARGING_STATE==USER_INPUT_OFF){ 
....................          ICEthrottle = 0; 
....................          ICE_ON = FALSE; 
....................          current_servo_position =right_position; 
....................          write_dac(0); 
....................       } 
....................       else if (CHARGING_STATE==SPEED_TO_LOW_ICE_DIRECT || CHARGING_STATE==INSUFFICIENT_BRAKING_RUNAWAY){ 
....................          if (ELECthrottle>0){ 
....................             current_servo_position =right_position- (3*ELECthrottle); 
....................          } 
....................          else{ 
....................             current_servo_position =right_position; 
....................          } 
....................          ICE_ON = TRUE; 
....................          write_dac(0); 
....................       } 
....................       else{ 
....................       if (ELECthrottle<0){ 
....................         if (CHARGING_STATE==CHARGING_ALLOWED || CHARGING_STATE ==CHARGING_AND_DISCHARING_ALLOWED){ 
....................              if (CURRENTLY_CHARGING==1){ 
....................                 trickBreaking(); 
....................              } 
....................              //ELECthrottle = 300; 
....................              CURRENTLY_CHARGING=0; 
....................              output_high(brake_pin); 
....................              output_high(Electric_Controller_Switch); 
....................              printf("BREAKING \n"); 
....................              write_dac((abs(ELECthrottle)+ELEC_CONTROLLER_OFFSET)); 
....................         } 
....................         else{ 
....................            //Decrease ICE throttle 
....................            write_dac(0); 
....................        
....................         } 
....................       } 
....................       else { 
....................         if (CHARGING_STATE==DISCHARGING_ALLOWED || CHARGING_STATE ==CHARGING_AND_DISCHARING_ALLOWED){ 
....................              CURRENTLY_CHARGING=1; 
....................              output_low(brake_pin); 
....................              output_low(Electric_Controller_Switch); 
....................              printf("ACCELERATING \n"); 
....................              write_dac((abs(ELECthrottle)+ELEC_CONTROLLER_OFFSET)); 
....................         } 
....................         else{ 
....................            //Increase ICE throttle 
....................            write_dac(0); 
....................        
....................         } 
....................           
....................       } 
....................       if (ICE_ON){ 
....................          //printf("ICE NORMAL \n"); 
....................          current_servo_position = left_position +500; 
....................       } 
....................       else{ 
....................          current_servo_position =right_position; 
....................          //printf("ICE OFF \n"); 
....................       } 
....................       } 
....................             
....................    } 
....................    } 
....................  
.................... } 
....................  
.................... #endif 
....................  
.................... boolean checkRunnaway(struct PID_DATA *pid) 
.................... { 
0319:  GOTO   319
.................... //return (pid->sumError > INSUFFICIENT_BRAKING_RUNNAWAY_ERROR); 
.................... return FALSE; 
.................... } 
....................  
.................... /*! \brief Initialisation of PID controller parameters. 
....................  * 
....................  *  Initialise the variables used by the PID algorithm. 
....................  * 
....................  *  \param p_factor  Proportional term. 
....................  *  \param i_factor  Integral term. 
....................  *  \param d_factor  Derivate term. 
....................  *  \param pid  Struct with PID status. 
....................  */ 
.................... void pid_Init(int16 p_factor, int16 i_factor, int16 d_factor, struct PID_DATA *pid) 
.................... // Set up PID controller parameters 
.................... { 
....................   // Start values for PID controller 
....................   pid->sumError = 0; 
*
013A:  MOVLW  02
013B:  ADDWF  59,W
013C:  MOVWF  04
013D:  INCF   04,F
013E:  INCF   04,F
013F:  INCF   04,F
0140:  CLRF   00
0141:  DECF   04,F
0142:  CLRF   00
0143:  DECF   04,F
0144:  CLRF   00
0145:  DECF   04,F
0146:  CLRF   00
....................   pid->lastProcessValue = 0; 
0147:  MOVF   59,W
0148:  MOVWF  04
0149:  INCF   04,F
014A:  CLRF   00
014B:  DECF   04,F
014C:  CLRF   00
....................   // Tuning constants for PID loop 
....................   pid->P_Factor = p_factor; 
014D:  MOVLW  06
014E:  ADDWF  59,W
014F:  MOVWF  04
0150:  INCF   04,F
0151:  MOVF   54,W
0152:  MOVWF  00
0153:  DECF   04,F
0154:  MOVF   53,W
0155:  MOVWF  00
....................   pid->I_Factor = i_factor; 
0156:  MOVLW  08
0157:  ADDWF  59,W
0158:  MOVWF  04
0159:  INCF   04,F
015A:  MOVF   56,W
015B:  MOVWF  00
015C:  DECF   04,F
015D:  MOVF   55,W
015E:  MOVWF  00
....................   pid->D_Factor = d_factor; 
015F:  MOVLW  0A
0160:  ADDWF  59,W
0161:  MOVWF  04
0162:  INCF   04,F
0163:  MOVF   58,W
0164:  MOVWF  00
0165:  DECF   04,F
0166:  MOVF   57,W
0167:  MOVWF  00
....................   // Limits to avoid overflow 
....................   pid->maxError = MAX_INT / (pid->P_Factor + 1); 
0168:  MOVLW  0C
0169:  ADDWF  59,W
016A:  MOVWF  5A
016B:  MOVLW  06
016C:  ADDWF  59,W
016D:  MOVWF  04
016E:  INCF   04,F
016F:  MOVF   00,W
0170:  MOVWF  5C
0171:  DECF   04,F
0172:  MOVF   00,W
0173:  MOVWF  5B
0174:  MOVLW  01
0175:  ADDWF  5B,W
0176:  MOVWF  21
0177:  MOVF   5C,W
0178:  MOVWF  23
0179:  BTFSC  03.0
017A:  INCF   23,F
017B:  MOVF   21,W
017C:  MOVWF  5D
017D:  MOVF   23,W
017E:  MOVWF  5E
017F:  MOVLW  7F
0180:  MOVWF  60
0181:  MOVLW  FF
0182:  MOVWF  5F
0183:  MOVF   5E,W
0184:  MOVWF  62
0185:  MOVF   5D,W
0186:  MOVWF  61
*
01AB:  MOVF   5A,W
01AC:  MOVWF  04
01AD:  INCF   04,F
01AE:  MOVF   22,W
01AF:  MOVWF  00
01B0:  DECF   04,F
01B1:  MOVF   21,W
01B2:  MOVWF  00
....................   ////printf("Max %ld factor %ld and pid %ld",MAX_INT,pid->I_Factor,pid->maxError); 
....................   pid->maxSumError = MAX_I_TERM / (pid->I_Factor + 1); 
01B3:  MOVLW  0E
01B4:  ADDWF  59,W
01B5:  MOVWF  5A
01B6:  MOVLW  08
01B7:  ADDWF  59,W
01B8:  MOVWF  04
01B9:  INCF   04,F
01BA:  MOVF   00,W
01BB:  MOVWF  5C
01BC:  DECF   04,F
01BD:  MOVF   00,W
01BE:  MOVWF  5B
01BF:  MOVLW  01
01C0:  ADDWF  5B,W
01C1:  MOVWF  21
01C2:  MOVF   5C,W
01C3:  MOVWF  23
01C4:  BTFSC  03.0
01C5:  INCF   23,F
01C6:  MOVF   21,W
01C7:  MOVWF  5D
01C8:  MOVF   23,W
01C9:  MOVWF  5E
01CA:  MOVF   04,W
01CB:  MOVWF  5F
01CC:  MOVLW  3F
01CD:  MOVWF  63
01CE:  MOVLW  FF
01CF:  MOVWF  62
01D0:  MOVWF  61
01D1:  MOVWF  60
01D2:  CLRF   67
01D3:  CLRF   66
01D4:  MOVF   5E,W
01D5:  MOVWF  65
01D6:  MOVF   5D,W
01D7:  MOVWF  64
*
0218:  MOVF   5F,W
0219:  MOVWF  04
021A:  MOVF   5A,W
021B:  MOVWF  04
021C:  MOVF   20,W
021D:  MOVWF  00
021E:  INCF   04,F
021F:  MOVF   21,W
0220:  MOVWF  00
0221:  INCF   04,F
0222:  MOVF   22,W
0223:  MOVWF  00
0224:  INCF   04,F
0225:  MOVF   23,W
0226:  MOVWF  00
.................... } 
0227:  BCF    0A.3
0228:  GOTO   2EA (RETURN)
....................  
....................  
.................... /*! \brief PID control algorithm. 
....................  * 
....................  *  Calculates output from setpoint, process value and PID status. 
....................  * 
....................  *  \param setPoint  Desired value. 
....................  *  \param processValue  Measured value. 
....................  *  \param pid_st  PID status struct. 
....................  */ 
.................... int16 pid_Controller(int16 setPoint, int16 processValue, struct PID_DATA *pid_st) 
.................... { 
....................   signed int16 error, p_term, d_term; 
....................   signed int32 i_term, ret, temp; 
....................     processValue=processValue/4; 
....................   ////printf("input %ld speed %ld ",setPoint,processValue); 
....................   error = setPoint - processValue; 
....................    
....................   // Calculate Pterm and limit error overflow 
....................    
....................   if (error > (signed int16) pid_st->maxError){ 
....................     p_term = MAX_INT; 
....................     ////printf("p greater error %ld a %ld p %ld",error,pid_st->maxError,p_term); 
....................  
....................   } 
....................   else if (error < (signed int16) -pid_st->maxError){ 
....................     p_term = -MAX_INT; 
....................     ////printf("p less error %ld a %ld p %ld",error,-pid_st->maxError,p_term); 
....................  
....................   } 
....................   else{ 
....................     p_term = (signed int16) (pid_st->P_Factor * (float) error); 
....................     ////printf("error %ld a %ld p %ld",error,pid_st->maxError,p_term); 
....................   } 
....................    
....................   // Calculate Iterm and limit integral runaway 
....................   temp = pid_st->sumError + error; 
....................   if(temp > (signed int32)pid_st->maxSumError){ 
....................     i_term = MAX_I_TERM; 
....................     pid_st->sumError = pid_st->maxSumError; 
....................     ////printf("\n greater temp %ld a %ld sum %ld",temp,pid_st->maxSumError,pid_st->sumError); 
....................  
....................  } 
....................   else if(temp < (signed int32)-pid_st->maxSumError){ 
....................     i_term = -MAX_I_TERM; 
....................     pid_st->sumError = -pid_st->maxSumError; 
....................     ////printf("\n less temp %ld a %ld sum %ld",temp,pid_st->maxSumError,pid_st->sumError); 
....................  
....................   } 
....................   else{ 
....................     pid_st->sumError = temp; 
....................     i_term = pid_st->I_Factor * pid_st->sumError; 
....................     ////printf("\n eror temp %ld i_term %ld sum %ld error %ld ",temp,i_term,pid_st->sumError,error); 
....................  
....................   } 
....................  
....................   // Calculate Dterm 
....................   d_term = pid_st->D_Factor * (pid_st->lastProcessValue - processValue); 
.................... ////printf("\n p_term %ld d_term %ld i_term %ld",p_term,d_term,i_term); 
....................   pid_st->lastProcessValue = processValue; 
....................  
....................   //ret = (p_term + i_term + d_term) / SCALING_FACTOR; 
....................    ret = (p_term+d_term+(signed int16)i_term) / SCALING_FACTOR; 
....................   if(ret > MAX_INT){ 
....................     ret = MAX_INT; 
....................   } 
....................   else if(ret < -MAX_INT){ 
....................     ret = -MAX_INT; 
....................   } 
....................  
....................   return((signed int16)ret); 
.................... } 
....................  
.................... /*! \brief Resets the integrator. 
....................  * 
....................  *  Calling this function will reset the integrator in the PID regulator. 
....................  */ 
.................... void pid_Reset_Integrator(pidData_t *pid_st) 
.................... { 
....................   pid_st->sumError = 0; 
.................... } 
....................  

Configuration Fuses:
   Word  1: 373A   HS NOWDT NOPUT DEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
